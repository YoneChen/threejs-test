/*! For license information please see handFire.923028ec3bd36192ca11.js.LICENSE.txt */
(self.webpackChunkbabylon_boilerplate=self.webpackChunkbabylon_boilerplate||[]).push([[631],{9987:function(t,e,n){"use strict";n.r(e),n.d(e,{HandPose:function(){return k},load:function(){return T}});var r=n(1928),o=n(6743);function s(t,e,n,r){return new(n||(n=Promise))((function(o,s){function a(t){try{u(r.next(t))}catch(t){s(t)}}function i(t){try{u(r.throw(t))}catch(t){s(t)}}function u(t){var e;t.done?o(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(a,i)}u((r=r.apply(t,e||[])).next())}))}function a(t,e){var n,r,o,s,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return s={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function i(s){return function(i){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(o=2&s[0]?r.return:s[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,s[1])).done)return o;switch(r=0,o&&(s=[2&s[0],o.value]),s[0]){case 0:case 1:o=s;break;case 4:return a.label++,{value:s[1],done:!1};case 5:a.label++,r=s[1],s=[0];continue;case 7:s=a.ops.pop(),a.trys.pop();continue;default:if(!((o=(o=a.trys).length>0&&o[o.length-1])||6!==s[0]&&2!==s[0])){a=0;continue}if(3===s[0]&&(!o||s[1]>o[0]&&s[1]<o[3])){a.label=s[1];break}if(6===s[0]&&a.label<o[1]){a.label=o[1],o=s;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(s);break}o[2]&&a.ops.pop(),a.trys.pop();continue}s=e.call(t,a)}catch(t){s=[6,t],r=0}finally{n=o=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,i])}}}function i(t){return[Math.abs(t.endPoint[0]-t.startPoint[0]),Math.abs(t.endPoint[1]-t.startPoint[1])]}function u(t){return[t.startPoint[0]+(t.endPoint[0]-t.startPoint[0])/2,t.startPoint[1]+(t.endPoint[1]-t.startPoint[1])/2]}function c(t,e){void 0===e&&(e=1.5);var n=u(t),r=i(t),o=[e*r[0]/2,e*r[1]/2];return{startPoint:[n[0]-o[0],n[1]-o[1]],endPoint:[n[0]+o[0],n[1]+o[1]],palmLandmarks:t.palmLandmarks}}function l(t){var e=u(t),n=i(t),r=Math.max.apply(Math,n)/2;return{startPoint:[e[0]-r,e[1]-r],endPoint:[e[0]+r,e[1]+r],palmLandmarks:t.palmLandmarks}}function p(t,e){var n=[t.endPoint[0]-t.startPoint[0],t.endPoint[1]-t.startPoint[1]],r=[n[0]*e[0],n[1]*e[1]];return{startPoint:[t.startPoint[0]+r[0],t.startPoint[1]+r[1]],endPoint:[t.endPoint[0]+r[0],t.endPoint[1]+r[1]],palmLandmarks:t.palmLandmarks}}var d=function(){function t(t,e,n,r,s,a){this.model=t,this.width=e,this.height=n,this.iouThreshold=s,this.scoreThreshold=a,this.anchors=r.map((function(t){return[t.x_center,t.y_center]})),this.anchorsTensor=(0,o.odF)(this.anchors),this.inputSizeTensor=(0,o.RRF)([e,n]),this.doubleInputSizeTensor=(0,o.RRF)([2*e,2*n])}return t.prototype.normalizeBoxes=function(t){var e=this;return(0,o.lub)((function(){var n=(0,o.tPi)(t,[0,0],[-1,2]),r=(0,o.tPi)(t,[0,2],[-1,2]),s=(0,o.IHx)((0,o.hiC)(n,e.inputSizeTensor),e.anchorsTensor),a=(0,o.hiC)(r,e.doubleInputSizeTensor),i=(0,o.dC7)((0,o.luU)(s,a),e.inputSizeTensor),u=(0,o.dC7)((0,o.IHx)(s,a),e.inputSizeTensor);return(0,o.Izb)([i,u],1)}))},t.prototype.normalizeLandmarks=function(t,e){var n=this;return(0,o.lub)((function(){var r=(0,o.IHx)((0,o.hiC)(t.reshape([-1,7,2]),n.inputSizeTensor),n.anchors[e]);return(0,o.dC7)(r,n.inputSizeTensor)}))},t.prototype.getBoundingBoxes=function(t){return s(this,void 0,void 0,(function(){var e,n,r,s,i,u,c,l,p,d,h,f,m,g,y,x=this;return a(this,(function(a){switch(a.label){case 0:return e=(0,o.lub)((function(){return(0,o.dC7)((0,o.luU)(t,.5),2)})),"webgl"===(0,o.N_N)()?(r=(0,o.OBj)().get("WEBGL_PACK_DEPTHWISECONV"),(0,o.OBj)().set("WEBGL_PACK_DEPTHWISECONV",!0),n=this.model.predict(e),(0,o.OBj)().set("WEBGL_PACK_DEPTHWISECONV",r)):n=this.model.predict(e),s=n.squeeze(),i=(0,o.lub)((function(){return(0,o.XD2)((0,o.tPi)(s,[0,0],[-1,1])).squeeze()})),u=(0,o.tPi)(s,[0,1],[-1,4]),c=this.normalizeBoxes(u),l=console.warn,console.warn=function(){},p=o.BHj.nonMaxSuppression(c,i,1,this.iouThreshold,this.scoreThreshold),console.warn=l,[4,p.array()];case 1:return d=a.sent(),h=[e,n,p,s,c,u,i],0===d.length?(h.forEach((function(t){return t.dispose()})),[2,null]):(f=d[0],m=(0,o.tPi)(c,[f,0],[1,-1]),g=(0,o.tPi)(s,[f,5],[1,14]),y=(0,o.lub)((function(){return x.normalizeLandmarks(g,f).reshape([-1,2])})),h.push(g),h.forEach((function(t){return t.dispose()})),[2,{boxes:m,palmLandmarks:y}])}}))}))},t.prototype.estimateHandBounds=function(t){return s(this,void 0,void 0,(function(){var e,n,r,s,i,u,c,l,p=this;return a(this,(function(a){switch(a.label){case 0:return e=t.shape[1],n=t.shape[2],r=(0,o.lub)((function(){return t.resizeBilinear([p.width,p.height]).div(255)})),[4,this.getBoundingBoxes(r)];case 1:return null===(s=a.sent())?(r.dispose(),[2,null]):(i=s.boxes.arraySync(),u=i[0].slice(0,2),c=i[0].slice(2,4),l=s.palmLandmarks.arraySync(),r.dispose(),s.boxes.dispose(),s.palmLandmarks.dispose(),[2,(d={startPoint:u,endPoint:c,palmLandmarks:l},h=[n/this.width,e/this.height],{startPoint:[d.startPoint[0]*h[0],d.startPoint[1]*h[1]],endPoint:[d.endPoint[0]*h[0],d.endPoint[1]*h[1]],palmLandmarks:d.palmLandmarks.map((function(t){return[t[0]*h[0],t[1]*h[1]]}))})])}var d,h}))}))},t}(),h={thumb:[1,2,3,4],indexFinger:[5,6,7,8],middleFinger:[9,10,11,12],ringFinger:[13,14,15,16],pinky:[17,18,19,20],palmBase:[0]},f=function(t,e){return[[1,0,t],[0,1,e],[0,0,1]]};function m(t,e){for(var n=0,r=0;r<t.length;r++)n+=t[r]*e[r];return n}function g(t,e){for(var n=[],r=0;r<t.length;r++)n.push(t[r][e]);return n}function y(t,e){for(var n=[],r=t.length,o=0;o<r;o++){n.push([]);for(var s=0;s<r;s++)n[o].push(m(t[o],g(e,s)))}return n}function x(t,e){var n=Math.cos(t),r=Math.sin(t),o=[[n,-r,0],[r,n,0],[0,0,1]],s=y(f(e[0],e[1]),o);return y(s,f(-e[0],-e[1]))}function v(t,e){return[m(t,e[0]),m(t,e[1])]}var b=[0,-.4],w=[0,-.1],$=[0,5,9,13,17,1,2],C=function(){function t(t,e,n,r,o,s){this.regionsOfInterest=[],this.runsWithoutHandDetector=0,this.boundingBoxDetector=t,this.meshDetector=e,this.maxContinuousChecks=o,this.detectionConfidence=s,this.meshWidth=n,this.meshHeight=r,this.maxHandsNumber=1}return t.prototype.getBoxForPalmLandmarks=function(t,e){var n=t.map((function(t){return v(t.concat([1]),e)}));return c(l(p(this.calculateLandmarksBoundingBox(n),b)),3)},t.prototype.getBoxForHandLandmarks=function(t){for(var e=c(l(p(this.calculateLandmarksBoundingBox(t),w)),1.65),n=[],r=0;r<$.length;r++)n.push(t[$[r]].slice(0,2));return e.palmLandmarks=n,e},t.prototype.transformRawCoords=function(t,e,n,r){var o,s,a,c,l=this,p=i(e),d=[p[0]/this.meshWidth,p[1]/this.meshHeight],h=t.map((function(t){return[d[0]*(t[0]-l.meshWidth/2),d[1]*(t[1]-l.meshHeight/2),t[2]]})),f=x(n,[0,0]),g=h.map((function(t){return v(t,f).concat([t[2]])})),y=(s=[[(o=r)[0][0],o[1][0]],[o[0][1],o[1][1]]],a=[o[0][2],o[1][2]],c=[-m(s[0],a),-m(s[1],a)],[s[0].concat(c[0]),s[1].concat(c[1]),[0,0,1]]),b=u(e).concat([1]),w=[m(b,y[0]),m(b,y[1])];return g.map((function(t){return[t[0]+w[0],t[1]+w[1],t[2]]}))},t.prototype.estimateHand=function(t){return s(this,void 0,void 0,(function(){var e,n,r,s,i,c,l,p,d,h,f,m,g,y,v,b,w,$,C,N;return a(this,(function(a){switch(a.label){case 0:return!0!==(e=this.shouldUpdateRegionsOfInterest())?[3,2]:[4,this.boundingBoxDetector.estimateHandBounds(t)];case 1:return null===(n=a.sent())?(t.dispose(),this.regionsOfInterest=[],[2,null]):(this.updateRegionsOfInterest(n,!0),this.runsWithoutHandDetector=0,[3,3]);case 2:this.runsWithoutHandDetector++,a.label=3;case 3:return r=this.regionsOfInterest[0],s=function(t,e){var n;return(n=Math.PI/2-Math.atan2(-(e[1]-t[1]),e[0]-t[0]))-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}(r.palmLandmarks[0],r.palmLandmarks[2]),i=u(r),c=[i[0]/t.shape[2],i[1]/t.shape[1]],l=o.BHj.rotateWithOffset(t,s,0,c),p=x(-s,i),d=!0===e?this.getBoxForPalmLandmarks(r.palmLandmarks,p):r,h=function(t,e,n){var r=e.shape[1],s=e.shape[2],a=[[t.startPoint[1]/r,t.startPoint[0]/s,t.endPoint[1]/r,t.endPoint[0]/s]];return o.BHj.cropAndResize(e,a,[0],n)}(d,l,[this.meshWidth,this.meshHeight]),f=h.div(255),h.dispose(),l.dispose(),"webgl"===(0,o.N_N)()?(g=(0,o.OBj)().get("WEBGL_PACK_DEPTHWISECONV"),(0,o.OBj)().set("WEBGL_PACK_DEPTHWISECONV",!0),m=this.meshDetector.predict(f),(0,o.OBj)().set("WEBGL_PACK_DEPTHWISECONV",g)):m=this.meshDetector.predict(f),y=m[0],v=m[1],f.dispose(),b=y.dataSync()[0],y.dispose(),b<this.detectionConfidence?(v.dispose(),this.regionsOfInterest=[],[2,null]):(w=(0,o.XLQ)(v,[-1,3]),$=w.arraySync(),v.dispose(),w.dispose(),C=this.transformRawCoords($,d,s,p),N=this.getBoxForHandLandmarks(C),this.updateRegionsOfInterest(N,!1),[2,{landmarks:C,handInViewConfidence:b,boundingBox:{topLeft:N.startPoint,bottomRight:N.endPoint}}])}}))}))},t.prototype.calculateLandmarksBoundingBox=function(t){var e=t.map((function(t){return t[0]})),n=t.map((function(t){return t[1]}));return{startPoint:[Math.min.apply(Math,e),Math.min.apply(Math,n)],endPoint:[Math.max.apply(Math,e),Math.max.apply(Math,n)]}},t.prototype.updateRegionsOfInterest=function(t,e){if(e)this.regionsOfInterest=[t];else{var n=this.regionsOfInterest[0],r=0;if(null!=n&&null!=n.startPoint){var o=t.startPoint,s=o[0],a=o[1],i=t.endPoint,u=i[0],c=i[1],l=n.startPoint,p=l[0],d=l[1],h=n.endPoint,f=h[0],m=h[1],g=Math.max(s,p),y=Math.max(a,d),x=(Math.min(u,f)-g)*(Math.min(c,m)-y);r=x/((u-s)*(c-a)+(f-p)*(m-a)-x)}this.regionsOfInterest[0]=r>.8?n:t}},t.prototype.shouldUpdateRegionsOfInterest=function(){return this.regionsOfInterest.length!==this.maxHandsNumber||this.runsWithoutHandDetector>=this.maxContinuousChecks},t}();function N(){return s(this,void 0,void 0,(function(){return a(this,(function(t){return[2,(0,r.YL)("https://tfhub.dev/mediapipe/tfjs-model/handdetector/1/default/1",{fromTFHub:!0})]}))}))}function I(){return s(this,void 0,void 0,(function(){return a(this,(function(t){return[2,(0,r.YL)("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1",{fromTFHub:!0})]}))}))}function E(){return s(this,void 0,void 0,(function(){return a(this,(function(t){return[2,o.D5U.he("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1/anchors.json?tfjs-format=file").then((function(t){return t.json()}))]}))}))}function T(t){var e=void 0===t?{}:t,n=e.maxContinuousChecks,r=void 0===n?1/0:n,o=e.detectionConfidence,i=void 0===o?.8:o,u=e.iouThreshold,c=void 0===u?.3:u,l=e.scoreThreshold,p=void 0===l?.5:l;return s(this,void 0,void 0,(function(){var t,e,n,o,s,u;return a(this,(function(a){switch(a.label){case 0:return[4,Promise.all([E(),N(),I()])];case 1:return t=a.sent(),e=t[0],n=t[1],o=t[2],s=new d(n,256,256,e,c,p),u=new C(s,o,256,256,r,i),[2,new k(u)]}}))}))}var k=function(){function t(t){this.pipeline=t}return t.getAnnotations=function(){return h},t.prototype.estimateHands=function(t,e){return void 0===e&&(e=!1),s(this,void 0,void 0,(function(){var n,r,s,i,u,c,l,p,d;return a(this,(function(a){switch(a.label){case 0:return n=function(t){return t instanceof o.esB?[t.shape[0],t.shape[1]]:[t.height,t.width]}(t),r=n[1],s=(0,o.lub)((function(){return t instanceof o.esB||(t=o.Xhn.n(t)),t.toFloat().expandDims(0)})),[4,this.pipeline.estimateHand(s)];case 1:if(i=a.sent(),s.dispose(),null===i)return[2,[]];for(u=i,!0===e&&(u=function(t,e){var n=t.handInViewConfidence,r=t.landmarks,o=t.boundingBox;return{handInViewConfidence:n,landmarks:r.map((function(t){return[e-1-t[0],t[1],t[2]]})),boundingBox:{topLeft:[e-1-o.topLeft[0],o.topLeft[1]],bottomRight:[e-1-o.bottomRight[0],o.bottomRight[1]]}}}(i,r)),c={},l=0,p=Object.keys(h);l<p.length;l++)d=p[l],c[d]=h[d].map((function(t){return u.landmarks[t]}));return[2,[{handInViewConfidence:u.handInViewConfidence,boundingBox:u.boundingBox,landmarks:u.landmarks,annotations:c}]]}}))}))},t}()},1263:function(t,e,n){"use strict";var r={};n.r(r),n.d(r,{addImpl:function(){return H},ceilImpl:function(){return Y},expImpl:function(){return Q},expm1Impl:function(){return Z},floorImpl:function(){return J},logImpl:function(){return tt},maxImpl:function(){return et},multiplyImpl:function(){return nt},notEqualImpl:function(){return ot},rsqrtImpl:function(){return st},simpleAbsImpl:function(){return M},sliceImpl:function(){return at},squaredDifferenceImpl:function(){return it},subImpl:function(){return ut},transposeImpl:function(){return lt},uniqueImpl:function(){return pt}});var o=n(6743);const s={},a={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function i(t){if(!(t in s)){const e=function(t){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=function(t){if("undefined"!=typeof OffscreenCanvas&&2===t)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);return e.addEventListener("webglcontextlost",(e=>{e.preventDefault(),delete s[t]}),!1),1===t?e.getContext("webgl",a)||e.getContext("experimental-webgl",a):e.getContext("webgl2",a)}(t);if(null===e)return console.log("Could not get context for WebGL version",t),null;s[t]=e}const e=s[t];return e.isContextLost()?(delete s[t],i(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),s[t])}var u,c,l;function p(t,e){return[e,t]}function d(t){const e=o.D5U.NA(t),n=Math.ceil(e/4);return o.D5U.YP(n)}function h(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function f(t,e){const n=t;let r,s,a,i,u,c,l,p,d,h;return 2===(0,o.OBj)().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,u=n.RED,l=4,p=1,d=n.HALF_FLOAT,h=n.FLOAT):(r=t.RGBA,s=t.RGBA,a=t.RGBA,i=n.RGBA,u=t.RGBA,l=4,p=4,d=null!=e?e.HALF_FLOAT_OES:null,h=t.FLOAT),c=t.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:u,downloadTextureFormat:c,downloadUnpackNumChannels:l,defaultNumChannels:p,textureTypeHalfFloat:d,textureTypeFloat:h}}function m(t,e){const n=e();return(0,o.OBj)().getBool("DEBUG")&&function(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+function(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}(t,e))}(t),n}function g(t){return!!((0,o.OBj)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||5.96e-8<Math.abs(t)&&Math.abs(t)<65504)}function y(t,e){return I(t,(()=>t.getExtension(e)),'Extension "'+e+'" not supported on this browser.')}!function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"}(u||(u={})),function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(c||(c={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(l||(l={}));const x=/ERROR: [0-9]+:([0-9]+):/g;function v(t,e){if(m(t,(()=>t.validateProgram(e))),!1===t.getProgramParameter(e,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function b(t,e,n,r,o,s,a){const i=t.getAttribLocation(e,n);return-1!==i&&(m(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,r))),m(t,(()=>t.vertexAttribPointer(i,o,t.FLOAT,!1,s,a))),m(t,(()=>t.enableVertexAttribArray(i))),!0)}function w(t,e,n,r){m(t,(()=>function(t,e,n){(function(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(t,n),m(t,(()=>t.activeTexture(t.TEXTURE0+n))),m(t,(()=>t.bindTexture(t.TEXTURE_2D,e)))}(t,e,r))),m(t,(()=>t.uniform1i(n,r)))}function $(t,e,n){m(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,n))),m(t,(()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0)))}function C(t,e){m(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,e))),m(t,(()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0)))}function N(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}(t,e))}function I(t,e,n){const r=m(t,(()=>e()));if(null==r)throw new Error(n);return r}function E(t,e=2){return o.D5U.NA(t.slice(0,t.length-e))}function T(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function k(t){let e=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(e=[E(t),...T(t)]),e}function S(t){return t%2==0}function R(t,e){if(t=t.slice(-2),e=e.slice(-2),o.D5U.cO(t,e))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){const n=t.slice(-1)[0],r=e.slice(-1)[0];if(n===r)return!0;if(S(n)&&S(r)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&S(t[0])&&S(e[0])}let _,A;function D(t,e){return null!=t.getExtension(e)}function O(t){try{if(null!=i(t))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function F(t){const e=f(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const o=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(r),o}function B(t,e){Array.isArray(t)||(t=[t]),t.forEach((t=>{null!=t&&o.D5U.hu("complex64"!==t.dtype,(()=>`${e} does not support complex64 tensors in the WebGL backend.`))}))}const P=(0,o.OBj)();function M(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}function L(t){return(e,n,r,s,a)=>{const i=o.Wap.assertAndGetBroadcastShape(e,n),u=i.length,c=o.D5U.e3(i),l=o.D5U.NA(i),p=o.D5U.WP(a,l),d=e.length,h=n.length,f=o.D5U.e3(e),m=o.D5U.e3(n),g=o.Wap.getBroadcastDims(e,i),y=o.Wap.getBroadcastDims(n,i);if(g.length+y.length===0)for(let e=0;e<p.length;++e)p[e]=t(r[e%r.length],s[e%s.length]);else for(let e=0;e<p.length;++e){const n=o.D5U.NE(e,u,c),a=n.slice(-d);g.forEach((t=>a[t]=0));const i=o.D5U.qy(a,d,f),l=n.slice(-h);y.forEach((t=>l[t]=0));const x=o.D5U.qy(l,h,m);p[e]=t(r[i],s[x])}return[p,i]}}function V(t,e){Array.isArray(t)||(t=[t]),t.forEach((t=>{null!=t&&o.D5U.hu("complex64"!==t.dtype,(()=>`${e} does not support complex64 tensors in the CPU backend.`))}))}function W(t){const{inputs:e,backend:n}=t,{real:r,imag:o}=e,s=n.data.get(r.dataId).values,a=n.data.get(o.dataId).values,i=n.makeTensorInfo(r.shape,"complex64");return n.data.get(i.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(o.shape,"float32",a)},i}function U(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function z(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dtype:a}=r;if("complex64"===a){if("complex64"===s.dtype)return U({inputs:{x:s},backend:n});const t=o.lls(s.shape),e=z({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),r=W({inputs:{real:e,imag:t},backend:n});return t.dispose(),n.disposeIntermediateTensorInfo(e),r}if("complex64"===s.dtype){const t=function(t){const{inputs:e,backend:n}=t,{input:r}=e,o=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(o.dataId).values;return n.makeTensorInfo(o.shape,o.dtype,s)}({inputs:{input:s},backend:n}),e=z({inputs:{x:t},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(t),e}if(!o.D5U.QB(s.dtype,a)){const t=U({inputs:{x:s},backend:n});return{dataId:t.dataId,shape:t.shape,dtype:a}}if("int32"===a){const t=n.data.get(s.dataId).values,e=Int32Array.from(t);return n.makeTensorInfo(s.shape,"int32",e)}if("bool"===a){const t=n.data.get(s.dataId).values,e=o.D5U.Os([0],s.dtype),[r,a]=L(((t,e)=>t!==e?1:0))(s.shape,[],t,e,"bool");return n.makeTensorInfo(a,"bool",r)}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}function G(t,e,n,r){return null==n?({inputs:n,backend:o})=>{const{a:s,b:a}=n,i=o;V([s,a],t);const u=i.data.get(s.dataId).values,c=i.data.get(a.dataId).values,l=r||s.dtype,[p,d]=e(s.shape,a.shape,u,c,l);return i.makeTensorInfo(d,l,p)}:({inputs:t,backend:o})=>{const{a:s,b:a}=t,i=o;if("complex64"===s.dtype||"complex64"===a.dtype){const t=z({inputs:{x:s},backend:i,attrs:{dtype:"complex64"}}),e=i.data.get(t.dataId),r=e.complexTensorInfos.real,o=e.complexTensorInfos.imag,u=i.data.get(r.dataId).values,c=i.data.get(o.dataId).values,l=z({inputs:{x:a},backend:i,attrs:{dtype:"complex64"}}),p=i.data.get(l.dataId),d=p.complexTensorInfos.real,h=p.complexTensorInfos.imag,f=i.data.get(d.dataId).values,m=i.data.get(h.dataId).values,[g,y,x]=n(s.shape,a.shape,u,c,f,m),v=i.makeTensorInfo(x,"float32",g),b=i.makeTensorInfo(x,"float32",y),w=W({inputs:{real:v,imag:b},backend:i});return i.disposeIntermediateTensorInfo(t),i.disposeIntermediateTensorInfo(l),i.disposeIntermediateTensorInfo(v),i.disposeIntermediateTensorInfo(b),w}{const t=i.data.get(s.dataId).values,n=i.data.get(a.dataId).values,o=r||s.dtype,[u,c]=e(s.shape,a.shape,t,n,o);return i.makeTensorInfo(c,o,u)}}}function X(t){return(e,n,r,s,a,i)=>{const u=o.Wap.assertAndGetBroadcastShape(e,n),c=o.D5U.NA(u),l=u.length,p=o.D5U.e3(u),d=o.D5U.WP("float32",c),h=o.D5U.WP("float32",c),f=o.Wap.getBroadcastDims(e,u),m=o.Wap.getBroadcastDims(n,u),g=o.Wap.mergeRealAndImagArrays(r,s),y=o.Wap.mergeRealAndImagArrays(a,i),x=e.length,v=o.D5U.e3(e),b=n.length,w=o.D5U.e3(n);if(f.length+m.length===0)for(let e=0;e<d.length;e++){const n=e%g.length,r=e%y.length,o=t(g[2*n],g[2*n+1],y[2*r],y[2*r+1]);d[e]=o.real,h[e]=o.imag}else for(let e=0;e<d.length;e++){const n=o.D5U.NE(e,l,p),r=n.slice(-x);f.forEach((t=>r[t]=0));const s=o.D5U.qy(r,x,v),a=n.slice(-b);m.forEach((t=>a[t]=0));const i=o.D5U.qy(a,b,w),u=t(g[2*s],g[2*s+1],y[2*i],y[2*i+1]);d[e]=u.real,h[e]=u.imag}return[d,h,u]}}P.registerFlag("HAS_WEBGL",(()=>P.getNumber("WEBGL_VERSION")>0)),P.registerFlag("WEBGL_VERSION",(()=>O(2)?2:O(1)?1:0)),P.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),P.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===P.get("WEBGL_VERSION"))),P.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),P.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),P.registerFlag("WEBGL_PACK",(()=>P.getBool("HAS_WEBGL"))),P.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>P.getBool("WEBGL_PACK"))),P.registerFlag("WEBGL_PACK_CLIP",(()=>P.getBool("WEBGL_PACK"))),P.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>!1)),P.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>P.getBool("WEBGL_PACK"))),P.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>P.getBool("WEBGL_PACK"))),P.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>P.getBool("WEBGL_PACK"))),P.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>P.getBool("WEBGL_PACK"))),P.registerFlag("WEBGL_PACK_REDUCE",(()=>P.getBool("WEBGL_PACK"))),P.registerFlag("WEBGL_LAZILY_UNPACK",(()=>P.getBool("WEBGL_PACK"))),P.registerFlag("WEBGL_CONV_IM2COL",(()=>P.getBool("WEBGL_PACK"))),P.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(t){if(null==_){const e=i(t);_=e.getParameter(e.MAX_TEXTURE_SIZE)}return _}(P.getNumber("WEBGL_VERSION")))),P.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(t){if(null==A){const e=i(t);A=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,A)}(P.getNumber("WEBGL_VERSION")))),P.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const t=P.getNumber("WEBGL_VERSION");return 0===t?0:function(t){if(0===t)return 0;let e;const n=i(t);return e=D(n,"EXT_disjoint_timer_query_webgl2")&&2===t?2:D(n,"EXT_disjoint_timer_query")?1:0,e}(t)})),P.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>P.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!o.C2$.t())),P.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(t){if(0===t)return!1;const e=i(t);if(1===t){if(!D(e,"OES_texture_float"))return!1}else if(!D(e,"EXT_color_buffer_float"))return!1;return F(e)}(P.getNumber("WEBGL_VERSION")))),P.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!P.getBool("WEBGL_FORCE_F16_TEXTURES")&&P.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),P.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>function(t){if(0===t)return!1;const e=i(t);if(1!==t){if(D(e,"EXT_color_buffer_float"))return F(e);const t="EXT_color_buffer_half_float";if(D(e,t)){const n=e.getExtension(t);return function(t,e){const n=f(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const s=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(o),s}(e,n)}return!1}return!!D(e,"OES_texture_float")&&!!D(e,"WEBGL_color_buffer_float")&&F(e)}(P.getNumber("WEBGL_VERSION")))),P.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(t=P.getNumber("WEBGL_VERSION"))&&null!=i(t).fenceSync;var t})),P.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>P.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),P.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)})),o.SYM,o.Zz9,o.iJz,o.xJR,o.RFZ;const H=L(((t,e)=>t+e)),j=X(((t,e,n,r)=>({real:t+n,imag:e+r})));function K(t){return(e,n,r)=>{const s=o.D5U.WP(n,e.length);for(let n=0;n<e.length;++n)s[n]=t(e[n],r);return s}}function q(t,e,n){return({inputs:r,attrs:o,backend:s})=>{const{x:a}=r;if(V(a,t),"string"===a.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const i=s,u=i.data.get(a.dataId).values,c=n||a.dtype,l=e(u,c,o);return i.makeTensorInfo(a.shape,c,l)}}G(o.mm_,H,j),o.mm_;const Y=K((t=>Math.ceil(t))),Q=(q(o.gJX,Y),o.gJX,K((t=>Math.exp(t)))),Z=(q(o.NEP,Q),o.NEP,K((t=>Math.expm1(t)))),J=(q(o.Y0y,Z),o.Y0y,K((t=>Math.floor(t)))),tt=(q(o.OR,J),o.OR,K((t=>Math.log(t))));function et(t,e,n,r){const s=o.D5U.WP(r,o.D5U.NA(n));for(let n=0;n<s.length;++n){const r=n*e;let o=t[r];for(let n=0;n<e;++n){const e=t[r+n];e>o&&(o=e)}s[n]=o}return s}q(o.ZbH,tt),o.ZbH;const nt=L(((t,e)=>t*e)),rt=X(((t,e,n,r)=>({real:t*n-e*r,imag:t*r+e*n}))),ot=(G(o.wYn,nt,rt),o.wYn,L(((t,e)=>t!==e?1:0))),st=(G(o.yQU,ot,null,"bool"),o.yQU,K((t=>1/Math.sqrt(t))));function at(t,e,n,r,s){const a=o.kuN.isSliceContinous(r,e,n),i=o.D5U.NA(n),u=o.D5U.e3(r);if(a){const n=o.kuN.computeFlatOffset(e,u);return t.subarray(n,n+i)}const c=o.D5U.WP(s,i);for(let s=0;s<i;++s){const a=n.length,i=o.D5U.e3(n),l=o.D5U.NE(s,a,i).map(((t,n)=>t+e[n])),p=o.D5U.qy(l,r.length,u);c[s]=t[p]}return c}q(o.bV0,st),o.bV0,o.p2w;const it=L(((t,e)=>{const n=t-e;return n*n})),ut=(G(o._tC,it),o._tC,L(((t,e)=>t-e))),ct=X(((t,e,n,r)=>({real:t-n,imag:e-r})));function lt(t,e,n,r,s){const a=e.length,i=o.D5U.NA(e),u=o.D5U.e3(e),c=o.D5U.e3(s),l=o.D5U.WP(n,o.D5U.NA(s));for(let e=0;e<i;++e){const n=o.D5U.NE(e,a,u),s=new Array(n.length);for(let t=0;t<s.length;t++)s[t]=n[r[t]];l[o.D5U.qy(s,a,c)]=t[e]}return l}function pt(t,e,n,r){const s=o.D5U.EC(e,n)[0],a=[1,n[0],1];for(let t=0;t<s;t++)a[0]*=n[t];a[1]=n[s];for(let t=s+1;t<n.length;t++)a[2]*=n[t];const i={},u=new Int32Array(n[s]),c=new o.YDk(a,r,t),l=[],p=1===a[0]&&1===a[2];for(let e=0;e<n[s];e++){let n;if(p)n=t[e].toString();else{const t=[];for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)t.push(c.get(n,e,r));n=t.join(",")}if(void 0!==i[n])u[e]=i[n];else{const t=Object.keys(i).length;i[n]=t,u[e]=t,l.push(e)}}const d=a.slice();d[1]=Object.keys(i).length;const h=new o.YDk(d,r);l.forEach(((t,e)=>{for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)h.set(c.get(n,t,r),n,e,r)}));const f=n.slice();return f[s]=d[1],{outputValues:h.values,outputShape:f,indices:u}}G(o.Tr8,ut,ct),o.Tr8;const{simpleAbsImpl:dt,addImpl:ht,ceilImpl:ft,expImpl:mt,expm1Impl:gt,floorImpl:yt,logImpl:xt,maxImpl:vt,multiplyImpl:bt,rsqrtImpl:wt,sliceImpl:$t,subImpl:Ct,transposeImpl:Nt,uniqueImpl:It}=r;class Et{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map(((t,e)=>`T${e}`));const n=[];this.variableNames.forEach((t=>{n.push(`float v${t} = get${t}AtOutCoords();`)}));const r=this.variableNames.map((t=>`v${t}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class Tt{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map(((t,e)=>`T${e}`));const n=[];this.variableNames.forEach((t=>{n.push(`vec4 v${t} = get${t}AtOutCoords();`)}));const r=this.variableNames.map((t=>`v${t}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}class kt{constructor(t,e,n){this.variableNames=["A"];const{windowSize:r,batchSize:o,outSize:s}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[o,s];const a="max"===e?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${i};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${a} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}function St(t,e){return["x","y","z","w","u","v"].slice(0,e).map((e=>`${t}.${e}`))}function Rt(t,e){return 1===e?[t]:St(t,e)}function _t(){let t,e,n,r,s,a,i,u,c,l;return 2===(0,o.OBj)().getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",u="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",c="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",u="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",c="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:u,defineSpecialInf:c,defineRound:l}}function At(t,e,n="index"){const r=o.D5U.e3(e);return r.map(((e,o)=>`int ${t[o]} = ${n} / ${e}; ${o===r.length-1?`int ${t[o+1]} = ${n} - ${t[o]} * ${e}`:`index -= ${t[o]} * ${e}`};`)).join("")}function Dt(t){const e=o.D5U.e3(t).map((t=>t.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;\n  }\n`}const Ot="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:Ft}=o.Wap;function Bt(t,e,n,r){const s=[];t.forEach((t=>{const e=o.D5U.NA(t.shapeInfo.logicalShape);t.shapeInfo.isUniform?s.push(`uniform float ${t.name}${e>1?`[${e}]`:""};`):(s.push(`uniform sampler2D ${t.name};`),s.push(`uniform int offset${t.name};`))}));const a=s.join("\n"),i=t.map((t=>function(t,e,n=!1){let r="";r+=n?Mt(t):Pt(t);const s=t.shapeInfo.logicalShape,a=e.logicalShape;return s.length<=a.length&&(r+=n?function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.shapeInfo.logicalShape.length,i=e.logicalShape.length,u=Ft(t.shapeInfo.logicalShape,e.logicalShape),c=Xt(i),l=i-a;let p;const d=["x","y","z","w","u","v"];p=0===a?"":i<2&&u.length>=1?"coords = 0;":u.map((t=>`coords.${d[t+l]} = 0;`)).join("\n");let h="";h=i<2&&a>0?"coords":t.shapeInfo.logicalShape.map(((t,e)=>`coords.${d[e+l]}`)).join(", ");let f="return outputValue;";const m=1===o.D5U.NA(t.shapeInfo.logicalShape),g=1===o.D5U.NA(e.logicalShape);if(1!==a||m||g){if(m&&!g)f=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(u.length){const t=a-2,e=a-1;u.indexOf(t)>-1&&u.indexOf(e)>-1?f="return vec4(outputValue.x);":u.indexOf(t)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":u.indexOf(e)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${c} coords = getOutputCoords();\n      ${p}\n      vec4 outputValue = get${r}(${h});\n      ${f}\n    }\n  `}(t,e):function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.texShape,i=t.shapeInfo.texShape,u=t.shapeInfo.logicalShape.length,c=e.logicalShape.length;if(!t.shapeInfo.isUniform&&u===c&&null==t.shapeInfo.flatOffset&&o.D5U.cO(i,a))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const l=Xt(c),p=Ft(t.shapeInfo.logicalShape,e.logicalShape),d=c-u;let h;const f=["x","y","z","w","u","v"];h=0===u?"":c<2&&p.length>=1?"coords = 0;":p.map((t=>`coords.${f[t+d]} = 0;`)).join("\n");let m="";return m=c<2&&u>0?"coords":t.shapeInfo.logicalShape.map(((t,e)=>`coords.${f[e+d]}`)).join(", "),`\n    float ${s}() {\n      ${l} coords = getOutputCoords();\n      ${h}\n      return get${r}(${m});\n    }\n  `}(t,e)),r}(t,e,r))).join("\n"),u=e.texShape,c=_t(),l=function(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(c);let p,d,h=function(t){return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Lt}\n    ${Vt}\n    ${Wt}\n  `}(c);return e.isPacked?(p=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return 1===n[0]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,e);case 2:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(o.D5U.cO(t,e))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const r=Math.ceil(t[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,e);case 3:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[2]/2),o=r*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,e);default:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[t.length-1]/2),o=r*Math.ceil(t[t.length-2]/2);let s=o,a="",i="b, r, c";for(let e=2;e<t.length-1;e++)s*=t[t.length-e-1],a=`\n      int b${e} = index / ${s};\n      index -= b${e} * ${s};\n    `+a,i=`b${e}, `+i;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${t.length}(${i});\n    }\n  `}(t,e)}}(e.logicalShape,u),d=function(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(c)):(p=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return 1===(n=e)[0]?`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `;case 2:return function(t,e){return o.D5U.cO(t,e)?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));\n      }\n    `:1===t[1]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===t[0]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,e);case 3:return function(t,e){const n=At(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(t,e);case 4:return function(t,e){const n=At(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,e);case 5:return function(t,e){const n=At(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},\n                             ${e[1]}));\n\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,e);case 6:return function(t,e){const n=At(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}var n}(e.logicalShape,u),d=function(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(c)),r&&(h+=Ut),[h,l,d,a,p,i,n].join("\n")}function Pt(t){const e=t.shapeInfo.logicalShape;switch(e.length){case 0:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`float ${n}() {return ${e};}`;const[r,o]=t.shapeInfo.texShape;if(1===r&&1===o)return`\n      float ${n}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const[s,a]=t.shapeInfo.texShape;return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${s}, ${a}, ${zt(e)});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 1:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${Gt(t)}\n      }\n    `;const r=t.shapeInfo.texShape,o=r[0],s=r[1];if(1===s&&1===o)return`\n      float ${n}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=zt(e);return 1===s?`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===o?`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${s}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${o}, ${s}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 2:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t.shapeInfo.texShape;if(null!=s&&o.D5U.cO(e,s)){const t=s[0];return`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${t}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `}const{newShape:a,keptDims:i}=o.D5U.bp(e),u=a;if(u.length<e.length){const e=["row","col"];return`\n      ${Pt(Ht(t,u))}\n      float ${r}(int row, int col) {\n        return ${r}(${jt(e,i)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${Gt(t)}\n      }\n    `;const c=s[0],l=s[1],p=zt(n);return 1===l?`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:1===c?`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${l}.0, 0.5);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${p};\n    vec2 uv = uvFromFlat(${c}, ${l}, index);\n    return sampleTexture(${n}, uv);\n  }\n`}(t);case 3:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[1]*e[2],a=e[2],{newShape:i,keptDims:u}=o.D5U.bp(e),c=i;if(c.length<e.length){const e=["row","col","depth"];return`\n        ${Pt(Ht(t,c))}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${jt(e,u)});\n        }\n      `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${a}, 1)));\n        ${Gt(t)}\n      }\n    `;const l=t.shapeInfo.texShape,p=l[0],d=l[1],h=t.shapeInfo.flatOffset;if(d===s&&null==h)return`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${p}.0);\n          return sampleTexture(${n}, uv);\n        }\n      `;if(d===a&&null==h)return`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${p}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${a} + depth + ${zt(n)};\n        vec2 uv = uvFromFlat(${p}, ${d}, index);\n        return sampleTexture(${n}, uv);\n      }\n  `}(t);case 4:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[3],a=e[2]*s,i=e[1]*a,{newShape:u,keptDims:c}=o.D5U.bp(e);if(u.length<e.length){const e=["row","col","depth","depth2"];return`\n      ${Pt(Ht(t,u))}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${jt(e,c)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${i}, ${a}, ${s}, 1)));\n        ${Gt(t)}\n      }\n    `;const l=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,d=p[0],h=p[1];if(h===i&&null==l)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(h===s&&null==l)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${a} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${h}, index + ${zt(n)});\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 5:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[4],a=e[3]*s,i=e[2]*a,u=e[1]*i,{newShape:c,keptDims:l}=o.D5U.bp(e);if(c.length<e.length){const e=["row","col","depth","depth2","depth3"];return`\n      ${Pt(Ht(t,c))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${jt(e,l)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${u}, ${i}, ${a}, ${s})) +\n          depth3;\n        ${Gt(t)}\n      }\n    `;const p=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,h=d[0],f=d[1];if(f===u&&null==p)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===s&&null==p)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]},\n               ${e[2]*e[3]}, ${e[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${i} + depth * ${a} +\n          depth2 * ${s} + depth3 + ${zt(n)};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 6:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=o.D5U.bp(e);if(s.length<e.length){const e=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Pt(Ht(t,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${jt(e,a)});\n      }\n    `}const i=e[5],u=e[4]*i,c=e[3]*u,l=e[2]*c,p=e[1]*l;if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${p}, ${l}, ${c}, ${u})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${Gt(t)}\n      }\n    `;const d=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,f=h[0],m=h[1];if(m===p&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${l}, ${c}, ${u}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(m===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]*e[4]},\n               ${e[2]*e[3]*e[4]},\n               ${e[3]*e[4]},\n               ${e[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${p} + col * ${l} + depth * ${c} +\n          depth2 * ${u} + depth3 * ${i} + depth4 + ${zt(n)};\n      vec2 uv = uvFromFlat(${f}, ${m}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function Mt(t){switch(t.shapeInfo.logicalShape.length){case 0:return function(t){const e=t.name;return`\n    vec4 ${"get"+e.charAt(0).toUpperCase()+e.slice(1)}() {\n      return ${_t().texture2D}(${e}, halfCR);\n    }\n  `}(t);case 1:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t.shapeInfo.texShape,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],s=_t();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${s.texture2D}(${e}, uv);\n    }\n  `}(t);case 2:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t.shapeInfo.texShape,a=s[0],i=s[1],u=_t();if(null!=s&&o.D5U.cO(e,s))return`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${a}.0);\n\n        return ${u.texture2D}(${n}, uv);\n      }\n    `;const c=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${c[0]}, ${c[1]}, row, col);\n      return ${u.texture2D}(${n}, uv);\n    }\n  `}(t);case 3:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t.shapeInfo.texShape,s=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===e[0]){const n=[1,2],o=["b","row","col"];return`\n        ${Mt(Ht(t,e.slice(1)))}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${jt(o,n)});\n        }\n      `}const a=s[0],i=s[1],u=Math.ceil(e[2]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${a}, ${i}, ${u*Math.ceil(e[1]/2)}, ${u}, b, row, col);\n      return ${_t().texture2D}(${n}, uv);\n    }\n  `}(t);default:return function(t){const e=t.shapeInfo.logicalShape,n=e.length,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],i=a[0],u=a[1],c=Math.ceil(e[n-1]/2);let l=c*Math.ceil(e[n-2]/2),p="int b, int row, int col",d=`b * ${l} + (row / 2) * ${c} + (col / 2)`;for(let t=2;t<n-1;t++)p=`int b${t}, `+p,l*=e[n-t-1],d=`b${t} * ${l} + `+d;return`\n    vec4 ${o}(${p}) {\n      int index = ${d};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${i});\n      return ${_t().texture2D}(${r}, uv);\n    }\n  `}(t)}}const Lt="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Vt="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Wt="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Ut="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function zt(t){return`offset${t}`}function Gt(t){const e=t.name,n=o.D5U.NA(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${e}[i];\n      }\n    }\n  `}function Xt(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function Ht(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function jt(t,e){return e.map((e=>t[e])).join(", ")}class Kt{constructor(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,o.D5U.hu(t.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const s=t[t.length-1],a=Math.ceil(s/e);this.outputShape=t.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,u=i.length,c=Xt(u),l=Rt("coords",u);let p,d;if(1===a){d=u+1;const t=Xt(d);p=`\n        ${t} sourceLocR = ${t}(${l.join()}, 0);\n        ++${l[u-1]};\n        ${t} sourceLocG = ${t}(${l.join()}, 0);\n        ++${l[u-2]};\n        ${t} sourceLocA = ${t}(${l.join()}, 0);\n        --${l[u-1]};\n        ${t} sourceLocB = ${t}(${l.join()}, 0);\n        --${l[u-2]};`}else d=u,p=`\n        ${c} sourceLocR = coords;\n        ++${l[u-1]};\n        ${c} sourceLocG = coords;\n        ++${l[u-2]};\n        ${c} sourceLocA = coords;\n        --${l[u-1]};\n        ${c} sourceLocB = coords;\n        --${l[u-2]};`;const h=["x","y","z","w","u","v"].slice(0,d),f="."+h[d-1],m=h.map((t=>"int "+t)),g=Rt("sourceLocR",d-1).concat("inIdx.r"),y=Rt("sourceLocG",d-1).concat("inIdx.g"),x=Rt("sourceLocB",d-1).concat("inIdx.b"),v=Rt("sourceLocA",d-1).concat("inIdx.a"),b="max"===n?"greaterThan":"lessThan",w=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${x.join()}),\n                             getBestIndicesAChannel(${v.join()})));`,$=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${y.join()}) : 0.,\n            hasNextRow ? getAChannel(${x.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,C=r?"":`\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${C}\n      void main() {\n        ${c} coords = getOutputCoords();\n        bool hasNextCol = ${l[u-1]} < ${i[u-1]-1};\n        bool hasNextRow = ${l[u-2]} < ${i[u-2]-1};\n        ${p}\n        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},\n          sourceLocB${f}, sourceLocA${f}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${$};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${$};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${b}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}class qt{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,s=t.dilationHeight,a=t.dilationWidth,i=t.effectiveFilterHeight,u=t.effectiveFilterWidth,c=i-1-t.padInfo.top,l=u-1-t.padInfo.left,p=1/(e*n);this.userCode=`\n      const ivec2 pads = ivec2(${c}, ${l});\n      const float avgMultiplier = float(${p});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${a}) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Yt{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,o=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,l=t.effectiveFilterDepth,p=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=l-1-t.padInfo.front,f=p-1-t.padInfo.top,m=d-1-t.padInfo.left,g=1/(e*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${h}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n            wD += ${i}) {\n          float dyD = float(dyDCorner + wD) / ${o}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${p};\n              wR += ${u}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${d};\n                wC += ${c}) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Qt="return (a < 0.) ? b * a : a;";class Zt{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=o.Wap.assertAndGetBroadcastShape(e,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const Jt="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";class te{constructor(t,e,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o.Wap.assertAndGetBroadcastShape(e,n);const s=this.outputShape.length;let a="";if(r)if(0===s||1===o.D5U.NA(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(a=`\n          ${Xt(s)} coords = getOutputCoords();\n        `,1===s)a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const t=Rt("coords",s);a+=`\n            bool nextRowOutOfBounds =\n              (${t[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${t[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}class ee{constructor(t){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(t,e){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}class ne{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(t,e){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}class re{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}class oe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,o=t.padInfo.left,s="channelsLast"===t.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${e} - ${r};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${o};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${s}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class se{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,s="channelsLast"===t.dataFormat,a=e-1-t.padInfo.top,i=n-1-t.padInfo.left,u=s?1:2,c=s?2:3,l=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${l}];\n\n        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ae{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,o=t.padInfo.front,s=t.padInfo.top,a=t.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${e} - ${o};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${a};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ie{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,o=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=e-1-t.padInfo.front,u=n-1-t.padInfo.top,c=r-1-t.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${i}, ${u}, ${c});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${o}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ue{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,o=t.padInfo.left,s=t.outChannels/t.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${e} - ${r};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${o};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ce{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,s=e-1-t.padInfo.top,a=n-1-t.padInfo.left,i=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${i}; dm++) {\n              int d2 = d1 * ${i} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class le{constructor(t,e=!1,n=null,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const o=t.padInfo.top,s=t.padInfo.left,a=t.strideHeight,i=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,l=t.filterHeight,p=t.filterWidth,d=4*Math.floor(t.inChannels/4),h=t.inChannels%4,f="channelsLast"===t.dataFormat,m=f?1:2,g=f?2:3,y=f?3:1;let x="",v="";n&&(x=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,v="result = activation(result);");const b=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${a}, ${i});\n      const ivec2 pads = ivec2(${o}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${m}], coords[${g}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${l}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${d}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${f}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===h}) {\n\n              if (${f}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${d}) *\n                    getW(wR, wC, ${d}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${d}, xR, xC) *\n                    getW(wR, wC, ${d}, d2);\n              }\n\n            } else if (${2===h}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${d}, d2),\n                getW(wR, wC, ${d} + 1, d2)\n              );\n\n              if (${f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${d}),\n                  getX(batch, xR, xC, ${d} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${d}, xR, xC),\n                  getX(batch, ${d} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===h}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${d}, d2),\n                getW(wR, wC, ${d} + 1, d2),\n                getW(wR, wC, ${d} + 2, d2)\n              );\n\n              if (${f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${d}),\n                  getX(batch, xR, xC, ${d} + 1),\n                  getX(batch, xR, xC, ${d} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${d}, xR, xC),\n                  getX(batch, ${d} + 1, xR, xC),\n                  getX(batch, ${d} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${b}\n        ${v}\n        setOutput(result);\n      }\n    `}}class pe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,n=t.padInfo.top,r=t.padInfo.left,o=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,l=t.filterDepth,p=t.filterHeight,d=t.filterWidth,h=4*Math.floor(t.inChannels/4),f=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${o}, ${s}, ${a});\n      const ivec3 pads = ivec3(${e}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${l}; wF++) {\n          int xF = xFCorner + wF * ${i};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${c};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${h}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${h}) *\n                  getW(wF, wR, wC, ${h}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1),\n                  getX(batch, xF, xR, xC, ${h} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2),\n                  getW(wF, wR, wC, ${h} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class de{constructor(t,e=!1,n=null,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const o=t.inHeight,s=t.inWidth,a=t.padInfo.top,i=t.padInfo.left,u=t.strideHeight,c=t.strideWidth,l=t.dilationHeight,p=t.dilationWidth,d=t.filterHeight,h=t.filterWidth,f=t.outChannels/t.inChannels;let m="",g="";n&&(m=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,g="result = activation(result);");const y=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${m}\n\n      const ivec2 strides = ivec2(${u}, ${c});\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${f};\n        int q = d2 - d1 * ${f};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${o}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${p};\n\n            if (xC < 0 || xC >= ${s}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${y}\n        ${g}\n        setOutput(result);\n      }\n    `}}class he{constructor(t,e=!1,n=null,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.outShape;const s=t.inHeight,a=t.inWidth,i=t.padInfo.top,u=t.padInfo.left,c=t.strideHeight,l=t.strideWidth,p=t.dilationHeight,d=t.dilationWidth,h=t.filterHeight,f=t.filterWidth,m=f;let g="int xR; int xC; int xCOffset;";for(let t=0;t<h;t++)for(let e=0;e<f;e++)g+=`\n          vec4 xTexelR${t}C${2*e} = vec4(0.);\n          vec4 wR${t}C${e} = vec4(0.);\n          vec4 xR${t}C${e} = vec4(0.);`;for(let t=0;t<h;t++)for(let e=0;e<m;e++){const n=2*e;if(g+=`\n          xR = xRCorner + ${t*p};\n          xC = xCCorner + ${n*d};\n        `,1===l){if(n<f&&(g+=u%2==1?`\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${s} && xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${t}C${n} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${a}) {\n                    xTexelR${t}C${n}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${t}C${n} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${s} && xCOffset >= 0 && xCOffset < ${a}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${a}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${t}C${n} = vec4(previous.zw, xTexelR${t}C${n}.xy);\n                } else {\n                  xR${t}C${n} = vec4(0, 0, xTexelR${t}C${n}.xy);\n                }\n              `:`\n                if(xR >= 0 && xR < ${s} && xC >= 0 && xC < ${a}) {\n                  xTexelR${t}C${n} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${t}C${n} = vec4(0.);\n                }\n\n                xR${t}C${n} = xTexelR${t}C${n};\n              `,n+1<f)){const e=u%2==0?o.D5U.nY(d):d;d%2==0&&u%2==1||d%2!=0&&u%2!=1?(g+=`\n                  xCOffset = xC + ${u%2} + ${e};\n\n                  if(xR >= 0 && xR < ${s} &&\n                    xCOffset >= 0 && xCOffset < ${a}) {\n                    xTexelR${t}C${n+2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `,d>1&&(g+=`\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${s} &&\n                      xCOffset >= 0 && xCOffset < ${a}) {\n                      xTexelR${t}C${n} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${t}C${n} = vec4(0.);\n                    }\n                  `),g+=`\n                  xR${t}C${n+1} = vec4(\n                    xTexelR${t}C${n}.zw, xTexelR${t}C${n+2}.xy);\n                `):g+=`\n                  xCOffset = xC + ${e};\n\n                  if(xR >= 0 && xR < ${s} &&\n                    xCOffset >= 0 && xCOffset < ${a}) {\n                    xTexelR${t}C${n+2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${t}C${n+1} = xTexelR${t}C${n+2};\n                `}}else n<f&&(g+=`\n              if(xR >= 0 && xR < ${s}) {\n            `,u%2==1?(g+=`\n                xCOffset = xC + 1 - ${l};\n                if(xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${t}C${n} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${t}C${n} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${a}) {\n                  xTexelR${t}C${n+2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${t}C${n+2} = vec4(0.);\n                }\n\n                xR${t}C${n} = vec4(\n                  xTexelR${t}C${n}.zw, xTexelR${t}C${n+2}.zw);\n              `,n+1<f&&(g+=`\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${l};\n                  if(xCOffset >= 0 && xCOffset < ${a}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${t}C${n+1} = vec4(xTexelR${t}C${n+2}.xy, final.xy);\n                `)):(g+=`\n                if(xC >= 0 && xC < ${a}) {\n                  xTexelR${t}C${n} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${t}C${n} = vec4(0.);\n                }\n\n                xCOffset = xC + ${l};\n                if(xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${t}C${n+2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${t}C${n+2} = vec4(0.);\n                }\n\n                xR${t}C${n} = vec4(\n                  xTexelR${t}C${n}.xy, xTexelR${t}C${n+2}.xy);\n              `,n+1<f&&(g+=`\n                  xR${t}C${n+1} = vec4(\n                    xTexelR${t}C${n}.zw, xTexelR${t}C${n+2}.zw);\n                `)),g+="}");n<f&&(g+=`\n            vec4 wTexelR${t}C${n} = getW(${t}, ${n}, d1, q);\n            wR${t}C${n} = vec4(wTexelR${t}C${n}.xz, wTexelR${t}C${n}.xz);\n          `,n+1<f&&(g+=`\n              vec4 wTexelR${t}C${n+1} = getW(${t}, ${n+1}, d1, q);\n              wR${t}C${n+1} =\n                vec4(wTexelR${t}C${n+1}.xz, wTexelR${t}C${n+1}.xz);`))}for(let t=0;t<h;t++)for(let e=0;e<f;e++)g+=`dotProd += xR${t}C${e} * wR${t}C${e};`;let y="",x="";n&&(y=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,x="result = activation(result);");const v=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${y}\n\n      const ivec2 strides = ivec2(${c}, ${l});\n      const ivec2 pads = ivec2(${i}, ${u});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${g}\n\n        vec4 result = dotProd;\n        ${v}\n        ${x}\n        setOutput(result);\n      }\n    `}}class fe{constructor(t,e,n,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,a,i,u]=t,[c]=e,[l,p]=n;this.outputShape=[c,l,p,u];const d="bilinear"===r?1:0,[h,f]=[a-1+".0",i-1+".0"],[m,g,y]=l>1?[""+(a-1)/(l-1),"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[x,v,b]=p>1?[""+(i-1)/(p-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${x});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${h} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${b};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}class me{constructor(t,e,n){this.variableNames=["x"],this.outputShape=t;const r=t.length,o=e?"0.0":`getX(${ge(r,"coords")})`,s=t[t.length-1];let a="",i="";e?(a=n?"end != "+(s-1):"end != 0",i=n?"end + 1":"end - 1"):(a=n?`end + pow2 < ${s}`:"end >= pow2",i=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${Xt(r)} coords = getOutputCoords();\n        int end = ${ye(r,"coords")};\n        float val = ${o};\n        int pow2 = int(pow(2.0, index));\n        if (${a}) {\n          int idx = ${i};\n          ${ye(r,"coords")} = idx;\n          val += getX(${ge(r,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.index&&(this.index=e.getUniformLocation(n,"index")),e.gl.uniform1f(this.index,t)}}}function ge(t,e){if(1===t)return`${e}`;if(2===t)return`${e}.x, ${e}.y`;if(3===t)return`${e}.x, ${e}.y, ${e}.z`;if(4===t)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}function ye(t,e){if(1===t)return`${e}`;if(2===t)return`${e}.y`;if(3===t)return`${e}.z`;if(4===t)return`${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}class xe{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=u.DENSE;const e=d(t),n=_t();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${At(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class ve{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=u.DENSE;const e=d(t),n=_t();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${At(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class be{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}class we{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}class $e{constructor(t){this.variableNames=["A"],this.outTexUsage=c.DOWNLOAD;const e=_t();this.outputShape=t,this.userCode=`\n      ${Ot}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class Ce{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=c.DOWNLOAD;const e=_t();this.outputShape=t,this.userCode=`\n      ${Ot}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}class Ne{constructor(t,e,n=!1){this.variableNames=["A"];const r=_t(),[o,s]=e;this.outputShape=t;let a="result";n&&(a="floor(result * 255. + 0.5)"),this.userCode=`\n      ${Dt(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${s};\n        int c = imod(flatIndex, ${s});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${s}.0, ${o}.0);\n        vec4 values = ${r.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${r.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}}class Ie{constructor(t,e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const r=_t(),[o,s]=e;this.outputShape=t;let a="",i="result";n&&(i="floor(result * 255. + 0.5)");for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){const i=2*e+n;a+=`\n          localCoords = coords;\n          if(localCoords[2] + ${n} < ${t[2]}) {\n            localCoords[2] += ${n};\n            if(localCoords[1] + ${e} < ${t[1]}) {\n              localCoords[1] += ${e};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${s};\n              c = imod(flatIndex, ${s});\n              uv = (vec2(c, r) + halfCR) / vec2(${s}.0, ${o}.0);\n              values = ${r.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${i}] = values[0];\n              } else if(offset == 1) {\n                result[${i}] = values[1];\n              } else if(offset == 2) {\n                result[${i}] = values[2];\n              } else {\n                result[${i}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${Dt(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${a}\n\n        ${r.output} = ${i};\n      }\n    `}}class Ee{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(t){return(e,n)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(this.valueLoc,t)}}}class Te{constructor(t,e,n){this.variableNames=["A","indices"];const r=t.slice();r[n]=e,this.outputShape=r,this.rank=r.length;const o=Xt(this.rank),s=function(t,e){const n=t.length;if(n>4)throw Error(`Gather for rank ${n} is not yet supported`);if(1===n)return"int(getIndices(resRC))";const r=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[];for(let n=0;n<t.length;n++)n===e?o.push(`int(getIndices(${r[n]}))`):o.push(`${r[n]}`);return o.join()}(t,n);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}class ke{constructor(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;const r=Xt(e.length),o=Xt(n.length),s=this.sliceDim>1?"strides[j]":"strides";this.userCode=`\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${s};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}function Se(t,e,n,r,s,a){!function(t,e){const n=(0,o.OBj)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0)throw new Error(`Requested texture size [${t}x${e}] is invalid.`);if(t>n||e>n)throw new Error(`Requested texture size [${t}x${e}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(e,n);const i=function(t){return I(t,(()=>t.createTexture()),"Unable to create WebGLTexture.")}(t),u=t.TEXTURE_2D;return m(t,(()=>t.bindTexture(u,i))),m(t,(()=>t.texParameteri(u,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE))),m(t,(()=>t.texParameteri(u,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE))),m(t,(()=>t.texParameteri(u,t.TEXTURE_MIN_FILTER,t.NEAREST))),m(t,(()=>t.texParameteri(u,t.TEXTURE_MAG_FILTER,t.NEAREST))),m(t,(()=>t.texImage2D(u,0,r,e,n,0,s,a,null))),m(t,(()=>t.bindTexture(t.TEXTURE_2D,null))),i}function Re(t){return t.internalFormatFloat}function _e(t){return t.internalFormatHalfFloat}function Ae(t){return t.downloadTextureFormat}function De(t){return t.internalFormatPackedFloat}function Oe(t){return t.internalFormatPackedHalfFloat}class Fe{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const e=(0,o.OBj)().getNumber("WEBGL_VERSION");null!=t?(this.gl=t,function(t,e){s[t]=e}(e,t)):this.gl=i(e);let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(1===(0,o.OBj)().getNumber("WEBGL_VERSION")){const t="OES_texture_float",e="OES_texture_half_float";if(this.textureFloatExtension=y(this.gl,t),D(this.gl,e))this.textureHalfFloatExtension=y(this.gl,e);else if((0,o.OBj)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),D(this.gl,r))this.colorBufferHalfFloatExtension=y(this.gl,r);else if((0,o.OBj)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",D(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!D(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=function(t){return function(t,e){const n=I(t,(()=>t.createBuffer()),"Unable to create WebGLBuffer");return m(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,n))),m(t,(()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW))),n}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(t){return function(t,e){const n=I(t,(()=>t.createBuffer()),"Unable to create WebGLBuffer");return m(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n))),m(t,(()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW))),n}(t,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(t){return I(t,(()=>t.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=f(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,o.OBj)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;m(t,(()=>t.finish())),m(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,null))),m(t,(()=>t.deleteFramebuffer(this.framebuffer))),m(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,null))),m(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null))),m(t,(()=>t.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[o,s]=p(e,n);return Se(t,o,s,Re(r),r.textureFormatFloat,t.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[o,s]=p(e,n);return Se(t,o,s,_e(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[o,s]=p(e,n);return Se(t,o,s,Ae(r),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function(t,e,n){m(t,(()=>t.bindTexture(t.TEXTURE_2D,e))),n.data instanceof Uint8Array?m(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data))):m(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n))),m(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,r){this.throwIfDisposed(),function(t,e,n,r,o,s){let a,i,u;m(t,(()=>t.bindTexture(t.TEXTURE_2D,e))),o instanceof Uint8Array?(a=new Uint8Array(n*r*4),i=t.UNSIGNED_BYTE,u=t.RGBA):(a=new Float32Array(n*r*4),i=t.FLOAT,u=s.internalFormatPackedFloat),a.set(o),m(t,(()=>t.texImage2D(t.TEXTURE_2D,0,u,n,r,0,t.RGBA,i,a))),m(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}(this.gl,t,e,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[o,s]=h(e,n);return Se(t,o,s,Oe(r),t.RGBA,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[o,s]=h(e,n);return Se(t,o,s,De(r),t.RGBA,t.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(C(this.gl,this.framebuffer),this.outputTexture=null),m(this.gl,(()=>this.gl.deleteTexture(t)))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,(()=>function(t,e,n,r){const[o,s]=p(e,n),a=new Uint8Array(e*n*4);return m(t,(()=>t.readPixels(0,0,o,s,r.downloadTextureFormat,t.UNSIGNED_BYTE,a))),new Float32Array(a.buffer)}(this.gl,e,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(t,e,n,r,o,s){return function(t,e,n,r,o,s,a,i){const u=t,c=new Float32Array(function(t,e){const[n,r]=h(t,e);return n*r*4}(s,a));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,c),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),c}(this.gl,t,0,0,0,o,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return function(t,e,n){const r=t,o=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,o),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),o}(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);const r=function(t,e,n,r){const o=t.createBuffer();m(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,o)));const s=16*e*n;return m(t,(()=>t.bufferData(t.PIXEL_PACK_BUFFER,s,t.STREAM_READ))),m(t,(()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0))),m(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null))),o}(this.gl,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if((0,o.OBj)().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,o=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{const t=r.clientWaitSync(o,0,0);return t===r.ALREADY_SIGNALED||t===r.CONDITION_SATISFIED},e=o}else(0,o.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,(0,o.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,(()=>function(t,e,n){const r=new Float32Array(e*n*4);return m(t,(()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,r))),r}(this.gl,e,n)))}createProgram(t){this.throwIfDisposed();const e=this.gl,n=function(t,e){const n=I(t,(()=>t.createShader(t.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(m(t,(()=>t.shaderSource(n,e))),m(t,(()=>t.compileShader(n))),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw function(t,e){const n=x.exec(e);if(null==n)return console.log(`Couldn't parse line number in error: ${e}`),void console.log(t);const r=+n[1],s=t.split("\n"),a=s.length.toString().length+2,i=s.map(((t,e)=>o.D5U.oj((e+1).toString(),a)+t));let u=0;for(let t=0;t<i.length;t++)u=Math.max(i[t].length,u);const c=i.slice(0,r-1),l=i.slice(r-1,r),p=i.slice(r);console.log(c.join("\n")),console.log(e.split("\n")[0]),console.log(`%c ${o.D5U.oj(l[0],u)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(p.join("\n"))}(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e,t),r=function(t){const e=_t();return function(t,e){const n=I(t,(()=>t.createShader(t.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(m(t,(()=>t.shaderSource(n,e))),m(t,(()=>t.compileShader(n))),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(t,`${e.version}\n    precision highp float;\n    ${e.attribute} vec3 clipSpacePos;\n    ${e.attribute} vec2 uv;\n    ${e.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e),s=function(t){return I(t,(()=>t.createProgram()),"Unable to create WebGLProgram.")}(e);return m(e,(()=>e.attachShader(s,r))),m(e,(()=>e.attachShader(s,n))),function(t,e){if(m(t,(()=>t.linkProgram(e))),!1===t.getProgramParameter(e,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}(e,s),this.debug&&v(e,s),this.vertexAttrsAreBound||(this.setProgram(s),this.vertexAttrsAreBound=function(t,e,n){return m(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,n))),b(t,e,"clipSpacePos",n,3,20,0)&&b(t,e,"uv",n,2,20,12)}(e,this.program,this.vertexBuffer)),s}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&m(this.gl,(()=>this.gl.deleteProgram(t)))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&v(this.gl,this.program),m(this.gl,(()=>this.gl.useProgram(t)))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?function(t,e,n){return I(t,(()=>t.getUniformLocation(e,n)),'uniform "'+n+'" not present in program.')}(this.gl,t,e):function(t,e,n){return t.getUniformLocation(e,n)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),m(this.gl,(()=>this.gl.getAttribLocation(t,e)))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),w(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();const[r,o]=h(e,n);this.setOutputMatrixTextureDriver(t,r,o)}setOutputMatrixWriteRegion(t,e,n,r){this.setOutputMatrixWriteRegionDriver(n,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&v(this.gl,this.program),N(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;this.debug&&this.debugValidate(),m(t,(()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),m(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=y(this.gl,2===(0,o.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,o.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===(0,o.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2();return void t.endQuery(e.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await o.D5U.WD((()=>this.disposed||this.isQueryAvailable(t,(0,o.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(t,(0,o.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(0===e)return null;if(2===e){const e=this.gl;return e.getQueryParameter(t,e.QUERY_RESULT)/1e6}{const e=this.getQueryTimerExtensionWebGL1();return e.getQueryObjectEXT(t,e.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const e=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=e.getQueryParameter(t,e.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const e=this.getQueryTimerExtensionWebGL1(),n=e.getQueryObjectEXT(t,e.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(e.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(t){return new Promise((e=>{this.addItemToPoll((()=>t.isFencePassed()),(()=>e()))}))}pollItems(){const t=function(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}(this.itemsToPoll.map((t=>t.isDoneFn)));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||o.D5U.WD((()=>(this.pollItems(),0===this.itemsToPoll.length)))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),$(this.gl,t,this.framebuffer),this.debug&&N(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?($(this.gl,this.outputTexture,this.framebuffer),this.debug&&N(this.gl)):C(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();const r=this.gl;$(r,t,this.framebuffer),this.debug&&N(r),this.outputTexture=t,m(r,(()=>r.viewport(0,0,e,n))),m(r,(()=>r.scissor(0,0,e,n)))}setOutputMatrixWriteRegionDriver(t,e,n,r){this.throwIfDisposed(),m(this.gl,(()=>this.gl.scissor(t,e,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}function Be(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach(((t,n)=>{const r=t.logicalShape,s=e[n],a=s.shape;if(!o.D5U.cO(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(t.isUniform&&s.isUniform)return;const i=t.texShape,u=s.isUniform?null:s.texData.texShape;if(!o.D5U.cO(i,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${u} must match`)}))}class Pe{constructor(t,e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;const{filterWidth:r,inChannels:o,strideWidth:s,strideHeight:a,padInfo:i,outWidth:u,dilationWidth:c,dilationHeight:l,dataFormat:p}=n,{left:d,top:h}=i,f=o*r,m=_t(),g="channelsLast"===p,y=g?0:1,x=g?1:2;let v="";for(let n=0;n<=1;n++)for(let r=0;r<=1;r++)v+=`\n          blockIndex = rc.y + ${r};\n          pos = rc.x + ${n};\n\n          if(blockIndex < ${t[1]} && pos < ${t[0]}) {\n            offsetY = int(blockIndex / (${u})) * ${a} - ${h};\n            d0 = offsetY + ${l} * (pos / ${f});\n\n            if(d0 < ${e[y]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${u}.) * ${s}. - ${d}.);\n              d1 = offsetX + ${c} * (int(mod(float(pos), ${f}.) / ${o}.));\n\n              if(d1 < ${e[x]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${o}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*n+r}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*n+r}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${v}\n\n        ${m.output} = result;\n      }\n    `}}class Me{constructor(t,e,n,r,o){this.variableNames=["x"],this.outputShape=[];const s=e,a=t[3]-1;let i;this.outputShape=t;const u=`float(${n}) + float(${r}) * sum`;i=.5===o?`inversesqrt(${u})`:1===o?`1.0/(${u})`:`exp(log(${u}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${i};\n        setOutput(val);\n      }\n    `}}class Le{constructor(t,e,n,r,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=r,this.beta=o,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${o})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}class Ve{constructor(t,e,n,r,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=e,a=t[3]-1;let i;this.outputShape=t;const u=`float(${n}) + float(${r}) * sum`;i=.5===o?`inversesqrt(${u})`:1===o?`1.0/(${u})`:`exp(log(${u}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${i};\n        setOutput(result);\n      }\n    `}}class We{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideHeight,n=t.strideWidth,r=t.dilationHeight,o=t.effectiveFilterHeight,s=t.effectiveFilterWidth,a=o-1-t.padInfo.top,i=s-1-t.padInfo.left,u=o*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${e}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ue{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,o=t.dilationDepth,s=t.dilationHeight,a=t.dilationWidth,i=t.effectiveFilterDepth,u=t.effectiveFilterHeight,c=t.effectiveFilterWidth,l=i-1-t.padInfo.front,p=u-1-t.padInfo.top,d=c-1-t.padInfo.left,h=i*u*c-1;this.userCode=`\n      const ivec3 pads = ivec3(${l}, ${p}, ${d});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${i};\n           wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${e}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${c};\n                wC += ${a}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${h} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${c} +\n                  wR * ${c} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ze{constructor(t,e,n,r=!1,o=!1,s=!1,a=null,i=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;const u=r?t[1]:t[2],c=Math.ceil(u/2),l=r?"i * 2, rc.y":"rc.y, i * 2",p=o?"rc.z, i * 2":"i * 2, rc.z",d=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let f="",m="";a&&(f=i?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,m="result = activation(result);");const g=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights");let y="rc.x",x="rc.x";t[0]<e[0]?y=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&(x=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`\n      ${f}\n\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${c}; i++) {\n          int batchA = ${y};\n          int batchB = ${x};\n          vec4 a = getMatrixA(batchA, ${l});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${h[0]});\n          result += (${d[1]} * ${h[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${g}\n\n        ${m}\n\n        setOutput(result);\n      }\n    `}}class Ge{constructor(t,e,n){this.variableNames=["probs"],this.outputShape=[t,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.seedLoc&&(this.seedLoc=e.getUniformLocation(n,"seed")),e.gl.uniform1f(this.seedLoc,t)}}}class Xe{constructor(t,e,n,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}class He{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t;const e=t.length;if(0===e)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=Rt("rc",e),r=Xt(e),o=function(t,e,n){if(1===t)return`rc > ${e[0]}`;let r="";for(let o=t-2;o<t;o++)r+=`${n[o]} >= ${e[o]}`,o<t-1&&(r+="||");return r}(e,t,n),s=function(t,e,n,r){if(1===t)return"";const o=r.slice(-2);return`\n    int r = ${o[0]};\n    int c = ${o[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${e};\n    bool rEdge = rp1 >= ${n};\n  `}(e,t[t.length-1],t[t.length-2],n),a=function(t,e){const n=t.length,r=function(t,e){const n=[];for(let r=0;r<=1;r++)for(let o=0;o<=1;o++){let s=`${0===r?"r":"rp1"}, ${0===o?"c":"cp1"}`;for(let n=2;n<t;n++)s=`${e[e.length-1-n]},`+s;n.push(s)}return n}(n,e);return 1===n?`getA(rc),\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${r[0]}),\n          cEdge ? 0. : getA(${r[1]}),\n          rEdge ? 0. : getA(${r[2]}),\n          rEdge || cEdge ? 0. : getA(${r[3]})`}(t,n);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${o}) {\n            setOutput(vec4(0));\n          } else {\n            ${s}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}}class je{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,o=Xt(r),s=e.map((t=>t[0])).join(","),a=e.map(((e,n)=>e[0]+t[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${o} start = ${o}(${s});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(${n}));\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${i}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(${n}));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class Ke{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,o=Xt(r),s=e.map((t=>t[0])).join(","),a=e.map(((e,n)=>e[0]+t[n])).join(","),i=Rt("rc",r),u=Rt("source",r),c=`${i[r-1]} < ${this.outputShape[r-1]}`,l=1===r?"source":`vec2(${u.slice(-2).join()})`,p=[`${o} rc = outputLoc;`,`${i[r-1]} += 1;\n       if(${c}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${i[r-2]} += 1;\n       if(${i[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${i[r-1]} += 1;\n         if(${c}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let h="";for(let t=0,e=1===r?2:4;t<e;t++)h+=`\n        ${p[t]}\n        if (${d}) {\n          result[${t}] = float(${n});\n        } else {\n          ${o} source = rc - start;\n          result[${t}] = getChannel(getX(${u.join()}), ${l});\n        }\n      `;h+=1===r?"} ":"}}",this.userCode=`\n      const ${o} start = ${o}(${s});\n      const ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}class qe{constructor(t,e,n,r=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const s=t.filterWidth,a=t.strideHeight,i=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,l=t.effectiveFilterHeight,p=t.effectiveFilterWidth,d=t.padInfo.top,h=t.padInfo.left;this.outputShape=t.outShape;const f="avg"===e,m=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,g=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let y="0.0";if(f||(y="-1.0 / 1e-20"),n){const e=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${i});\n        const ivec2 pads = ivec2(${d}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${l};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p};\n                wC += ${c}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${e} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?o?m:g:`wR * ${p} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let x=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(x="avgValue / count");const v=4*Math.floor(s/4),b=s%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${i});\n      const ivec2 pads = ivec2(${d}, ${h});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${l};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${c};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              getValue(batch, xR, xC + 3 * ${c}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${x});\n      }\n    `}}class Ye{constructor(t,e,n,r=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const s=t.filterWidth,a=t.strideDepth,i=t.strideHeight,u=t.strideWidth,c=t.dilationDepth,l=t.dilationHeight,p=t.dilationWidth,d=t.effectiveFilterDepth,h=t.effectiveFilterHeight,f=t.effectiveFilterWidth,m=t.padInfo.front,g=t.padInfo.top,y=t.padInfo.left;this.outputShape=t.outShape;const x="avg"===e;let v="0.0";if(x||(v="-1.0 / 1e-20"),n){const e=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${i}, ${u});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${c}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${h};\n                wR += ${l}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${p}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${e} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?o?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${h} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(b="avgValue / count");const w=4*Math.floor(s/4),$=s%4,C=`\n      if (${x}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${i}, ${u});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${c}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h};\n            wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${p};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${p}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${p}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${p}, ch)\n              );\n\n              ${C}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===$}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${C}\n            } else if (${2===$}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${p}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${C}\n            } else if (${3===$}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${p}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${p}, ch),\n                initializationValue\n              );\n\n              ${C}\n            }\n          }\n          setOutput(${b});\n        }\n      }\n    `}}class Qe{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:o,outSize:s}=t;this.outputShape=[r,s];let a="0.0",i="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",i="min"):"max"===e&&(a="-1.0 / 1e-20",i="max");let u=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?u="sumValue":"prod"===e?u="prodValue":"all"===e?u="allValue":"any"===e&&(u="anyValue");const c=4*Math.floor(n/4),l=n%4;let p=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${i}(values, minMaxValue);\n      }\n    `,d="vec4";"all"===e?(a="1.0",p="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===e&&(a="0.0",p="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let h="";o%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${p}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===l}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${p}\n        } else if (${2===l}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${p}\n        } else if (${3===l}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${p}\n        }\n        setOutput(${u});\n      }\n    `}}class Ze{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;let n="";for(let t=0;t<4;t++){let e="thisRC = rc;";t%2==1&&(e+="thisRC.z += 1;"),t>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${t>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${t}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${t>0?"}":""}\n      `}var r;this.userCode=`\n      ${r=e,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${At(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${Dt(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${t[1]};\n        int cols = ${t[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class Je{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;const[,r,o]=e.shape,[,s,a]=t.shape,i=[n&&s>1?r-1:r,n&&a>1?o-1:o],u=[n&&s>1?s-1:s,n&&a>1?a-1:a],c=i[0]/u[0],l=i[1]/u[1],p=1/c,d=1/l,h=2*Math.ceil(p)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${l});\n\n        const float invHeightScale = float(${p});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}class tn{constructor(t,e,n,r){this.variableNames=["A"],this.outputShape=[];const[o,s,a,i]=t;this.outputShape=[o,e,n,i];const u=[r&&e>1?s-1:s,r&&n>1?a-1:a],c=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${s}.0, ${a}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class en{constructor(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,s,a,i]=t;this.outputShape=[o,e,n,i];const u=[r&&e>1?s-1:s,r&&n>1?a-1:a],c=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${s}.0, ${a}.0,\n                                     ${a}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${i-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}class nn{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;const[,r,o]=e.shape,[,s,a]=t.shape,i=[n&&s>1?r-1:r,n&&a>1?o-1:o],u=[n&&s>1?s-1:s,n&&a>1?a-1:a],c=i[0]/u[0],l=i[1]/u[1],p=1/c,d=1/l,h=2*Math.ceil(p)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${l});\n\n        const float invHeightScale = float(${p});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${i[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${i[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${o}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}class rn{constructor(t,e,n,r){this.variableNames=["A"],this.outputShape=[];const[o,s,a,i]=t;this.outputShape=[o,e,n,i];const u=[r&&e>1?s-1:s,r&&n>1?a-1:a],c=[r&&e>1?e-1:e,r&&n>1?n-1:n],l=r?"0.5":"0.0";this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${s}.0, ${a}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${l})));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class on{constructor(t,e){this.variableNames=["x"];const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const r=t.map(((n,r)=>(n=>-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),o=Xt(n);this.userCode=`\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class sn{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;const r=Rt("rc",n),o=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,a=Xt(n);function i(n){const r=t.map(((r,o)=>function(n,r){return-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - ${r[n]} - 1`:`${r[n]}`}(o,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${o}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(t){return i(t)}(r.slice())};\n          if(${o}){\n            result.g = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",i(t)}(r.slice())};\n          }\n          if(${s}) {\n            result.b = ${function(t){return t[n-2]="("+t[n-2]+" + 1)",i(t)}(r.slice())};\n            if(${o}) {\n              result.a = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",i(t)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}class an{constructor(t,e,n,r,o,s,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const i=Xt(o.length),u=Xt(s.length);let c="";1===n?c="i":2===n&&(c="i, j");const l=`getIndices(${c})`;let p="";1===r?p="i":2===r&&(p="i, coords[1]");const d=`getUpdates(${p})`,h=e>1?"strides[j]":"strides";this.userCode=`\n        ${i} strides = ${i}(${o});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(${l});\n              flattenedIndex += index * ${h};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${d};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}class un{constructor(t,e){this.variableNames=["x","segmentIds"];const n=t.windowSize,r=t.batchSize,o=t.inSize,s=t.numSegments,a=s*Math.ceil(o/n);this.outputShape=[r,a];const i=4*Math.floor(n/4),u=n%4,c="\n        sumValue += dot(values, segFilter);\n    ";let l="";o%n>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `);let p="";o%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${p}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${c}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${c}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}class cn{constructor(t,e,n){let r,o;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)o="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],a=[];for(let r=0;r<e.length;r++)a.push(`${n[r]}`),r<t&&s.push(`${n[r]}`);r=s.join(),o=a.join()}const s=Xt(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}class ln{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=Xt(this.rank),n=`uniform int start[${this.rank}];`,r=function(t){if(1===t)return"sourceLoc";if(t<=6)return pn.slice(0,t).map((t=>"sourceLoc."+t)).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let o;o=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map(((t,e)=>`sourceLoc.${pn[e]} = start[${e}] + coords.${pn[e]};`)).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${o}\n        setOutput(getSource(${r}));\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,t)}}}const pn=["x","y","z","w","u","v"];class dn{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length;const e=Xt(this.rank),n=Rt("coords",this.rank),r=Rt("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${o})`,a=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${s};\n        --${r[this.rank-1]};\n      }\n    `,i=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map(((t,e)=>`start[${e}]`)).join()});`:t.map(((t,e)=>`${r[e]} = ${n[e]} + start[${e}];`)).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${a}\n        ${i}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,t)}}}class hn{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,o=Xt(n.length),s=Xt(n.length);let a="";if(1===r)a="coords * strides + begin";else{let t=0;a=n.map(((e,r)=>(t++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${t-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${o} begin = ${o}(${t});\n      ${o} strides = ${o}(${e});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}class fn{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,n){const r=gn(e,n),o=yn(t,r,n);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const s=mn(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const t=this.freeTextures[o].shift();return this.usedTextures[o].push(t),t}let a;return r===l.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===l.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===l.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===l.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===l.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),a}releaseTexture(t,e,n,r){if(null==this.freeTextures)return;const s=gn(n,r),a=yn(e,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);const i=mn(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),u=(0,o.OBj)().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==u&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(t),this._numBytesAllocated-=i):(this.freeTextures[a].push(t),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const c=this.usedTextures[a],l=c.indexOf(t);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c.splice(l,1),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach((t=>{this.gpgpu.deleteMatrixTexture(t)}));for(const t in this.usedTextures)this.usedTextures[t].forEach((t=>{this.gpgpu.deleteMatrixTexture(t)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function mn(t,e,n,r,o){const s=function(t,e){switch(t){case l.PACKED_2X2_FLOAT32:return De(e);case l.PACKED_2X2_FLOAT16:return Oe(e);case l.UNPACKED_FLOAT32:return Re(e);case l.UNPACKED_FLOAT16:return _e(e);case l.PACKED_4X1_UNSIGNED_BYTE:return Ae(e);default:throw new Error(`Unknown physical texture type ${t}`)}}(e,r);let a;if(o){const[e,n]=h(t[0],t[1]);a=e*n}else{const[e,n]=p(t[0],t[1]);a=e*n}return a*function(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;throw new Error(`Unknown internal format ${e}`)}(n,s)}function gn(t,e){if(t===c.UPLOAD)return l.PACKED_2X2_FLOAT32;if(t===c.RENDER||null==t)return function(t){return(0,o.OBj)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?l.PACKED_2X2_FLOAT32:l.UNPACKED_FLOAT32:t?l.PACKED_2X2_FLOAT16:l.UNPACKED_FLOAT16}(e);if(t===c.DOWNLOAD||t===c.PIXELS)return l.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function yn(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}class xn{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let r=0;r<n.length;r++)n[r]=t[r]*e[r];this.outputShape=n,this.rank=n.length;const r=Xt(this.rank),o=function(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let e=0;e<t.length;e++)r.push(`imod(${n[e]}, ${t[e]})`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}class vn{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const bn="return abs(x);",wn="if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",$n="if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",Cn="return (x >= 0.0) ? x : (exp(x) - 1.0);",Nn=`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${o.Wap.SELU_SCALEALPHA};\n  float scale = ${o.Wap.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`,In="return -x;",En="return ceil(x);",Tn="return floor(x);",kn="return exp(x);",Sn="return exp(x) - 1.0;",Rn=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${o.Wap.ERF_P};\n  float a1 = ${o.Wap.ERF_A1};\n  float a2 = ${o.Wap.ERF_A2};\n  float a3 = ${o.Wap.ERF_A3};\n  float a4 = ${o.Wap.ERF_A4};\n  float a5 = ${o.Wap.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`,_n="return x;",An="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Dn="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",On="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n";class Fn{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class Bn{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t;const e=t.length,n=Rt("rc",e),r=Xt(e),o=function(t,e){if(1===t)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}(e,n),s=n.slice(-2),a=e<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${o});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const{segment_util:Pn}=o.Wap,Mn=o.GDt.Vl,Ln=o.GDt.Gg,Vn=o.GDt.vN,Wn=o.GDt.ZA,Un={};function zn(t,e=!1){if("linear"===t)return"return x;";if("relu"===t)return e?An:wn;if("elu"===t)return e?On:Cn;if("relu6"===t)return e?Dn:$n;if("prelu"===t)return e?Jt:Qt;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class Gn extends o.Zuw{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.warnedAboutMemory=!1,this.warnedAboutCPUBackend=!1,this.pendingDeletes=0,this.disposed=!1,!(0,o.OBj)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==t){const t=i((0,o.OBj)().getNumber("WEBGL_VERSION"));this.binaryCache=((e=(0,o.OBj)().getNumber("WEBGL_VERSION"))in Un||(Un[e]={}),Un[e]),this.gpgpu=new Fe(t),this.canvas=t.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=t,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=t.gl.canvas;var e;this.textureManager=new fn(this.gpgpu),this.numMBBeforeWarning=null==(0,o.OBj)().global.screen?1024:(0,o.OBj)().global.screen.height*(0,o.OBj)().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new o.JLz(this,(0,o.SRH)())}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(t,e,n){if(((0,o.OBj)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,o.OBj)().getBool("DEBUG"))&&this.checkNumericalProblems(t),"complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={};return this.texData.set(r,{shape:e,dtype:n,values:t,usage:c.UPLOAD,refCount:1,complexParentRefCount:0}),r}incRef(t){this.texData.get(t).refCount++}decRef(t){this.texData.has(t)&&this.texData.get(t).refCount--}move(t,e,n,r){if((0,o.OBj)().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:r,values:e,usage:c.UPLOAD,refCount:1,complexParentRefCount:0})}disposeIntermediateTensorInfo(t){const e=t.dataId;if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--,t.refCount<1&&this.disposeData(e)}}readSync(t){const e=this.texData.get(t),{values:n,dtype:r,complexTensorInfos:s,slice:a,shape:i,isPacked:u}=e;if(null!=a){let e;e=u?new Fn(i,_n):new vn(i,_n);const n=this.runWebGLProgram(e,[{dataId:t,shape:i,dtype:r}],r),o=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),o}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===r)return n;const c=null!=this.activeTimers;let l,p;if(c&&(l=o.D5U.zO()),"complex64"===r){const t=this.readSync(s.real.dataId),e=this.readSync(s.imag.dataId);p=o.Wap.mergeRealAndImagArrays(t,e)}else p=this.getValuesFromTexture(t);return c&&(this.downloadWaitMs+=o.D5U.zO()-l),this.convertAndCacheOnCPU(t,p)}async read(t){if(this.pendingRead.has(t)){const e=this.pendingRead.get(t);return new Promise((t=>e.push(t)))}const e=this.texData.get(t),{values:n,shape:r,slice:s,dtype:a,complexTensorInfos:i,isPacked:u}=e;if(null!=s){let e;e=u?new Fn(r,_n):new vn(r,_n);const n=this.runWebGLProgram(e,[{dataId:t,shape:r,dtype:a}],a),o=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),o}if(null!=n)return this.convertAndCacheOnCPU(t);if(!(0,o.OBj)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===(0,o.OBj)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c,l,p=null;if("complex64"!==a&&(0,o.OBj)().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(t);const e=this.texData.get(c.dataId);p=this.gpgpu.createBufferFromTexture(e.texture,...d(r))}if(this.pendingRead.set(t,[]),"complex64"!==a&&await this.gpgpu.createAndWaitForFence(),"complex64"===a){const t=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),e=t[0],n=t[1];l=o.Wap.mergeRealAndImagArrays(e,n)}else if(null==p)l=this.getValuesFromTexture(t);else{const t=o.D5U.NA(r);l=this.gpgpu.downloadFloat32MatrixFromBuffer(p,t)}null!=c&&this.disposeIntermediateTensorInfo(c);const h=this.convertAndCacheOnCPU(t,l),f=this.pendingRead.get(t);return this.pendingRead.delete(t),f.forEach((t=>t(h))),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t),this.pendingDeletes--),h}checkNumericalProblems(t){if(null!=t)for(let e=0;e<t.length;e++){const n=t[e];if(!g(n)){if((0,o.OBj)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(t){const{shape:e,dtype:n,isPacked:r}=this.texData.get(t),s=o.D5U.NA(e);if((0,o.OBj)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(t),r=this.texData.get(n.dataId),o=this.gpgpu.downloadMatrixFromPackedTexture(r.texture,...d(e)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),o}const a=(0,o.OBj)().getBool("WEBGL_PACK")&&!0===r,i=a?k(e):e,u=a?new Ce(i):new $e(i),c=this.runWebGLProgram(u,[{shape:i,dtype:n,dataId:t}],"float32"),l=this.texData.get(c.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture,l.texShape[0],l.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(c),p}async time(t){const e=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,t();const s=o.D5U.xH(this.activeTimers.map((t=>t.query))).filter((t=>null!=t)),a=o.D5U.xH(this.activeTimers.map((t=>t.name))).filter((t=>null!=t));this.activeTimers=e,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if((0,o.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=await Promise.all(s);i.kernelMs=o.D5U.Sm(t),i.getExtraProfileInfo=()=>t.map(((t,e)=>({name:a[e],ms:t}))).map((t=>`${t.name}: ${t.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,o.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:o.D5U.zO(),endMs:null}}endTimer(t){return(0,o.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=o.D5U.zO(),t)}async getQueryTime(t){if((0,o.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const e=t;return e.endMs-e.startMs}disposeData(t){if(this.pendingDisposal.has(t))return;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),void this.pendingDeletes++;if(!this.texData.has(t))return;if(this.texData.get(t).complexParentRefCount>0)return void this.texData.get(t).refCount--;this.releaseGPUData(t);const{complexTensorInfos:e}=this.texData.get(t);null!=e&&(this.texData.get(e.real.dataId).complexParentRefCount--,this.disposeIntermediateTensorInfo(e.real),this.texData.get(e.imag.dataId).complexParentRefCount--,this.disposeIntermediateTensorInfo(e.imag)),this.texData.delete(t)}releaseGPUData(t){const{texture:e,dtype:n,texShape:r,usage:o,isPacked:s,slice:a}=this.texData.get(t),i=a&&a.origDataId||t,u=this.dataRefCount.get(i);u>1?this.dataRefCount.set(i,u-1):(this.dataRefCount.delete(i),null!=e&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(e,r,o,s)));const c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture}getDataInfo(t){return this.texData.get(t)}getCPUBackend(){return(0,o.OBj)().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=(0,o.SRH)().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(t,e=128){const n=this.getCPUBackend();return this.warnedAboutCPUBackend||null!=n||(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),null!=n&&t.every((t=>null==this.texData.get(t.dataId).texture&&o.D5U.NA(t.shape)<e))}getGPGPUContext(){return this.gpgpu}slice(t,e,n){if(this.shouldExecuteOnCPU([t])){const r=$t(this.texData.get(t.dataId).values,e,n,t.shape,t.dtype);return this.makeOutput(n,t.dtype,r)}if(0===o.D5U.NA(n))return(0,o.XeE)([],n,t.dtype);const{isPacked:r}=this.texData.get(t.dataId),s=o.kuN.isSliceContinous(t.shape,e,n);if(r||!s){const r=(0,o.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dn(n):new ln(n),s=r.getCustomSetupFunc(e);return this.compileAndRun(r,[t],null,s)}return this.uploadToGPU(t.dataId),this.shallowSlice(t,e,n)}shallowSlice(t,e,n){const r=this.texData.get(t.dataId),s=this.makeOutput(n,t.dtype),a=this.texData.get(s.dataId);Object.assign(a,r),a.shape=n,a.dtype=t.dtype;let i=o.kuN.computeFlatOffset(e,t.strides);r.slice&&(i+=r.slice.flatOffset),a.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||t.dataId};const u=this.dataRefCount.get(a.slice.origDataId)||1;return this.dataRefCount.set(a.slice.origDataId,u+1),s}stridedSlice(t,e,n,r){const s=this.tryRunOnCpuOrThrow([t],(()=>this.cpuBackend.stridedSlice(t,e,n,r)));if(s)return s;const a=o.kuN.computeOutShape(e,n,r);if(a.some((t=>0===t)))return(0,o.XeE)([],a);const i=new hn(e,r,a);return this.compileAndRun(i,[t])}reverse(t,e){const n=(0,o.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new sn(t.shape,e):new on(t.shape,e);return this.compileAndRun(n,[t])}neg(t){const e=this.tryRunOnCpuOrThrow([t],(()=>this.cpuBackend.neg(t)));if(e)return e;if((0,o.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,In,t.dtype);const n=new vn(t.shape,In);return this.compileAndRun(n,[t])}batchMatMul(t,e,n,r){const s=n?t.shape[2]:t.shape[1],a=r?e.shape[1]:e.shape[2],i=n?t.shape[1]:t.shape[2],u=Math.max(t.shape[0],e.shape[0]);if((1===s||1===a)&&i>1e3){n&&(t=(0,o.p4s)(t,[0,2,1])),r&&(e=(0,o.p4s)(e,[0,2,1]));const s=1===a?t:t.as3D(u,i,1),c=1===a?2:1,l=1===a?e.as3D(u,1,i):e;return o.dC7(s,l).sum(c,!0)}const c=(0,o.x8V)(t.dtype,e.dtype),l=new ze(t.shape,e.shape,[u,s,a],n,r);return this.compileAndRun(l,[t,e],c)}fusedBatchMatMul({a:t,b:e,transposeA:n,transposeB:r,bias:s,activation:a,preluActivationWeights:i}){const u=n?t.shape[2]:t.shape[1],c=r?e.shape[1]:e.shape[2],l=Math.max(t.shape[0],e.shape[0]),p=(0,o.x8V)(t.dtype,e.dtype),d=null!=s,h=null!=i,f=a?zn(a,!0):null,m=new ze(t.shape,e.shape,[l,u,c],n,r,d,f,h),g=[t,e];return s&&g.push(s),i&&g.push(i),this.compileAndRun(m,g,p)}localResponseNormalization4D(t,e,n,r,s){const a=(0,o.OBj)().getBool("WEBGL_PACK_NORMALIZATION")?new Ve(t.shape,e,n,r,s):new Me(t.shape,e,n,r,s);return this.compileAndRun(a,[t])}LRNGrad(t,e,n,r,o,s,a){const i=new Le(e.shape,r,o,s,a);return this.compileAndRun(i,[e,n,t])}tile(t,e){if("string"===t.dtype){const n=this.readSync(t.dataId).map((t=>o.D5U.v5(t))),r=(0,o.f3b)(t.shape,t.dtype,n);return Ln(r,e)}const n=new xn(t.shape,e);return this.compileAndRun(n,[t])}pad(t,e,n){const r=(0,o.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ke(t.shape,e,n):new je(t.shape,e,n);return this.compileAndRun(r,[t])}gather(t,e,n){const r=this.tryRunOnCpuOrThrow([t,e],(()=>this.cpuBackend.gather(t,e,n)));if(r)return r;const o=new Te(t.shape,e.size,n);return this.compileAndRun(o,[t,e])}batchToSpaceND(t,e,n){o.D5U.hu(t.rank<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const r=e.reduce(((t,e)=>t*e)),s=o.Wap.getReshaped(t.shape,e,r),a=o.Wap.getPermuted(s.length,e.length),i=o.Wap.getReshapedPermuted(t.shape,e,r),u=o.Wap.getSliceBeginCoords(n,e.length),c=o.Wap.getSliceSize(i,n,e.length);return(0,o.p4s)(t.reshape(s),a).reshape(i).slice(u,c)}spaceToBatchND(t,e,n){o.D5U.hu(t.rank<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const r=e.reduce(((t,e)=>t*e)),s=[[0,0]];s.push(...n);for(let n=1+e.length;n<t.shape.length;++n)s.push([0,0]);const a=t.pad(s),i=o.Wap.getReshaped(a.shape,e,r,!1),u=o.Wap.getPermuted(i.length,e.length,!1),c=o.Wap.getReshapedPermuted(a.shape,e,r,!1),l=(0,o.p4s)(a.reshape(i),u);return(0,o.XLQ)(l,c)}reduce(t,e,n){const r=t.shape[0],s=t.shape[1],a=o.Wap.computeOptimalWindowSize(s),i=Math.ceil(s/a),u=new Qe({windowSize:a,inSize:s,batchSize:r,outSize:i},e),c=this.compileAndRun(u,[t],n);return 1===c.shape[1]?c:this.reduce(c,e,n)}argReduce(t,e,n=null){let r=t.shape[0],s=t.shape[1];null!=n&&(r=n.shape[0],s=n.shape[1]);const a=o.Wap.computeOptimalWindowSize(s),i={windowSize:a,inSize:s,batchSize:r,outSize:Math.ceil(s/a)},u=new kt(i,e,null==n),c=[t];null!=n&&c.push(n);const l=this.compileAndRun(u,c,"int32");return 1===l.shape[1]?l:this.argReduce(t,e,l)}argReducePacked(t,e,n=null){const r=null!=n?n.shape:t.shape,s=r[r.length-1],a=o.Wap.computeOptimalWindowSize(s),i=new Kt(r,a,e,null==n),u=null==n?[t]:[t,n],c=this.compileAndRun(i,u,"int32");return c.rank===t.rank?this.argReducePacked(t,e,c):c}sum(t,e){o.Wap.assertAxesAreInnerMostDims("sum",e,t.rank);const[n,r]=o.Wap.computeOutAndReduceShapes(t.shape,e),s=o.D5U.NA(r),a=t.as2D(-1,s),i=o.z4k(t.dtype);return this.reduce(a,"sum",i).reshape(n)}prod(t,e){const n=this.tryRunOnCpuOrThrow([t],(()=>this.cpuBackend.prod(t,e)));if(n)return n;const[r,s]=o.Wap.computeOutAndReduceShapes(t.shape,e),a=o.D5U.NA(s),i=t.as2D(-1,a),u=o.z4k(t.dtype);return this.reduce(i,"prod",u).reshape(r)}unsortedSegmentSum(t,e,n){let r=0;const s=o.Wap.getAxesPermutation([r],t.rank);let a=t;null!=s&&(a=(0,o.p4s)(t,s),r=o.Wap.getInnerMostAxes(1,t.rank)[0]);const i=Pn.computeOutShape(a.shape,r,n),u=o.D5U.NA([a.shape[r]]),c=a.as2D(-1,u),l=o.z4k(t.dtype);let p=this.segOpCompute(c,"unsortedSegmentSum",e,l,n).reshape(i);return null!=s&&(p=(0,o.p4s)(p,o.Wap.getUndoAxesPermutation(s))),p}segOpCompute(t,e,n,r,s){const a=t.shape[0],i=t.shape[1],u=Pn.segOpComputeOptimalWindowSize(i,s),c=new un({windowSize:u,inSize:i,batchSize:a,numSegments:s},e),l=this.compileAndRun(c,[t,n],r);return l.shape[1]===s?l:(n=(0,o.w6H)(0,s).tile([i/u]),this.segOpCompute(l,e,n,r,s))}argMinMaxReduce(t,e,n){const r=[e];if(o.Wap.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),r,t.rank),!(0,o.OBj)().getBool("WEBGL_PACK_REDUCE")||t.rank<=2){const[e,s]=o.Wap.computeOutAndReduceShapes(t.shape,r),a=o.D5U.NA(s),i=t.as2D(-1,a);return this.argReduce(i,n).reshape(e)}return this.argReducePacked(t,n)}argMin(t,e){return this.argMinMaxReduce(t,e,"min")}argMax(t,e){return this.argMinMaxReduce(t,e,"max")}cumsum(t,e,n,r){if(e!==t.rank-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${t.rank-1} but got axis=${e}`);const o=t.shape[e];let s=t;for(let e=0;e<=Math.ceil(Math.log2(o))-1;e++){const n=new me(t.shape,!1,r),o=n.getCustomSetupFunc(e),a=s;s=this.compileAndRun(n,[s],s.dtype,o),a.dispose()}if(n){const e=new me(t.shape,n,r),o=s;s=this.compileAndRun(e,[s]),o.dispose()}return s}equal(t,e){if((0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(equal(a, b));\n","bool");const n=new Zt("return float(a == b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}less(t,e){const n=this.tryRunOnCpuOrThrow([t,e],(()=>this.cpuBackend.less(t,e)));if(n)return n;if((0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(lessThan(a, b));\n","bool");const r=new Zt("return float(a < b);",t.shape,e.shape);return this.compileAndRun(r,[t,e],"bool")}lessEqual(t,e){if((0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(lessThanEqual(a, b));\n","bool");const n=new Zt("return float(a <= b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}greater(t,e){const n=this.tryRunOnCpuOrThrow([t,e],(()=>this.cpuBackend.greater(t,e)));if(n)return n;if((0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(greaterThan(a, b));\n","bool");const r=new Zt("return float(a > b);",t.shape,e.shape);return this.compileAndRun(r,[t,e],"bool")}greaterEqual(t,e){if((0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(greaterThanEqual(a, b));\n","bool");const n=new Zt("return float(a >= b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}logicalNot(t){const e=new vn(t.shape,"return float(!(x >= 1.0));");return this.compileAndRun(e,[t])}logicalAnd(t,e){if((0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n","bool");const n=new Zt("return float(a >= 1.0 && b >= 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}logicalOr(t,e){if((0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n","bool");const n=new Zt("return float(a >= 1.0 || b >= 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}select(t,e,n){const r=new cn(t.rank,e.shape,e.rank);return this.compileAndRun(r,[t,e,n],(0,o.x8V)(e.dtype,n.dtype))}where(t){o.Wap.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return Wn(t.shape,e)}topk(t,e,n){const r=t.dataSync();return Vn(r,t.shape,t.dtype,e,n)}min(t,e){o.Wap.assertAxesAreInnerMostDims("min",e,t.rank);const[n,r]=o.Wap.computeOutAndReduceShapes(t.shape,e),s=o.D5U.NA(r),a=t.as2D(-1,s);return this.reduce(a,"min",a.dtype).reshape(n)}minimum(t,e){const n=this.tryRunOnCpuOrThrow([t,e],(()=>this.cpuBackend.minimum(t,e)));if(n)return n;const r=(0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new te("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Zt("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",t.shape,e.shape);return this.compileAndRun(r,[t,e])}mod(t,e){const n=(0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new te("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Zt("if (b == 0.0) return NAN;\n  return mod(a, b);",t.shape,e.shape);return this.compileAndRun(n,[t,e])}maximum(t,e){const n=this.tryRunOnCpuOrThrow([t,e],(()=>this.cpuBackend.maximum(t,e)));if(n)return n;const r=(0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new te("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Zt("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",t.shape,e.shape);return this.compileAndRun(r,[t,e])}all(t,e){o.Wap.assertAxesAreInnerMostDims("all",e,t.rank);const[n,r]=o.Wap.computeOutAndReduceShapes(t.shape,e),s=o.D5U.NA(r),a=t.as2D(-1,s);return this.reduce(a,"all",a.dtype).reshape(n)}any(t,e){o.Wap.assertAxesAreInnerMostDims("any",e,t.rank);const[n,r]=o.Wap.computeOutAndReduceShapes(t.shape,e),s=o.D5U.NA(r),a=t.as2D(-1,s);return this.reduce(a,"any",a.dtype).reshape(n)}floorDiv(t,e){const n="int32";if((0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",n);const r=new Zt("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",t.shape,e.shape);return this.compileAndRun(r,[t,e],n)}packedUnaryOp(t,e,n){const r=new Fn(t.shape,e);return this.compileAndRun(r,[t],n)}packedBinaryOp(t,e,n,r,o=!1){const s=new te(n,t.shape,e.shape,o);return this.compileAndRun(s,[t,e],r)}makeComplexComponentTensorInfo(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}addN(t){if(1===t.length)return t[0];if(t.length>(0,o.OBj)().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(t.length/2),n=this.addN(t.slice(0,e)),r=this.addN(t.slice(e));return this.addN([n,r])}const e=t.map((t=>t.dtype)).reduce(((t,e)=>(0,o.x8V)(t,e))),n=t.map((t=>t.shape)),r=(0,o.OBj)().getBool("WEBGL_PACK")?new Tt(t[0].shape,n):new Et(t[0].shape,n);return this.compileAndRun(r,t,e)}pow(t,e){const n=(0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new te("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Zt("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",t.shape,e.shape),r=(0,o.x8V)(t.dtype,e.dtype);return this.compileAndRun(n,[t,e],r)}ceil(t){if(this.shouldExecuteOnCPU([t])){const e=ft(this.texData.get(t.dataId).values,t.dtype);return this.makeOutput(t.shape,t.dtype,e)}if((0,o.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,En,t.dtype);const e=new vn(t.shape,En);return this.compileAndRun(e,[t])}floor(t){if(this.shouldExecuteOnCPU([t])){const e=yt(this.texData.get(t.dataId).values,t.dtype);return this.makeOutput(t.shape,t.dtype,e)}if((0,o.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Tn,t.dtype);const e=new vn(t.shape,Tn);return this.compileAndRun(e,[t])}sign(t){const e=new vn(t.shape,"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");return this.compileAndRun(e,[t])}isNaN(t){const e=new vn(t.shape,"return float(isnan(x));");return this.compileAndRun(e,[t],"bool")}isInf(t){const e=new vn(t.shape,"return float(isinf(x));");return this.compileAndRun(e,[t],"bool")}isFinite(t){const e=new vn(t.shape,"return float(!isnan(x) && !isinf(x));");return this.compileAndRun(e,[t],"bool")}round(t){const e=new vn(t.shape,"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");return this.compileAndRun(e,[t])}exp(t){if(this.shouldExecuteOnCPU([t])){const e=mt(this.texData.get(t.dataId).values,t.dtype);return this.makeOutput(t.shape,t.dtype,e)}if((0,o.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,kn,t.dtype);const e=new vn(t.shape,kn);return this.compileAndRun(e,[t])}expm1(t){if(this.shouldExecuteOnCPU([t])){const e=gt(this.texData.get(t.dataId).values,t.dtype);return this.makeOutput(t.shape,t.dtype,e)}if((0,o.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Sn,t.dtype);const e=new vn(t.shape,Sn);return this.compileAndRun(e,[t])}softmax(t,e){const n=o.D5U.EC([e],t.shape),r=(0,o.Fp7)(t,n),s=o.Wap.expandShapeToKeepDim(r.shape,n),a=o.luU(t,r.reshape(s)),i=this.exp(a),u=this.sum(i,n).reshape(s);return(0,o.hiC)(i,u)}log(t){if(this.shouldExecuteOnCPU([t])){const e=xt(this.texData.get(t.dataId).values,t.dtype);return this.makeOutput(t.shape,t.dtype,e)}if((0,o.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",t.dtype);const e=new vn(t.shape,"if (x < 0.0) return NAN;\n  return log(x);");return this.compileAndRun(e,[t])}log1p(t){const e=new vn(t.shape,"return log(1.0 + x);");return this.compileAndRun(e,[t])}sqrt(t){const e=new vn(t.shape,"return sqrt(x);");return this.compileAndRun(e,[t])}rsqrt(t){if(this.shouldExecuteOnCPU([t])){const e=wt(this.texData.get(t.dataId).values,t.dtype);return this.makeOutput(t.shape,t.dtype,e)}const e=new vn(t.shape,"return inversesqrt(x);");return this.compileAndRun(e,[t])}reciprocal(t){const e=new vn(t.shape,"return 1.0 / x;");return this.compileAndRun(e,[t])}relu(t){let e;return e=(0,o.OBj)().getBool("WEBGL_PACK")?new Fn(t.shape,An):new vn(t.shape,wn),this.compileAndRun(e,[t])}relu6(t){let e;return e=(0,o.OBj)().getBool("WEBGL_PACK")?new Fn(t.shape,Dn):new vn(t.shape,$n),this.compileAndRun(e,[t])}prelu(t,e){const n=(0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new te(Jt,t.shape,e.shape):new Zt(Qt,t.shape,e.shape);return this.compileAndRun(n,[t,e])}elu(t){if((0,o.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,On,t.dtype);const e=new vn(t.shape,Cn);return this.compileAndRun(e,[t])}eluDer(t,e){const n=(0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new te("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",t.shape,e.shape):new Zt("return (b >= 1.0) ? a : a * (b + 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e])}selu(t){const e=new vn(t.shape,Nn);return this.compileAndRun(e,[t])}clip(t,e,n){let r;r=(0,o.OBj)().getBool("WEBGL_PACK_CLIP")?new ne(t.shape):new ee(t.shape);const s=r.getCustomSetupFunc(e,n);return this.compileAndRun(r,[t],null,s)}abs(t){if(this.shouldExecuteOnCPU([t])&&"complex64"!==t.dtype){const e=dt(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,e)}if((0,o.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,bn,t.dtype);const e=new vn(t.shape,bn);return this.compileAndRun(e,[t])}complexAbs(t){const e=this.texData.get(t.dataId),n=new re(t.shape),r=[this.makeComplexComponentTensorInfo(t,e.complexTensorInfos.real),this.makeComplexComponentTensorInfo(t,e.complexTensorInfos.imag)];return this.compileAndRun(n,r)}sigmoid(t){const e=new vn(t.shape,"return 1.0 / (1.0 + exp(-1.0 * x));");return this.compileAndRun(e,[t])}softplus(t){const e=new vn(t.shape,"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");return this.compileAndRun(e,[t])}asin(t){const e=new vn(t.shape,"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n");return this.compileAndRun(e,[t])}acos(t){const e=new vn(t.shape,"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n");return this.compileAndRun(e,[t])}atan(t){const e=new vn(t.shape,"if (isnan(x)) return x;\n  return atan(x);\n");return this.compileAndRun(e,[t])}sinh(t){const e=new vn(t.shape,"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])}cosh(t){const e=new vn(t.shape,"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])}tanh(t){const e=new vn(t.shape,"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");return this.compileAndRun(e,[t])}asinh(t){const e=new vn(t.shape,"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));");return this.compileAndRun(e,[t])}acosh(t){const e=new vn(t.shape,"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));");return this.compileAndRun(e,[t])}atanh(t){const e=new vn(t.shape,"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;");return this.compileAndRun(e,[t])}erf(t){const e=new vn(t.shape,Rn);return this.compileAndRun(e,[t])}step(t,e){const n=new vn(t.shape,function(t=0){return`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t});\n  `}(e));return this.compileAndRun(n,[t])}conv2dByMatMul(t,e,n,r,s,a){const i=t.shape,u=this.texData.get(t.dataId),c=n.inChannels,l=i[0]*i[1]*i[2],p=n.outChannels,d="channelsLast"===n.dataFormat,h=(1===l||1===p)&&c>1e3,f=i[2]%2!=0&&!!u.isPacked;if(h||!(0,o.OBj)().getBool("WEBGL_LAZILY_UNPACK")||!(0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!f){const u=d?i[0]*i[1]*i[2]:i[0]*i[2]*i[3],c=(0,o.XLQ)(t,[1,u,n.inChannels]),l=(0,o.XLQ)(e,[1,n.inChannels,n.outChannels]),p=this.fusedBatchMatMul({a:c,b:l,transposeA:!1,transposeB:!1,bias:r,activation:s,preluActivationWeights:a});return(0,o.XLQ)(p,n.outShape)}const m=d?i[0]*i[1]*(i[2]+1):i[0]*i[2]*(i[3]+1),g={dataId:t.dataId,shape:[1,m,n.inChannels],dtype:t.dtype},y=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,o.D5U.hu(R(u.shape,g.shape),(()=>`packed reshape ${u.shape} to ${g.shape} isn't free`));const x=(0,o.XLQ)(e,[1,n.inChannels,n.outChannels]),v=this.fusedBatchMatMul({a:g,b:x,transposeA:!1,transposeB:!1,bias:r,activation:s,preluActivationWeights:a}),b=this.texData.get(v.dataId);return o.D5U.hu(b.isPacked,(()=>"batchMatMul result is expected to be packed")),u.shape=y,b.shape=n.outShape,(0,o.SRH)().makeTensorFromDataId(v.dataId,n.outShape,v.dtype)}conv2dWithIm2Row(t,e,n,r,o,s){const{filterWidth:a,filterHeight:i,inChannels:u,outWidth:c,outHeight:l,dataFormat:p}=n,d="channelsLast"===p,h=a*i*u,f=l*c,m=[h,f],g=t.squeeze([0]),y=e.reshape([1,h,-1]),x=new Pe(m,g.shape,n),v=this.compileAndRun(x,[g]).reshape([1,m[0],m[1]]),b=null!=r,w=null!=s,$=o?zn(o,!0):null,C=new ze(v.shape,y.shape,[1,f,n.outChannels],!0,!1,b,$,w),N=[v,y];r&&N.push(r),w&&N.push(s);const I=this.compileAndRun(C,N);return d?I.reshape([1,l,c,n.outChannels]):I.reshape([1,n.outChannels,l,c])}fusedConv2d({input:t,filter:e,convInfo:n,bias:r,activation:s,preluActivationWeights:a}){if(1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))return this.conv2dByMatMul(t,e,n,r,s,a);if((0,o.OBj)().getBool("WEBGL_CONV_IM2COL")&&1===t.shape[0])return this.conv2dWithIm2Row(t,e,n,r,s,a);const i=null!=r,u=null!=a,c=s?zn(s,!1):null,l=new le(n,i,c,u),p=[t,e];return r&&p.push(r),a&&p.push(a),this.compileAndRun(l,p)}conv2d(t,e,n){if(1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))return this.conv2dByMatMul(t,e,n);if((0,o.OBj)().getBool("WEBGL_CONV_IM2COL")&&1===t.shape[0])return this.conv2dWithIm2Row(t,e,n);const r=new le(n);return this.compileAndRun(r,[t,e])}conv2dDerInput(t,e,n){const r=new se(n);return this.compileAndRun(r,[t,e])}conv2dDerFilter(t,e,n){const r=new oe(n);return this.compileAndRun(r,[t,e])}fusedDepthwiseConv2D({input:t,filter:e,convInfo:n,bias:r,activation:s,preluActivationWeights:a}){const i=(0,o.OBj)().getBool("WEBGL_PACK_DEPTHWISECONV")&&n.strideWidth<=2&&n.outChannels/n.inChannels==1,u=s?zn(s,i):null,c=[t,e],l=null!=r,p=null!=a;let d;return l&&c.push(r),p&&c.push(a),i?(d=new he(n,l,u,p),this.compileAndRun(d,c)):(d=new de(n,l,u,p),this.compileAndRun(d,c))}depthwiseConv2D(t,e,n){let r;return(0,o.OBj)().getBool("WEBGL_PACK_DEPTHWISECONV")&&n.strideWidth<=2&&n.outChannels/n.inChannels==1?(r=new he(n),this.compileAndRun(r,[t,e])):(r=new de(n),this.compileAndRun(r,[t,e]))}depthwiseConv2DDerInput(t,e,n){const r=new ce(n);return this.compileAndRun(r,[t,e])}depthwiseConv2DDerFilter(t,e,n){const r=new ue(n);return this.compileAndRun(r,[t,e])}conv3d(t,e,n){const r=new pe(n);return this.compileAndRun(r,[t,e])}conv3dDerInput(t,e,n){const r=new ie(n);return this.compileAndRun(r,[t,e])}conv3dDerFilter(t,e,n){const r=new ae(n);return this.compileAndRun(r,[t,e])}unstack(t,e){const n=t.shape[e],r=new Array(t.rank-1);let o=0;for(let n=0;n<t.rank;n++)n!==e&&(r[o++]=t.shape[n]);const s=new Array(t.rank).fill(0),a=t.shape.slice();a[e]=1;const i=new Array(n);for(let n=0;n<i.length;n++)s[e]=n,i[n]=this.slice(t,s,a).reshape(r);return i}avgPool3d(t,e){const n=new Ye(e,"avg",!1);return this.compileAndRun(n,[t],"float32")}avgPool3dBackprop(t,e,n){const r=new Yt(n);return this.compileAndRun(r,[t],e.dtype)}maxPool3d(t,e){const n=new Ye(e,"max",!1);return this.compileAndRun(n,[t],"float32")}maxPool3dBackprop(t,e,n,r){const o=new Ye(r,"max",!0),s=this.compileAndRun(o,[e]),a=new Ue(r),i=this.compileAndRun(a,[t,s],e.dtype);return s.dispose(),i}resizeBilinear(t,e,n,r){const s=(0,o.OBj)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new en(t.shape,e,n,r):new tn(t.shape,e,n,r);return this.compileAndRun(s,[t],"float32")}resizeBilinearBackprop(t,e,n){const r=new Je(t,e,n);return this.compileAndRun(r,[t])}resizeNearestNeighbor(t,e,n,r){const o=new rn(t.shape,e,n,r);return this.compileAndRun(o,[t])}resizeNearestNeighborBackprop(t,e,n){const r=new nn(t,e,n);return this.compileAndRun(r,[t])}multinomial(t,e,n,r){const s=e?t:(0,o.XAC)(t),a=s.shape[0],i=s.shape[1],u=new Ge(a,i,n),c=u.getCustomSetupFunc(r);return this.compileAndRun(u,[s],"int32",c)}oneHot(t,e,n,r){const o=new Xe(t.size,e,n,r);return this.compileAndRun(o,[t])}diag(t){const e=new we(t.size);return this.compileAndRun(e,[t])}cropAndResize(t,e,n,r,o,s){const a=new fe(t.shape,e.shape,r,o,s);return this.compileAndRun(a,[t,e,n],"float32")}depthToSpace(t,e,n){o.D5U.hu(e>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`));const r=t.shape[0],s="NHWC"===n?t.shape[1]:t.shape[2],a="NHWC"===n?t.shape[2]:t.shape[3],i="NHWC"===n?t.shape[3]:t.shape[1],u=s*e,c=a*e,l=i/(e*e),p=new be("NHWC"===n?[r,u,c,l]:[r,l,u,c],e,n);return this.compileAndRun(p,[t])}split(t,e,n){return Mn(t,e,n)}scatterND(t,e,n){const{sliceRank:r,numUpdates:s,sliceSize:a,strides:i,outputSize:u}=o.Wap.calculateShapes(e,t,n),c=[u/a,a],l=t.reshape([s,r]),p=e.reshape([s,a]);if(0===u)return o.Wap.reshapeTensor((0,o.XeE)([]),n);const d=(0,o.iD$)(0),h=new an(s,r,l.rank,p.rank,i,c);return this.compileAndRun(h,[p,l,d]).reshape(n)}sparseToDense(t,e,n,r){const{sliceRank:s,numUpdates:a,strides:i,outputSize:u}=o.Wap.calculateShapes(e,t,n),c=new an(a,s,t.rank,e.rank,i,[u,1],!1);return this.compileAndRun(c,[e,t,r]).reshape(n)}gatherND(t,e){const n=e.shape,r=n[n.length-1],[s,a,i,u]=o.Wap.prepareAndValidate(t,e),c=e.reshape([a,r]),l=t.reshape([t.size/i,i]),p=new ke(r,u,[a,i]);return this.compileAndRun(p,[l,c]).reshape(s)}fill(t,e,n){if("string"===(n=n||o.D5U.D2(e))){const r=o.D5U.rQ(n,o.D5U.NA(t));return r.fill(e),(0,o.SRH)().makeTensor(r,t,n,this)}{const r=new Ee(t,e),o=r.getCustomSetupFunc(e);return this.compileAndRun(r,[],n,o)}}onesLike(t){if("string"===t.dtype)throw new Error("onesLike is not supported under string dtype");return this.fill(t.shape,1,t.dtype)}zerosLike(t){return this.fill(t.shape,"string"===t.dtype?"":0,t.dtype)}linspace(t,e,n){return o.Wap.linspaceImpl(t,e,n)}makeTensorInfo(t,e,n){const r=this.write(n,t,e);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:e}}makeOutput(t,e,n){const{dataId:r}=this.makeTensorInfo(t,e,n);return(0,o.SRH)().makeTensorFromDataId(r,t,e,this)}unpackTensor(t){const e=new Bn(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new He(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const n=[E(t.shape),...T(t.shape)],r={dtype:t.dtype,shape:n,dataId:t.dataId},o=[E(e),...T(e)],s=new Ze(o,n),a=this.runWebGLProgram(s,[r],t.dtype,null,!0);return{dataId:a.dataId,shape:e,dtype:a.dtype}}decode(t){const e=this.texData.get(t),{isPacked:n,shape:r,dtype:o}=e,s=k(r);let a;return a=n?new ve(s):new xe(s),{dtype:o,shape:r,dataId:this.runWebGLProgram(a,[{shape:s,dtype:o,dataId:t}],o,null,!0).dataId}}runWebGLProgram(t,e,n,r,s=!1){const a=this.makeTensorInfo(t.outputShape,n),i=this.texData.get(a.dataId);if(t.packedOutput&&(i.isPacked=!0),t.outPackingScheme===u.DENSE){const e=d(t.outputShape);i.texShape=e.map((t=>2*t))}if(null!=t.outTexUsage&&(i.usage=t.outTexUsage),0===o.D5U.NA(a.shape))return i.values=o.D5U.WP(a.dtype,0),a;const c=[],l=e.map((e=>{if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(e.dataId);if(null==n.texture){if(!t.packedInputs&&o.D5U.NA(e.shape)<=(0,o.OBj)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.packedInputs&&(n.isPacked=!0,n.shape=e.shape)}else if(!!n.isPacked!=!!t.packedInputs)e=n.isPacked?this.unpackTensor(e):this.packTensor(e),c.push(e),n=this.texData.get(e.dataId);else if(n.isPacked&&!R(n.shape,e.shape)){const t=e,r=e.shape;e.shape=n.shape,e=this.packedReshape(e,r),c.push(e),n=this.texData.get(e.dataId),t.shape=r}return this.uploadToGPU(e.dataId),{shape:e.shape,texData:n,isUniform:!1}}));this.uploadToGPU(a.dataId);const p={shape:a.shape,texData:i,isUniform:!1},h=function(t,e,n){let r="";e.concat(n).forEach((t=>{const e=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0,n=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${n}_${e}`}));const o=t.userCode;let s=t.constructor.name;return s+="_"+r+"_"+o,s}(t,l,p),f=this.getAndSaveBinary(h,(()=>function(t,e,n,r){const s=e.userCode,a=n.map(((t,n)=>{const r={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(r.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:r}})),i=a.map((t=>t.shapeInfo)),u={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},c=Bt(a,u,s,e.packedInputs),l=t.createProgram(c);let p=null;const d=t.getUniformLocation(l,"NAN",!1);1===(0,o.OBj)().getNumber("WEBGL_VERSION")&&(p=t.getUniformLocation(l,"INFINITY",!1));const h={};for(let n=0;n<e.variableNames.length;n++){const r=e.variableNames[n],o=!1;h[r]=t.getUniformLocation(l,r,o),h[`offset${r}`]=t.getUniformLocation(l,`offset${r}`,o)}return{program:e,source:c,webGLProgram:l,uniformLocations:h,inShapeInfos:i,outShapeInfo:u,infLoc:p,nanLoc:d}}(this.gpgpu,t,l,p))),m=null!=this.activeTimers;let g;if(m&&(g=this.startTimer()),function(t,e,n,r,s){Be(e.inShapeInfos,n),Be([e.outShapeInfo],[r]);const a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(a,i[0],i[1]):t.setOutputMatrixTexture(a,i[0],i[1]),t.setProgram(e.webGLProgram),1===(0,o.OBj)().getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach(((n,r)=>{const s=e.program.variableNames[r],a=e.uniformLocations[s],i=e.uniformLocations[`offset${s}`];if(null!=a)if(n.isUniform)if(o.D5U.NA(n.shape)<2)t.gl.uniform1f(a,n.uniformValues[0]);else{let e=n.uniformValues;e instanceof Float32Array||(e=new Float32Array(e)),t.gl.uniform1fv(a,e)}else null!=n.texData.slice&&null!=i&&t.gl.uniform1i(i,n.texData.slice.flatOffset),t.setInputMatrixTexture(n.texData.texture,a,r)})),null!=s&&s(t,e.webGLProgram),t.executeProgram()}(this.gpgpu,f,l,p,r),c.forEach((t=>this.disposeIntermediateTensorInfo(t))),m&&(g=this.endTimer(g),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(g)})),!(0,o.OBj)().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===s){const t=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),t}return a}compileAndRun(t,e,n,r,s=!1){n=n||e[0].dtype;const a=this.runWebGLProgram(t,e,n,r,s);return(0,o.SRH)().makeTensorFromDataId(a.dataId,a.shape,a.dtype)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||((0,o.OBj)().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(0,o.lub)((()=>{if(!(0,o.OBj)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=(0,o.OBj)().getBool("DEBUG");(0,o.OBj)().set("DEBUG",!1);const e=this.abs((0,o.iD$)(1e-8)).dataSync()[0];if((0,o.OBj)().set("DEBUG",t),e>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(t){const e=this.texData.get(t),{shape:n,dtype:r,values:s,texture:a,usage:i,isPacked:u}=e;if(null!=a)return;const l=null!=this.activeTimers;let p;l&&(p=o.D5U.zO());let d=e.texShape;if(null==d&&(d=function(t,e=!1){let n=(0,o.OBj)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e&&(n*=2,1===(t=t.map(((e,n)=>n>=t.length-2?o.D5U.nY(t[n]):t[n]))).length&&(t=[2,t[0]])),2!==t.length){const e=o.D5U.bp(t);t=e.newShape}let r=o.D5U.NA(t);if(t.length<=1&&r<=n)return[1,r];if(2===t.length&&t[0]<=n&&t[1]<=n)return t;if(3===t.length&&t[0]*t[1]<=n&&t[2]<=n)return[t[0]*t[1],t[2]];if(3===t.length&&t[0]<=n&&t[1]*t[2]<=n)return[t[0],t[1]*t[2]];if(4===t.length&&t[0]*t[1]*t[2]<=n&&t[3]<=n)return[t[0]*t[1]*t[2],t[3]];if(4===t.length&&t[0]<=n&&t[1]*t[2]*t[3]<=n)return[t[0],t[1]*t[2]*t[3]];if(e){const e=E(t);let n=2,s=2;return t.length&&([n,s]=T(t)),r=e*(n/2)*(s/2),o.D5U.YP(r).map((t=>2*t))}return o.D5U.YP(r)}(n,u),e.texShape=d),null!=s){const t=k(n);let a,i=d[1],f=d[0];const m=s instanceof Uint8Array;u?([i,f]=h(d[0],d[1]),a=new Ie(t,[f,i],m)):a=new Ne(t,[f,i],m);const g=this.makeTensorInfo([f,i],r);this.texData.get(g.dataId).usage=m?c.PIXELS:c.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(g.dataId),i,f,s);const y=!0,x=this.runWebGLProgram(a,[g],r,null,y),v=this.texData.get(x.dataId);e.texture=v.texture,e.texShape=v.texShape,e.isPacked=v.isPacked,e.usage=v.usage,this.disposeIntermediateTensorInfo(g),this.texData.delete(x.dataId),e.values=null,l&&(this.uploadWaitMs+=o.D5U.zO()-p)}else{const t=this.acquireTexture(d,i,r,u);e.texture=t}}convertAndCacheOnCPU(t,e){const n=this.texData.get(t),{dtype:r}=n;return this.releaseGPUData(t),null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){const n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length);for(let e=0;e<n.length;++e)n[e]=Math.round(t[e]);return n}throw new Error(`Unknown dtype ${e}`)}(e,r)),n.values}acquireTexture(t,e,n,r){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const t=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${t} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,r)}computeBytes(t,e){return t[0]*t[1]*o.D5U.bT(e)}tryRunOnCpuOrThrow(t,e){if(this.shouldExecuteOnCPU(t))try{return e()}catch(t){if((0,o.OBj)().getBool("IS_TEST"))throw new Error("CPU forwarding failed")}return null}}function Xn(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}o.C2$.j()&&(0,o.jqO)("webgl",(()=>new Gn),2);const Hn={kernelName:o.iJz,backendName:"webgl",kernelFunc:Xn};function jn(t){const{inputs:e,backend:n}=t,{real:r,imag:o}=e,s=n.makeTensorInfo(r.shape,"complex64"),a=n.texData.get(s.dataId),i=Xn({inputs:{x:r},backend:n});n.texData.get(i.dataId).complexParentRefCount++;const u=Xn({inputs:{x:o},backend:n});return n.texData.get(u.dataId).complexParentRefCount++,a.complexTensorInfos={real:i,imag:u},s}const Kn={kernelName:o.Zz9,backendName:"webgl",kernelFunc:jn};function qn(t){return({inputs:e,backend:n})=>{const{x:r}=e,o=n,s=new vn(r.shape,t);return o.runWebGLProgram(s,[r],r.dtype)}}function Yn({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:i,backend:u})=>{const{a:c,b:l}=i,p=u;if(r&&"complex64"===c.dtype){const e=p.texData.get(c.dataId),n=p.texData.get(l.dataId),[r,s]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,r]=e,s={dataId:n.dataId,dtype:n.dtype,shape:c.shape},a={dataId:r.dataId,dtype:r.dtype,shape:l.shape},i=new Zt(t,c.shape,l.shape);return p.runWebGLProgram(i,[s,a],(0,o.x8V)(n.dtype,r.dtype))})),a=jn({inputs:{real:r,imag:s},backend:p});return p.disposeIntermediateTensorInfo(r),p.disposeIntermediateTensorInfo(s),a}const d=a||(0,o.x8V)(c.dtype,l.dtype);if(p.shouldExecuteOnCPU([c,l])&&null!=s){const t=p.texData.get(c.dataId),e=p.texData.get(l.dataId),[n,r]=s(c.shape,l.shape,t.values,e.values,d),o=p.makeTensorInfo(r,d);return p.texData.get(o.dataId).values=n,o}let h;return h=(0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=e?new te(e,c.shape,l.shape,n):new Zt(t,c.shape,l.shape),p.runWebGLProgram(h,[c,l],d)}}const Qn="return a + b;",Zn=Yn({opSnippet:Qn,packedOpSnippet:Qn,supportsComplex:!0,cpuKernelImpl:ht}),Jn={kernelName:o.mm_,backendName:"webgl",kernelFunc:Zn},tr=Yn({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),er={kernelName:o.QCc,backendName:"webgl",kernelFunc:tr},nr={kernelName:o.JhU,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;B(s,"avgPool");const{filterSize:a,strides:i,pad:u,dimRoundingMode:c}=r;o.D5U.hu(o.Wap.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const l=o.Wap.computePool2DInfo(s.shape,a,i,1,u,c);if(1===l.filterWidth&&1===l.filterHeight&&o.D5U.cO(l.inShape,l.outShape))return Xn({inputs:{x:s},backend:n});const p=new qe(l,"avg",!1);return n.runWebGLProgram(p,[s],"float32")}},rr={kernelName:o.xts,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:a}=e,i=a;B([s,a],"avgPoolBackprop");const{filterSize:u,strides:c,pad:l}=r,p=o.Wap.computePool2DInfo(i.shape,u,c,1,l),d=new qt(p);return n.runWebGLProgram(d,[s],i.dtype)}};class or{constructor(t,e,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],o.Wap.assertAndGetBroadcastShape(t,e),o.Wap.assertAndGetBroadcastShape(t,n);let i="0.0";null!=r&&(o.Wap.assertAndGetBroadcastShape(t,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="1.0";null!=s&&(o.Wap.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${u};\n        float inv = scale * inversesqrt(variance + float(${a}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class sr{constructor(t,e,n,r,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],o.Wap.assertAndGetBroadcastShape(t,e),o.Wap.assertAndGetBroadcastShape(t,n);let i="vec4(0.0)";null!=r&&(o.Wap.assertAndGetBroadcastShape(t,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="vec4(1.0)";null!=s&&(o.Wap.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${u};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${a}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const ar={kernelName:o.sHE,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,mean:s,variance:a,offset:i,scale:u}=t;o.D5U.hu(s.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),o.D5U.hu(null==i||s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),o.D5U.hu(null==u||s.shape.length===u.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:c}=n;null==c&&(c=.001);const l=[r,s,a];let p=null;null!=i&&(p=i.shape,l.push(i));let d=null;null!=u&&(d=u.shape,l.push(u));const h=(0,o.OBj)().getBool("WEBGL_PACK_NORMALIZATION")?new sr(r.shape,s.shape,a.shape,p,d,c):new or(r.shape,s.shape,a.shape,p,d,c);return e.runWebGLProgram(h,l,l[0].dtype)}},ir=Yn({opSnippet:"return float(a != b);",dtype:"bool"}),ur={kernelName:o.yQU,backendName:"webgl",kernelFunc:ir};function cr(t){const{inputs:e,backend:n}=t,{input:r}=e;return Xn({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const lr={kernelName:o.xJR,backendName:"webgl",kernelFunc:cr},pr={kernelName:o.RFZ,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:r,attrs:s}=e,{x:a}=n,{dtype:i}=s;if("complex64"===i){if("complex64"===a.dtype)return Xn({inputs:{x:a},backend:r});const e=o.lls(a.shape),n=t({inputs:{x:a},backend:r,attrs:{dtype:"float32"}}),s=jn({inputs:{real:n,imag:e},backend:r});return e.dispose(),r.disposeIntermediateTensorInfo(n),s}if("complex64"===a.dtype){const e=cr({inputs:{input:a},backend:r}),n=t({inputs:{x:e},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(e),n}if(!o.D5U.QB(a.dtype,i)){const t=Xn({inputs:{x:a},backend:r});return{dataId:t.dataId,shape:t.shape,dtype:i}}if("int32"===i)return function(t,e){const n=new vn(t.shape,"return float(int(x));"),r=e.runWebGLProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(a,r);if("bool"===i){const t=r.makeTensorInfo([],"bool",o.D5U.WP("bool",1)),e=ir({inputs:{a:a,b:t},backend:r});return r.disposeIntermediateTensorInfo(t),e}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${i}`)}};class dr{constructor(t){this.outputShape=[],this.outputShape=o.Wap.computeOutShape(t,1),this.variableNames=t.map(((t,e)=>`T${e}`));const e=new Array(t.length-1);e[0]=t[0][1];for(let n=1;n<e.length;n++)e[n]=e[n-1]+t[n][1];const n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let t=1;t<e.length;t++){const r=e[t-1];n.push(`else if (yC < ${e[t]}) setOutput(getT${t}(yR, yC-${r}));`)}const r=e.length,s=e[e.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class hr{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=o.Wap.computeOutShape(t,e);const n=this.outputShape,r=n.length,s=Xt(r),a=Rt("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map(((t,e)=>`T${e}`));const u=new Array(t.length-1);u[0]=t[0][e];for(let n=1;n<u.length;n++)u[n]=u[n-1]+t[n][e];const c=i[e],l=i.slice(-2),p=i.join();let d=`if (${c} < ${u[0]}) {\n        return getChannel(\n            getT0(${p}), vec2(${l.join()}));\n        }`;for(let t=1;t<u.length;t++){const e=u[t-1];d+=`\n        if (${c} < ${u[t]}  && ${c} >= ${u[t-1]}) {\n          return getChannel(\n            getT${t}(${fr(i,c,e)}),\n            vec2(${fr(l,c,e)}));\n        }`}const h=u.length,f=u[u.length-1];d+=`\n        return getChannel(\n          getT${h}(${fr(i,c,f)}),\n          vec2(${fr(l,c,f)}));`,this.userCode=`\n      float getValue(${i.map((t=>"int "+t))}) {\n        ${d}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[r-1]} = ${a[r-1]} + 1;\n        if (${a[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[r-2]} = ${a[r-2]} + 1;\n        if (${a[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[r-1]} = ${a[r-1]} - 1;\n        if (${a[r-2]} < ${n[r-2]} &&\n            ${a[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `}}function fr(t,e,n){const r=t.indexOf(e);return t.map(((t,e)=>e===r?`${t} - ${n}`:t)).join()}function mr(t){const{inputs:e,backend:n}=t,{input:r}=e;return Xn({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const gr={kernelName:o.J_u,backendName:"webgl",kernelFunc:mr};function yr(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{shape:a}=r,i=n,u=o.D5U.NA(s.shape),c=o.D5U.JZ(a,u),l=o.D5U.NA(c);o.D5U.hu(u===l,(()=>`The new shape (${c}) has ${l} elements and the old shape (${s.shape}) has ${u} elements. The new shape and old shape must have the same number of elements.`));const p=i.texData.get(s.dataId);return!p.isPacked||R(s.shape,c)||null!==p.texture&&R(p.shape,c)?(i.incRef(s.dataId),{dataId:s.dataId,shape:c,dtype:s.dtype}):function(t,e,n){const r=[E(t.shape),...T(t.shape)],o={dtype:t.dtype,shape:r,dataId:t.dataId},s=[E(e),...T(e)],a=new Ze(s,r),i=n.runWebGLProgram(a,[o],t.dtype,null,!0);return{dataId:i.dataId,shape:e,dtype:i.dtype}}(s,c,i)}const xr={kernelName:o.HZH,backendName:"webgl",kernelFunc:yr};function vr(t,e,n){const r=t[0].dtype;if("complex64"===r){const r=t.map((t=>cr({inputs:{input:t},backend:n}))),o=t.map((t=>mr({inputs:{input:t},backend:n}))),s=vr(r,e,n),a=vr(o,e,n),i=jn({inputs:{real:s,imag:a},backend:n});return r.forEach((t=>n.disposeIntermediateTensorInfo(t))),o.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}if(t.length>(0,o.OBj)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const r=Math.floor(t.length/2),o=vr(t.slice(0,r),e,n),s=vr(t.slice(r),e,n),a=vr([o,s],e,n);return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(s),a}if((0,o.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].shape.length>1){const o=new hr(t.map((t=>t.shape)),e);return n.runWebGLProgram(o,t,r)}const s=o.Wap.computeOutShape(t.map((t=>t.shape)),e),a=t.map((t=>yr({inputs:{x:t},attrs:{shape:[-1,o.D5U.NA(t.shape.slice(e))]},backend:n}))),i=new dr(a.map((t=>t.shape))),u=n.runWebGLProgram(i,a,r);a.forEach((t=>n.disposeIntermediateTensorInfo(t)));const c=yr({inputs:{x:u},attrs:{shape:s},backend:n});return n.disposeIntermediateTensorInfo(u),c}const br={kernelName:o.Eh3,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r,a=o.D5U.EC(s,e[0].shape)[0],i=o.Wap.computeOutShape(e.map((t=>t.shape)),a);if(0===o.D5U.NA(i))return n.makeTensorInfo(i,e[0].dtype,[]);const u=e.filter((t=>o.D5U.NA(t.shape)>0));if(1===u.length)return u[0];const c=u.map((t=>t.shape));return o.Wap.assertParamsConsistent(c,a),vr(u,a,n)}},wr=qn("if (isnan(x)) return x;\n  return cos(x);\n"),$r={kernelName:o.mc4,backendName:"webgl",kernelFunc:wr},Cr=Yn({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),Nr={kernelName:o.ZCY,backendName:"webgl",kernelFunc:Cr};class Ir{constructor(t,e,n){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const o=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${r}.0`:"1.0";let a;if("real"===t)a="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${o};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${s};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function Er(t,e,n){const r=n.texData.get(t.dataId),s=o.D5U.NA(t.shape),a=t.shape[t.shape.length-1],i=yr({inputs:{x:t},backend:n,attrs:{shape:[s/a,a]}}).shape,u=new Ir("real",i,e),c=new Ir("imag",i,e),l=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:i},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:i}],p=n.runWebGLProgram(u,l,"float32"),d=n.runWebGLProgram(c,l,"float32"),h=jn({inputs:{real:p,imag:d},backend:n});n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d);const f=yr({inputs:{x:h},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(f),f}const Tr={kernelName:o.vwp,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e;return Er(r,!1,n)}};class kr{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Sr={kernelName:o.Uyb,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,o=new kr(n.shape);return r.runWebGLProgram(o,[n],n.dtype)}};class Rr{constructor(t){this.variableNames=["A"];const e=_t(),[n,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class _r{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=_t(),[n,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const Ar={kernelName:o.eBW,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:s}=e;const{numChannels:a}=r,i="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,u="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,[l,p]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],d=[p,l],h=[p,l,a];(u||i)&&(null==Dr&&(Dr=document.createElement("canvas").getContext("2d")),Dr.canvas.width=l,Dr.canvas.height=p,Dr.drawImage(s,0,0,l,p),s=Dr.canvas);const f=n.makeTensorInfo(d,"int32");n.texData.get(f.dataId).usage=c.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(f.dataId),s);const m=(0,o.OBj)().getBool("WEBGL_PACK")?new _r(h):new Rr(h),g=n.runWebGLProgram(m,[f],"int32");return n.disposeData(f.dataId),g}};let Dr;const Or={kernelName:o.Qg5,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e;return Er(r,!0,n)}};class Fr{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=t;this.outputShape=[r,a];const i=4*Math.floor(n/4),u=n%4;let c="sumValue += dot(values, ones);";if(null!=e){const t=1/e;c=`sumValue += dot(values * ${o.D5U.GN(t)?t.toPrecision(2):t}, ones);`}let l="";s%n>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===u}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${c}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${c}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}function Br(t,e,n,r){const s=function(t){const e=[];for(;0===e.length||1!==e[e.length-1].outSize;){const n=e.length?e[e.length-1].outSize:t[1],r=o.Wap.computeOptimalWindowSize(n);e.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return e}(t.shape);let a=t;for(let o=0;o<s.length;o++){const{inSize:i,windowSize:u,outSize:c}=s[o];let l,p;l="mean"===n?0===o?new Fr({windowSize:u,inSize:i,batchSize:t.shape[0],outSize:c},i):new Fr({windowSize:u,inSize:i,batchSize:t.shape[0],outSize:c}):new Qe({windowSize:u,inSize:i,batchSize:t.shape[0],outSize:c},n),p=a,a=r.runWebGLProgram(l,[a],e),p.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(p)}return a}class Pr{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let r=0;r<n.length;r++)n[r]=t[e[r]];this.outputShape=n,this.rank=n.length;const r=Xt(this.rank),o=function(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let e=0;e<t.length;e++)r[t[e]]=n[e];return r.join()}(e);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${o}));\n    }\n    `}}class Mr{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(t.length);for(let r=0;r<n.length;r++)n[r]=t[e[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Xt(this.rank),o=St("rc",this.rank),s=new Array(this.rank);for(let t=0;t<e.length;t++)s[e[t]]=o[t];const a=`vec2(${s.slice(-2).join()})`,i=`++${o[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${s.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${i}) {\n        result[1] = ${u};\n      }\n      --${o[this.rank-1]};\n      if(++${o[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${u};\n        if(${i}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function Lr(t,e,n){const r=(0,o.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Mr(t.shape,e):new Pr(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}const Vr={kernelName:o.YoZ,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{reductionIndices:s,keepDims:a}=e,i=n,u=r.shape.length,c=o.D5U.EC(s,r.shape);let l=c;const p=o.Wap.getAxesPermutation(l,u),d=null!=p,h=i.shouldExecuteOnCPU([r]);let f=r;if(d){if(h){const t=i.texData.get(f.dataId).values,e=new Array(u);for(let t=0;t<e.length;t++)e[t]=r.shape[p[t]];const n=Nt(t,r.shape,r.dtype,p,e);f=i.makeTensorInfo(e,r.dtype),i.texData.get(f.dataId).values=n}else f=Lr(r,p,i);l=o.Wap.getInnerMostAxes(l.length,u)}o.Wap.assertAxesAreInnerMostDims("max",l,u);const[m,g]=o.Wap.computeOutAndReduceShapes(f.shape,l);let y,x=m;if(a&&(x=o.Wap.expandShapeToKeepDim(m,c)),h){const t=i.texData.get(f.dataId).values,e=vt(t,o.D5U.NA(g),x,r.dtype);y=i.makeTensorInfo(x,r.dtype),i.texData.get(y.dataId).values=e}else y=function(t,e,n,r){const s=o.D5U.NA(e),a=yr({inputs:{x:t},attrs:{shape:[o.D5U.NA(t.shape)/s,s]},backend:r}),i=Br(a,t.dtype,"max",r),u=yr({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),u}(f,g,x,i);return d&&i.disposeIntermediateTensorInfo(f),y}},Wr={kernelName:o.mTV,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;B(s,"maxPool");const{filterSize:a,strides:i,pad:u,dimRoundingMode:c}=r;o.D5U.hu(o.Wap.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const l=o.Wap.computePool2DInfo(s.shape,a,i,1,u,c);if(1===l.filterWidth&&1===l.filterHeight&&o.D5U.cO(l.inShape,l.outShape))return Xn({inputs:{x:s},backend:n});const p=new qe(l,"max",!1);return n.runWebGLProgram(p,[s],s.dtype)}},Ur={kernelName:o.GvW,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:a,output:i}=e,u=a;B([a,i],"maxPoolBackprop");const{filterSize:c,strides:l,pad:p,dimRoundingMode:d}=r,h=o.Wap.computePool2DInfo(u.shape,c,l,1,p,d),f=new qe(h,"max",!0),m=n.runWebGLProgram(f,[u],u.dtype),g=new We(h),y=n.runWebGLProgram(g,[s,m],u.dtype);return n.disposeIntermediateTensorInfo(m),y}},zr={kernelName:o.vFR,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:s,strides:a,pad:i,includeBatchInIndex:u}=e,c=n;o.D5U.hu(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const l=[1,1];o.D5U.hu(o.Wap.eitherStridesOrDilationsAreOne(a,l),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`));const p=o.Wap.computePool2DInfo(r.shape,s,a,l,i),[d,h]=function(t,e,n,r){let o=new qe(n,"max",!1);const s=r.runWebGLProgram(o,[t],"float32");return o=new qe(n,"max",!0,!0,e),[s,r.runWebGLProgram(o,[t],"float32")]}(r,u,p,c);return[d,h]}},Gr={kernelName:o.q2K,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{keepDims:s,axis:a}=e,i=n,u=r.shape.length,c=o.D5U.EC(a,r.shape);let l=c;const p=o.Wap.getAxesPermutation(l,u),d=null!=p,h=i.shouldExecuteOnCPU([r]),f=[];let m=r;if(d){if(h){const t=i.texData.get(m.dataId).values,e=new Array(u);for(let t=0;t<e.length;t++)e[t]=r.shape[p[t]];const n=Nt(t,r.shape,r.dtype,p,e);m=i.makeTensorInfo(e,r.dtype),i.texData.get(m.dataId).values=n}else m=Lr(r,p,i);f.push(m),l=o.Wap.getInnerMostAxes(l.length,u)}o.Wap.assertAxesAreInnerMostDims("sum",l,u);const[g,y]=o.Wap.computeOutAndReduceShapes(m.shape,l);let x=g;s&&(x=o.Wap.expandShapeToKeepDim(g,c));const v=function(t,e,n,r){const s=o.D5U.NA(e),a=yr({inputs:{x:t},attrs:{shape:[o.D5U.NA(t.shape)/s,s]},backend:r}),i=Br(a,"float32","mean",r),u=yr({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),u}(m,y,x,i);for(const t of f)i.disposeIntermediateTensorInfo(t);return v}};class Xr{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,o=Xt(r),s=e.map((t=>t[0])).join(","),a=e.map(((e,n)=>e[0]+t[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u="reflect"===n?0:1;this.userCode=1!==r?`\n      ${o} start = ${o}(${s});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${o} coords = outC - start;\n        setOutput(getX(${i}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class Hr{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,o=Xt(r),s=e.map((t=>t[0])).join(","),a=e.map(((e,n)=>e[0]+t[n])).join(","),i=Rt("rc",r),u=Rt("source",r),c=`${i[r-1]} < ${this.outputShape[r-1]}`,l=1===r?"source":`vec2(${u.slice(-2).join()})`,p="reflect"===n?0:1;let d="";if(1===r){const t=`\n        ${o} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${p};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${p};\n        }\n        source -= start;\n      `;d=`\n        ${o} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${u.join()}), ${l});\n        ${i[r-1]} += 1;\n        if(${c}) {\n          ${t}\n          result[1] = getChannel(getX(${u.join()}), ${l});\n        }\n      `}else{const t=`\n        ${o} source = rc;\n        ${o} lt = ${o}(lessThan(source, start));\n        ${o} gte = ${o}(greaterThanEqual(source, end));\n        ${o} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${p}) +\n                gte * ((end - 1) * 2 - source + ${p});\n        source -= start;\n      `;d=`\n        ${o} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${u.join()}), ${l});\n        ${i[r-1]} += 1;\n        if(${c}) {\n          ${t}\n          result[1] = getChannel(getX(${u.join()}), ${l});\n        }\n        rc = outputLoc;\n        ${i[r-2]} += 1;\n        if(${i[r-2]} < ${this.outputShape[r-2]}) {\n          ${t}\n          result[2] = getChannel(getX(${u.join()}), ${l});\n          ${i[r-1]} += 1;\n          if(${c}) {\n            ${t}\n            result[3] = getChannel(getX(${u.join()}), ${l});\n          }\n        }\n      `}this.userCode=`\n      const ${o} start = ${o}(${s});\n      const ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const jr={kernelName:o.jQs,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r}=t,{paddings:s,mode:a}=n,i=(0,o.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Hr(r.shape,s,a):new Xr(r.shape,s,a);return e.runWebGLProgram(i,[r],r.dtype)}};class Kr{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=o.Wap.assertAndGetBroadcastShape(e,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const qr="return a * b;",Yr={kernelName:o.wYn,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{a:r,b:s}=e,a=o.Wap.upcastType(r.dtype,s.dtype);if("complex64"===r.dtype){const t=n.texData.get(r.dataId),e=n.texData.get(s.dataId),o=new Kr("return areal * breal - aimag * bimag;",r.shape,s.shape),a=new Kr("return areal * bimag + aimag * breal;",r.shape,s.shape),i=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:r.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:s.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:s.shape}],u=n.runWebGLProgram(o,i,"float32"),c=n.runWebGLProgram(a,i,"float32"),l=jn({inputs:{real:u,imag:c},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),l}if(n.shouldExecuteOnCPU([r,s])){const t=n.texData.get(r.dataId),e=n.texData.get(s.dataId),[o,i]=bt(r.shape,s.shape,t.values,e.values,a),u=n.makeTensorInfo(i,a);return n.texData.get(u.dataId).values=o,u}let i;return i=(0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new te(qr,r.shape,s.shape):new Zt(qr,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}},Qr={kernelName:o.uv1,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{o.Wap.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{boxes:r,scores:s}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u}=n,c=e,l=c.readSync(r.dataId),p=c.readSync(s.dataId),d=a,h=i,f=u;return o.GDt.GP(l,p,d,h,f)}},Zr=o.GDt.qP,Jr={kernelName:o.cye,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{o.Wap.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{boxes:r,scores:s}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:c}=n,l=e,p=l.readSync(r.dataId),d=l.readSync(s.dataId),{selectedIndices:h,validOutputs:f}=Zr(p,d,a,i,u,c);return[h,f]}},to=o.GDt.pA,eo={kernelName:o.W0H,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{o.Wap.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{boxes:r,scores:s}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,softNmsSigma:c}=n,l=e,p=l.readSync(r.dataId),d=l.readSync(s.dataId),h=a,f=i,m=u,g=c,{selectedIndices:y,selectedScores:x}=to(p,d,h,f,m,g);return[y,x]}};class no{constructor(t,e,n,r){this.variableNames=["Image"],this.outputShape=[];const s=t[1],a=t[2],i=Math.sin(e).toFixed(3),u=Math.cos(e).toFixed(3);this.outputShape=t;const[c,l]=o.Wap.getImageCenter(r,s,a),p=c.toFixed(3),d=l.toFixed(3);let h="";h="number"==typeof n?`float outputValue = ${n.toFixed(2)};`:`\n        vec3 fill = vec3(${n.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - ${p}) * ${u} - (float(y) - ${d}) * ${i};\n          float coordYFloat = (float(x) - ${p}) * ${i} + (float(y) - ${d}) * ${u};\n          int coordX = int(round(coordXFloat + ${p}));\n          int coordY = int(round(coordYFloat + ${d}));\n          ${h}\n          if(coordX >= 0 && coordX < ${a} && coordY >= 0 && coordY < ${s}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const ro={kernelName:o.b9H,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:o,fillValue:s,center:a}=e,i=n,u=new no(r.shape,o,s,a);return i.runWebGLProgram(u,[r],r.dtype)}},oo=qn("if (isnan(x)) return x;\n  return sin(x);\n"),so={kernelName:o.RQH,backendName:"webgl",kernelFunc:oo},ao=qn("return x * x;"),io={kernelName:o.bK0,backendName:"webgl",kernelFunc:ao},uo="return (a - b) * (a - b);",co=Yn({opSnippet:uo,packedOpSnippet:uo}),lo={kernelName:o._tC,backendName:"webgl",kernelFunc:co},po="return a - b;",ho=Yn({opSnippet:po,packedOpSnippet:po,supportsComplex:!0,cpuKernelImpl:Ct}),fo={kernelName:o.Tr8,backendName:"webgl",kernelFunc:ho},mo=qn("return tan(x);"),go=[Jn,er,nr,rr,ar,pr,Kn,br,$r,Nr,Tr,Sr,Ar,Hn,Or,gr,Vr,Wr,Ur,zr,Gr,jr,Yr,Qr,Jr,eo,ur,lr,xr,ro,so,io,fo,lo,{kernelName:o.sEM,backendName:"webgl",kernelFunc:mo},{kernelName:o.G3Y,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{perm:o}=e,s=n,a=r.shape.length,i=new Array(a);for(let t=0;t<i.length;t++)i[t]=r.shape[o[t]];let u;if(s.shouldExecuteOnCPU([r])){const t=s.texData.get(r.dataId).values,e=Nt(t,r.shape,r.dtype,o,i);u=s.makeTensorInfo(i,r.dtype),s.texData.get(u.dataId).values=e}else u=Lr(r,o,s);return u}},{kernelName:o.kpP,backendName:"webgl",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{axis:o}=n,{x:s}=e;B(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=r.readSync(s.dataId),{outputValues:i,outputShape:u,indices:c}=It(a,o,s.shape,s.dtype);return[r.makeTensorInfo(u,s.dtype,i),r.makeTensorInfo([c.length],"int32",c)]}}];for(const t of go)(0,o.wCN)(t)},1928:function(t,e,n){"use strict";n.d(e,{YL:function(){return Nr}});var r={};n.r(r),n.d(r,{json:function(){return A}});var o={};n.r(o),n.d(o,{json:function(){return D}});var s={};n.r(s),n.d(s,{json:function(){return O}});var a={};n.r(a),n.d(a,{json:function(){return F}});var i={};n.r(i),n.d(i,{json:function(){return B}});var u={};n.r(u),n.d(u,{json:function(){return P}});var c={};n.r(c),n.d(c,{json:function(){return M}});var l={};n.r(l),n.d(l,{json:function(){return L}});var p={};n.r(p),n.d(p,{json:function(){return V}});var d={};n.r(d),n.d(d,{json:function(){return W}});var h={};n.r(h),n.d(h,{json:function(){return U}});var f={};n.r(f),n.d(f,{json:function(){return z}});var m={};n.r(m),n.d(m,{json:function(){return G}});var g={};n.r(g),n.d(g,{json:function(){return X}});var y={};n.r(y),n.d(y,{json:function(){return H}});var x={};n.r(x),n.d(x,{json:function(){return j}});var v={};n.r(v),n.d(v,{json:function(){return K}});var b,w,$=n(6743);!function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(b||(b={})),function(t){let e;!function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))}(w||(w={}));const C={};function N(t){return C[t]}function I(t,e,n,r,o){const s=e.inputParams[t];if(s&&void 0!==s.inputIndexStart){const t=s.inputIndexStart,a=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?t+1:s.inputIndexEnd;if("tensor"===s.type)return E(e.inputNames[s.inputIndexStart],n,r,o);if("tensors"===s.type)return e.inputNames.slice(t,a).map((t=>E(t,n,r,o)));const i=E(e.inputNames.slice(t)[0],n,r,o),u=i.dataSync();return"number"===s.type?u[0]:$.D5U.GX(i.shape,u)}const a=e.attrParams[t];return a&&a.value}function E(t,e,n,r){const[o,s]=S(t);if(null!=r){const t=r.getHashTableHandleByName(o);if(null!=t)return t}const a=n.currentContextIds.find((t=>!!e[k(o,t)]));return void 0!==a?e[k(o,a)][s]:void 0}function T(t,e){const[n,r]=S(t);return[k(n,e&&e.currentContextId),r]}function k(t,e){return e?`${t}-${e}`:t}function S(t){const e=t.split(":");return 1===e.length?[t,0]:[e[0],Number(e[e.length-1])]}function R(t,e,n){let r=I("pad",t,e,n);if("explicit"===r){r=I("explicitPaddings",t,e,n);const o=[[0,0],[0,0],[0,0],[0,0]];for(let t=0;t<4;t++)o[t][0]=r[2*t],o[t][1]=r[2*t+1];return o}return r}function _(t){return t.kept?t:(0,$.d9v)(t)}const A=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],D=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"clip_value_min",name:"clipValueMin",type:"number"},{tfName:"clip_value_max",name:"clipValueMax",type:"number"}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"clipValueMin",name:"clipValueMin",type:"number",defaultValue:0},{tfName:"clipValueMax",name:"clipValueMax",type:"number",defaultValue:6}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],O=[{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],F=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],B=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],P=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],M=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],L=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],V=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]}],W=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],U=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],z=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],G=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],X=[{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],H=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool",notSupported:!0}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],j=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],K=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}];class q{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[].concat(...[r,o,s,a,i,u,c,h,d,l,f,m,g,y,x,v,p].map((t=>t.json)));this.opMappers=t.reduce(((t,e)=>(t[e.tfOpName]=e,t)),{})}transformGraph(t,e={}){const n=t.node,r=[],o=[],s=[],a=n.reduce(((t,e)=>(t[e.name]=this.mapNode(e),e.op.startsWith("Placeholder")?r.push(t[e.name]):"Const"===e.op?o.push(t[e.name]):null!=e.input&&0!==e.input.length||s.push(t[e.name]),t)),{});let i=[];const u=[];let c={},l={};null!=e&&(c=this.mapSignatureEntries(e.inputs),l=this.mapSignatureEntries(e.outputs));const p=Object.keys(a);p.forEach((t=>{const e=a[t];e.inputNames.forEach((t=>{const[n]=T(t);e.inputs.push(a[n]),a[n].children.push(e)}))})),0===Object.keys(l).length?p.forEach((t=>{const e=a[t];0===e.children.length&&u.push(e)})):Object.keys(l).forEach((t=>{const[e]=T(t),n=a[e];null!=n&&(n.signatureKey=l[t],u.push(n))})),Object.keys(c).length>0?Object.keys(c).forEach((t=>{const[e]=T(t),n=a[e];n&&(n.signatureKey=c[t],i.push(n))})):i=r;let d={};null!=t.library&&null!=t.library.function&&(d=t.library.function.reduce(((t,e)=>(t[e.signature.name]=this.mapFunction(e),t)),{}));const h={nodes:a,inputs:i,outputs:u,weights:o,placeholders:r,signature:e,functions:d};return s.length>0&&(h.initNodes=s),h}mapSignatureEntries(t){return Object.keys(t||{}).reduce(((e,n)=>(e[t[n].name]=n,e)),{})}mapNode(t){const e=N(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const n={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map((t=>t.startsWith("^")?t.substr(1):t)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr};return null!=e.inputs&&(n.inputParams=e.inputs.reduce(((t,e)=>(t[e.name]={type:e.type,inputIndexStart:e.start,inputIndexEnd:e.end},t)),{})),null!=e.attrs&&(n.attrParams=e.attrs.reduce(((e,n)=>{const r=n.type;let o;switch(n.type){case"string":o=Q(t.attr,n.tfName,n.defaultValue),void 0===o&&n.tfDeprecatedName&&(o=Q(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":o=it(t.attr,n.tfName,n.defaultValue),void 0===o&&n.tfDeprecatedName&&(o=it(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":o=J(t.attr,n.tfName,n.defaultValue||0),void 0===o&&n.tfDeprecatedName&&(o=J(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":o=at(t.attr,n.tfName,n.defaultValue),void 0===o&&n.tfDeprecatedName&&(o=at(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":o=Z(t.attr,n.tfName,n.defaultValue),void 0===o&&n.tfDeprecatedName&&(o=Z(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":o=ct(t.attr,n.tfName,n.defaultValue),void 0===o&&n.tfDeprecatedName&&(o=ct(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":o=st(t.attr,n.tfName,n.defaultValue),void 0===o&&n.tfDeprecatedName&&(o=st(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":o=ut(t.attr,n.tfName,n.defaultValue),void 0===o&&n.tfDeprecatedName&&(o=ut(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":o=nt(t.attr,n.tfName,n.defaultValue),void 0===o&&n.tfDeprecatedName&&(o=nt(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":o=rt(t.attr,n.tfName,n.defaultValue),void 0===o&&n.tfDeprecatedName&&(o=rt(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":o=et(t.attr,n.tfName,n.defaultValue),void 0===o&&n.tfDeprecatedName&&(o=et(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${t.op}`)}return e[n.name]={value:o,type:r},e}),{})),n}mapFunction(t){const e=t.nodeDef,n=[];let r={};null!=e&&(r=e.reduce(((t,e)=>(t[e.name]=this.mapNode(e),"Const"===e.op&&n.push(t[e.name]),t)),{}));const o=[],s=[];t.signature.inputArg.forEach((t=>{const[e]=T(t.name),n={name:e,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:tt(t.type),type:"dtype"}},children:[]};n.signatureKey=t.name,o.push(n),r[e]=n})),Object.keys(r).forEach((t=>{const e=r[t];e.inputNames.forEach((t=>{const[n]=T(t);e.inputs.push(r[n]),r[n].children.push(e)}))}));const a=t.ret;t.signature.outputArg.forEach((t=>{const[e,n]=T(a[t.name]),o=r[e];null!=o&&(o.defaultOutput=n,s.push(o))}));const i=this.mapArgsToSignature(t);return{nodes:r,inputs:o,outputs:s,weights:n,placeholders:[],signature:i}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce(((t,e)=>(t[e.name]=this.mapArgToTensorInfo(e),t)),{}),outputs:t.signature.outputArg.reduce(((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n,t.ret),e)),{})}}mapArgToTensorInfo(t,e){let n=t.name;return null!=e&&(n=e[n]),{name:n,dtype:t.type}}}function Y(t,e){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):function(t){const e=(0,$.OBj)().global;if(void 0!==e.atob)return e.atob(t);if("undefined"!=typeof Buffer)return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(t);return e?n:n.toLowerCase()}function Q(t,e,n,r=!1){const o=t[e];return null!=o?Y(o.s,r):n}function Z(t,e,n){const r=t[e];return r?r.b:n}function J(t,e,n){const r=t[e]||{},o=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof o?o:parseInt(o,10)}function tt(t){switch("string"==typeof t&&(t=b[t]),t){case b.DT_FLOAT:return"float32";case b.DT_INT32:case b.DT_INT64:case b.DT_INT8:case b.DT_UINT8:return"int32";case b.DT_BOOL:return"bool";case b.DT_DOUBLE:return"float32";case b.DT_STRING:return"string";default:return null}}function et(t,e,n){const r=t[e];return r&&r.func?r.func.name:n}function nt(t,e,n){const r=t[e];return r&&r.type?tt(r.type):n}function rt(t,e,n){const r=t[e];return r&&r.list&&r.list.type?r.list.type.map((t=>tt(t))):n}function ot(t){if(!t.unknownRank)return null!=t.dim?t.dim.map((t=>"number"==typeof t.size?t.size:parseInt(t.size,10))):[]}function st(t,e,n){const r=t[e];return r&&r.shape?ot(r.shape):n}function at(t,e,n){const r=t[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((t=>"number"==typeof t?t:parseInt(t,10))):n}function it(t,e,n,r=!1){const o=t[e];return o&&o.list&&o.list.s?o.list.s.map((t=>Y(t,r))):n}function ut(t,e,n){const r=t[e];return r&&r.list&&r.list.shape?r.list.shape.map((t=>ot(t))):n}function ct(t,e,n){const r=t[e];return r&&r.list&&r.list.b?r.list.b:n}class lt{constructor(t,e,n){this.node=t,this.tensorMap=e,this.context=n,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map((t=>this.getInput(t))),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce(((t,e)=>(t[e]=this.getAttr(e),t)),{}))}getInput(t){return E(t,this.tensorMap,this.context)}getAttr(t,e){const n=this.node.rawAttrs[t];if(null!=n.tensor)return E(t,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return J(this.node.rawAttrs,t,e);if(null!=n.s)return Q(this.node.rawAttrs,t,e);if(null!=n.b)return Z(this.node.rawAttrs,t,e);if(null!=n.shape)return st(this.node.rawAttrs,t,e);if(null!=n.type)return nt(this.node.rawAttrs,t,e);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return at(this.node.rawAttrs,t,e);if(null!=n.list.s)return it(this.node.rawAttrs,t,e);if(null!=n.list.shape)return ut(this.node.rawAttrs,t,e);if(null!=n.list.b)return ct(this.node.rawAttrs,t,e);if(null!=n.list.type)return rt(this.node.rawAttrs,t,e)}return e}}var pt=n(6407),dt=n(7097),ht=n(9121),ft=n(3740),mt=n(569),gt=n(2668);const yt=(0,gt.op)({addN_:function(t){mt.hu(Array.isArray(t),(()=>"The argument passed to tf.addN() must be a list of tensors")),mt.hu(t.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`));const e=t.map(((t,e)=>(0,ft._1)(t,`tensors${e}`,"addN"))),n=e[0];e.forEach((t=>{if(t.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),e.forEach((t=>{if(!mt.cO(t.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const r=e;return dt.BV.runKernelFunc(((t,n)=>{const r=t.addN(e);return n(e),r}),r,null,ht.Xz)}});var xt=n(5228),vt=n(4841),bt=n(1274),wt=n(9322),$t=n(9165),Ct=n(827),Nt=n(4513),It=n(632),Et=n(3453),Tt=n(5265),kt=n(6235),St=n(7839),Rt=n(1470),_t=n(2421),At=n(1891),Dt=n(7037),Ot=n(9812),Ft=n(369),Bt=n(6825),Pt=n(1661),Mt=n(173),Lt=n(2699),Vt=n(3233),Wt=n(4650),Ut=n(4842),zt=n(3426),Gt=n(6943),Xt=n(2597),Ht=n(7474),jt=n(4386),Kt=n(7370),qt=n(9036),Yt=n(766),Qt=n(7409),Zt=n(7809),Jt=n(5503),te=n(625),ee=n(9331),ne=n(4434),re=n(3254),oe=n(3694),se=n(3261),ae=n(248),ie=n(1869),ue=n(1173),ce=n(2279),le=n(2634),pe=n(9451),de=n(9133),he=n(8151);function fe(t,e,n=""){$.D5U.hu(function(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(-1!==t[n]&&-1!==e[n]&&t[n]!==e[n])return!1;return!0}(t,e),(()=>n+` Shapes ${t} and ${e} must match`))}class me{constructor(t,e,n,r,o,s,a){this.name=t,this.dtype=e,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=o,this.dynamicSize=s,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=(0,$.iD$)(0),(0,$.CnY)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach((e=>{null!=t&&t.has(e.tensor.id)||e.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map((t=>this.read(t)))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=e.shape),fe(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);n.tensor=e,(0,$.CnY)(e),n.written=!0,this.tensors[t]=n}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach(((t,n)=>this.write(t,e[n])))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let e=0;e<this.size();e++)t.push(e)}if(0===t.length)return(0,$.XeE)([],[0].concat(this.elementShape));const n=this.readMany(t);return fe(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),(0,$.knu)(n,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return(0,$.XeE)([],[0].concat(this.elementShape));const e=[];for(let t=0;t<this.size();t++)e.push(t);const n=this.readMany(e);return fe(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),(0,$.zoF)(n,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const n=Math.max(...t);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(t,(0,$.HHK)(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let n=0;const r=t.map((t=>(n+=t,n)));if(n!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const o=0===n?0:e.size/n,s=[];(0,$.lub)((()=>{e=(0,$.XLQ)(e,[1,n,o]);for(let n=0;n<t.length;++n){const a=[0,0===n?0:r[n-1],0],i=[1,t[n],o];s[n]=(0,$.XLQ)((0,$.tPi)(e,a,i),this.elementShape)}return s}));const a=[];for(let e=0;e<t.length;e++)a[e]=e;this.writeMany(a,s)}}class ge{constructor(t,e,n,r=-1){this.tensors=t,this.elementShape=e,this.elementDtype=n,null!=t&&t.forEach((t=>{if(n!==t.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${t.dtype}`);fe(e,t.shape,"TensorList shape mismatch: "),(0,$.CnY)(t)})),this.idTensor=(0,$.iD$)(0),this.maxNumElements=r,(0,$.CnY)(this.idTensor)}get id(){return this.idTensor.id}copy(){return new ge([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach((e=>{null!=t&&t.has(e.id)||e.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,n=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);return fe(t,this.elementShape,"TensorList shape mismatch: "),(0,$.lub)((()=>{const e=this.tensors.map((e=>(0,$.XLQ)(e,t)));return(0,$.knu)(e,0)}))}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=this.tensors.pop();return fe(n.shape,t,"TensorList shape mismatch: "),(0,$.XLQ)(n,t)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(fe(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");(0,$.CnY)(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=t}getItem(t,e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);return fe(this.tensors[t].shape,e,"TensorList shape mismatch: "),this.tensors[t]}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);fe(this.elementShape,e.shape,"TensorList shape mismatch: "),(0,$.CnY)(e),this.tensors[t]=e}gather(t,e,n){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);return fe(this.elementShape,n,"TensorList shape mismatch: "),0===(t=t.slice(0,this.size())).length?(0,$.XeE)([],[0].concat(this.elementShape)):(0,$.lub)((()=>{const e=t.map((t=>(0,$.XLQ)(this.tensors[t],n)));return(0,$.knu)(e,0)}))}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);return fe(this.elementShape,e,"TensorList shape mismatch: "),0===this.size()?(0,$.XeE)([],[0].concat(this.elementShape)):(0,$.lub)((()=>{const t=this.tensors.map((t=>(0,$.XLQ)(t,e)));return(0,$.zoF)(t,0)}))}}var ye=n(1355),xe=n(4794),ve=n(633),be=n(747),we=n(2200),$e=n(6013),Ce=n(9832),Ne=n(2582),Ie=n(9323),Ee=n(4968);const Te=(0,gt.op)({fusedConv2d_:function({x:t,filter:e,strides:n,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:i,activation:u="linear",preluActivationWeights:c}){if(u=u||"linear",!1===(0,Ie.uy)(dt.BV.state.gradientDepth,u)){let l=(0,xe.T)(t,e,n,r,o,s,a);return null!=i&&(l=(0,pt.I)(l,i)),(0,Ie.QH)(l,u,c)}const l=(0,ft._1)(t,"x","conv2d"),p=(0,ft._1)(e,"filter","conv2d");let d=l,h=!1;3===l.rank&&(h=!0,d=(0,Ee.X)(l,[1,l.shape[0],l.shape[1],l.shape[2]])),mt.hu(4===d.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`)),mt.hu(4===p.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`)),null!=a&&mt.hu(mt.GN(r),(()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`)),mt.hu(d.shape[3]===p.shape[2],(()=>`Error in conv2d: depth of input (${d.shape[3]}) must match input depth for filter ${p.shape[2]}.`)),mt.hu(Ne.jT(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),mt.hu("NHWC"===o,(()=>`Error in conv2d: got dataFormat of ${o} but only NHWC is currently supported.`));const f=Ne.Ix(d.shape,p.shape,n,s,r,a);let m,g;null!=i&&(m=(0,ft._1)(i,"bias","fused conv2d"),[m]=(0,be.T_)(m,l),we.$N(f.outShape,m.shape)),null!=c&&(g=(0,ft._1)(c,"prelu weights","fused conv2d"));const y=(t,e)=>{const[o,a,i,c]=e,l=(0,Ie.Fr)(t,i,u);mt.hu(Ne.I0(s),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`));const p=[(0,Ce._)(a.shape,l,o,n,r),(0,$e.p)(a,l,o.shape,n,r)];if(null!=c){const t=(0,Ie.pf)(c,l);p.push(t)}return p},x=t=>t.fusedConv2d({input:d,filter:p,convInfo:f,bias:m,activation:u,preluActivationWeights:g}),v={x:d,filter:p,bias:m,preluActivationWeights:g},b={strides:n,pad:r,dataFormat:o,dilations:s,dimRoundingMode:a,activation:u};return null==i?(0,ve.cb)(((t,e,n)=>{let r=dt.BV.runKernelFunc(x,v,null,ht._V,b);return n([e,t,r]),h&&(r=(0,Ee.X)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}}))(d,p):(0,ve.cb)(((t,e,n,r)=>{let o=dt.BV.runKernelFunc(x,v,null,ht._V,b);return r([e,t,o,n]),h&&(o=(0,Ee.X)(o,[o.shape[1],o.shape[2],o.shape[3]])),{value:o,gradFunc:y}}))(d,p,m)}});var ke=n(4718),Se=n(8098),Re=n(4375);const _e=(0,gt.op)({fusedDepthwiseConv2d_:function({x:t,filter:e,strides:n,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:i,activation:u="linear",preluActivationWeights:c}){if(!1===(0,Ie.uy)(dt.BV.state.gradientDepth,u)){let l=(0,ke.B)(t,e,n,r,o,s,a);return null!=i&&(l=(0,pt.I)(l,i)),(0,Ie.QH)(l,u,c)}const l=(0,ft._1)(t,"x","depthwiseConv2d"),p=(0,ft._1)(e,"filter","depthwiseConv2d");let d=l,h=!1;3===l.rank&&(h=!0,d=(0,Ee.X)(l,[1,l.shape[0],l.shape[1],l.shape[2]])),mt.hu(4===d.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`)),mt.hu(4===p.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`)),mt.hu(d.shape[3]===p.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`)),null==s&&(s=[1,1]),mt.hu(Ne.jT(n,s),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),null!=a&&mt.hu(mt.GN(r),(()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${a} but got pad ${r}.`));const f=Ne.Ix(d.shape,p.shape,n,s,r,a,!0);let m,g;null!=i&&(m=(0,ft._1)(i,"bias","fused conv2d"),[m]=(0,be.T_)(m,l),we.$N(f.outShape,m.shape)),null!=c&&(g=(0,ft._1)(c,"prelu weights","fused depthwiseConv2d"));const y=(t,e)=>{mt.hu(Ne.I0(s),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`));const[o,i,c,l]=e,p=(0,Ie.Fr)(t,c,u),d=(0,Re.v)(i.shape,p,o,n,r,s,a),h=(0,Se.z)(i,p,o.shape,n,r,s,a);return null!=l?[d,h,(0,Ie.pf)(m,p)]:[d,h]},x=t=>t.fusedDepthwiseConv2D({input:d,filter:p,convInfo:f,bias:m,activation:u,preluActivationWeights:g}),v={x:d,filter:p,bias:m,preluActivationWeights:g},b={strides:n,pad:r,dataFormat:o,dilations:s,dimRoundingMode:a,activation:u};return null==i?(0,ve.cb)(((t,e,n)=>{let r=dt.BV.runKernelFunc(x,v,null,ht.lu,b);return n([e,t,r]),h&&(r=(0,Ee.X)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}}))(d,p):(0,ve.cb)(((t,e,n,r)=>{let o=dt.BV.runKernelFunc(x,v,null,ht.lu,b);return r([e,t,o,n]),h&&(o=(0,Ee.X)(o,[o.shape[1],o.shape[2],o.shape[3]])),{value:o,gradFunc:y}}))(d,p,m)}});var Ae=n(8687);const De=(0,gt.op)({fusedMatMul_:function({a:t,b:e,transposeA:n=!1,transposeB:r=!1,bias:o,activation:s="linear",preluActivationWeights:a}){if(!1===(0,Ie.uy)(dt.BV.state.gradientDepth,s)){let i=(0,Ae.O)(t,e,n,r);return null!=o&&(i=(0,pt.I)(i,o)),(0,Ie.QH)(i,s,a)}let i=(0,ft._1)(t,"a","fused matMul"),u=(0,ft._1)(e,"b","fused matMul");[i,u]=(0,be.T_)(i,u);const c=n?i.shape[i.rank-2]:i.shape[i.rank-1],l=r?u.shape[u.rank-1]:u.shape[u.rank-2],p=n?i.shape[i.rank-1]:i.shape[i.rank-2],d=r?u.shape[u.rank-2]:u.shape[u.rank-1],h=i.shape.slice(0,-2),f=u.shape.slice(0,-2),m=mt.NA(h),g=mt.NA(f);mt.hu(i.rank>=2&&u.rank>=2&&i.rank===u.rank,(()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${i.rank} and ${u.rank}.`)),mt.hu(mt.cO(h,f),(()=>`Error in fused matMul: outer dimensions (${h}) and (${f}) of Tensors with shapes ${i.shape} and ${u.shape} must match.`)),mt.hu(c===l,(()=>`Error in fused matMul: inner shapes (${c}) and (${l}) of Tensors with shapes ${i.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`));const y=i.shape.slice(0,-2).concat([p,d]),x=n?(0,Ee.X)(i,[m,c,p]):(0,Ee.X)(i,[m,p,c]),v=r?(0,Ee.X)(u,[g,d,l]):(0,Ee.X)(u,[g,l,d]);let b,w;null!=o&&(b=(0,ft._1)(o,"bias","fused matMul"),[b]=(0,be.T_)(b,i),we.$N(y,b.shape)),null!=a&&(w=(0,ft._1)(a,"prelu weights","fused matMul"));const $=(t,e)=>{const[a,i,u,c]=e,l=(0,Ie.Fr)((0,Ee.X)(t,u.shape),u,s);let p,d;return n||r?!n&&r?(p=(0,Ae.O)(l,i,!1,!1),d=(0,Ae.O)(l,a,!0,!1)):n&&!r?(p=(0,Ae.O)(i,l,!1,!0),d=(0,Ae.O)(a,l,!1,!1)):(p=(0,Ae.O)(i,l,!0,!0),d=(0,Ae.O)(l,a,!0,!0)):(p=(0,Ae.O)(l,i,!1,!0),d=(0,Ae.O)(a,l,!0,!1)),null!=o?[p,d,(0,Ie.pf)(c,l)]:[p,d]},C=t=>t.fusedBatchMatMul({a:x,b:v,transposeA:n,transposeB:r,bias:b,activation:s,preluActivationWeights:w}),N={a:x,b:v,bias:b,preluActivationWeights:w},I={transposeA:n,transposeB:r,activation:s};return null==o?(0,ve.cb)(((t,e,n)=>{const r=dt.BV.runKernelFunc(C,N,null,ht.us,I);return n([t,e,r]),{value:(0,Ee.X)(r,y),gradFunc:$}}))(x,v):(0,ve.cb)(((t,e,n,r)=>{const o=dt.BV.runKernelFunc(C,N,null,ht.us,I);return r([t,e,o,n]),{value:(0,Ee.X)(o,y),gradFunc:$}}))(x,v,b)}});var Oe=n(1405);const Fe=(0,gt.op)({conv3d_:function(t,e,n,r,o="NDHWC",s=[1,1,1]){const a=(0,ft._1)(t,"x","conv3d"),i=(0,ft._1)(e,"filter","conv3d");let u=a,c=!1;4===a.rank&&(c=!0,u=(0,Ee.X)(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),mt.hu(5===u.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`)),mt.hu(5===i.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`)),mt.hu(u.shape[4]===i.shape[3],(()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`)),mt.hu((0,Ne.jT)(n,s),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),mt.hu("NDHWC"===o,(()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`));const l={x:u,filter:i},p={strides:n,pad:r,dataFormat:o,dilations:s},d=dt.BV.runKernelFunc(((t,e)=>{const o=Ne.jw(u.shape,i.shape,n,s,r),a=t.conv3d(u,i,o);return e([u,i]),a}),l,null,ht.x1,p);return c?(0,Ee.X)(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});var Be=n(5176),Pe=n(1174);const Me=(0,gt.op)({maxPoolWithArgmax_:function(t,e,n,r,o=!1){const s={x:(0,ft._1)(t,"x","maxPoolWithArgmax")},a={filterSize:e,strides:n,pad:r,includeBatchInIndex:o},i=dt.BV.runKernel(ht.vF,s,a);return{result:i[0],indexes:i[1]}}});var Le=n(4368),Ve=n(2271);const We=(0,gt.op)({avgPool3d_:function(t,e,n,r,o,s="NDHWC",a){null==a?a=[1,1,1]:(0,Le.MX)("dilations is deprecated, this field will be gone in v3.0.0.");const i=(0,ft._1)(t,"x","avgPool3d","float32");let u=i,c=!1;4===i.rank&&(c=!0,u=(0,Ee.X)(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),mt.hu(5===u.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${u.rank}.`)),mt.hu("NDHWC"===s,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),mt.hu(Ne.jT(n,a),(()=>`Error in avgPool3d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),null!=o&&mt.hu(mt.GN(r),(()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`));const l={x:u},p={filterSize:e,strides:n,pad:r,dimRoundingMode:o,dataFormat:s,dilations:a};let d=dt.BV.runKernelFunc(((t,i)=>{null==a&&(a=[1,1,1]);const c=Ne.pl(u.shape,e,n,a,r,o,s);return i([u]),t.avgPool3d(u,c)}),l,null,ht._k,p);return d=(0,Ve.p)(d,u.dtype),c?(0,Ee.X)(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Ue=(0,gt.op)({maxPool3d_:function(t,e=[1,1,1],n,r,o,s="NDHWC",a){null==a?a=[1,1,1]:(0,Le.MX)("dilations is deprecated, this field will be gone in v3.0.0.");const i=(0,ft._1)(t,"x","maxPool3d");let u=i,c=!1;4===i.rank&&(c=!0,u=(0,Ee.X)(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),mt.hu(5===u.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${u.rank}.`)),mt.hu("NDHWC"===s,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),mt.hu(Ne.jT(n,a),(()=>`Error in maxPool3d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),null!=o&&mt.hu(mt.GN(r),(()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`));const l={x:u},p={filterSize:e,strides:n,pad:r,dimRoundingMode:o,dataFormat:s,dilations:a},d=dt.BV.runKernelFunc(((t,i)=>{null==a&&(a=[1,1,1]);const c=Ne.pl(u.shape,e,n,a,r,o,s),l=t.maxPool3d(u,c);return i([u,l]),l}),l,null,ht.OA,p);return c?(0,Ee.X)(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});var ze=n(557);function Ge(t,e,n){const[r,o]=I("fusedOps",t,e,n),s="biasadd"===r,a="prelu"===o,i="fusedbatchnorm"===r,u=I("numArgs",t,e,n);if(s){if(a&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(i)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");const c=I("strides",t,e,n),l=R(t,e,n),p=I("dataFormat",t,e,n).toUpperCase(),d=I("dilations",t,e,n),[h,f]=I("args",t,e,n);return{stride:c,pad:l,dataFormat:p,dilations:d,biasArg:h,preluArg:f,activationFunc:o}}var Xe=n(4006);function He(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:t,stop:e,num:n};return dt.BV.runKernelFunc((r=>r.linspace(t,e,n)),{},null,ht.e7,r)}const je=(0,gt.op)({multinomial_:function(t,e,n,r=!1){const o=(0,ft._1)(t,"logits","multinomial"),s=o.size,a=o.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);n=n||Math.random();const i=1===a?(0,Ee.X)(o,[1,-1]):o,u=dt.BV.runKernelFunc((t=>t.multinomial(i,r,e,n)),{logits2D:i});return 1===a?(0,Ee.X)(u,[u.size]):u}});var Ke=n(6708),qe=n(4917),Ye=n(7846),Qe=n(2657),Ze=n(6377);class Je{constructor(t,e,n,r,o){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=o||Math.random();this.random=Ze.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let r,o,s;do{r=2*this.random()-1,o=2*this.random()-1,s=r*r+o*o}while(s>=1||0===s);const a=Math.sqrt(-2*Math.log(s)/s);t=this.mean+this.stdDev*r*a,e=this.mean+this.stdDev*o*a,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class tn{constructor(t=0,e=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=Ze.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const en=(0,gt.op)({randomUniform_:function(t,e=0,n=1,r="float32",o){const s=(0,Qe.f)(t,r),a=new tn(e,n,null,o);for(let t=0;t<s.values.length;t++)s.values[t]=a.nextValue();return s.toTensor()}});var nn=n(7245);const rn=(0,gt.op)({truncatedNormal_:function(t,e=0,n=1,r,o){if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const s=new Je(e,n,r,!0,o),a=(0,Qe.f)(t,r);for(let t=0;t<a.values.length;t++)a.values[t]=s.nextValue();return a.toTensor()}});var on=n(9640),sn=n(6577),an=n(5410),un=n(8333);const cn=async function(t){const e=(0,ft._1)(t,"condition","whereAsync","bool"),n=await e.data(),r=(0,un.Z)(e.shape,n);return t!==e&&e.dispose(),r};var ln=n(4077);function pn(t,e,n){return{boxes:I("boxes",t,e,n),scores:I("scores",t,e,n),maxOutputSize:I("maxOutputSize",t,e,n),iouThreshold:I("iouThreshold",t,e,n),scoreThreshold:I("scoreThreshold",t,e,n),softNmsSigma:I("softNmsSigma",t,e,n)}}var dn=n(3243),hn=n(9608),fn=n(6092),mn=n(9494);class gn{constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=(0,$.iD$)(0),this.tensorMap=new Map,(0,$.CnY)(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach((t=>t.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}async import(t,e){this.checkKeyAndValueTensor(t,e);const n=await t.data();return this.tensorMap.forEach((t=>t.dispose())),this.tensorMap.clear(),(0,$.lub)((()=>{const t=(0,$.HHK)(e),r=n.length,o=t.length;$.D5U.hu(r===o,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${o} elements.`));for(let e=0;e<r;e++){const r=n[e],o=t[e];(0,$.CnY)(o),this.tensorMap.set(r,o)}return this.handle}))}async find(t,e){this.checkKeyAndValueTensor(t,e);const n=await t.data();return(0,$.lub)((()=>{const t=[];for(let r=0;r<n.length;r++){const o=n[r],s=this.findWithDefault(o,e);t.push(s)}return(0,$.knu)(t)}))}findWithDefault(t,e){const n=this.tensorMap.get(t);return null!=n?n:e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}var yn=n(6477),xn=n(6500),vn=n(636),bn=n(7630),wn=n(6573),$n=n(624),Cn=n(2856),Nn=n(8651),In=n(5750),En=n(5912),Tn=n(9065),kn=n(7505),Sn=n(9648),Rn=n(682),_n=n(1510);const An=(0,gt.op)({sparseToDense_:function(t,e,n,r=0){const o=(0,ft._1)(t,"sparseIndices","sparseToDense","int32"),s=(0,ft._1)(e,"sparseValues","sparseToDense"),a=(0,ft._1)(r,"defaultValue","sparseToDense",s.dtype);!function(t,e,n,r){if("int32"!==t.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const o=t.rank>0?t.shape[0]:1,s=t.rank>1?t.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);const a=e.size;if(0!==e.rank&&(1!==e.rank||a!==o))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${o}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(o,s,n,a);const i={sparseIndices:o,sparseValues:s,defaultValue:a},u={outputShape:n};return dt.BV.runKernelFunc((t=>t.sparseToDense(o,s,n,a)),i,null,ht.D2,u)}});var Dn=n(3307),On=n(5130),Fn=n(5735),Bn=n(5475),Pn=n(781),Mn=n(2998),Ln=n(47),Vn=n(7394),Wn=n(7405),Un=n(6884),zn=n(4926),Gn=n(7486),Xn=n(2676),Hn=n(5158),jn=n(9590),Kn=n(2991),qn=n(4136),Yn=n(7501),Qn=n(8644),Zn=n(3028);const Jn=(0,gt.op)({scatterND_:function(t,e,n){const r=(0,ft._1)(t,"indices","scatterND","int32"),o=(0,ft._1)(e,"updates","scatterND");Zn.b0(o,r,n);const s={indices:r,updates:o},a={shape:n};return dt.BV.runKernelFunc((t=>t.scatterND(r,o,n)),s,null,ht.xQ,a)}}),tr=(0,gt.op)({gatherND_:function(t,e){const n=(0,ft._1)(e,"indices","gatherND","int32"),r=(0,ft._1)(t,"x","gatherND"),o={params:r,indices:n};return dt.BV.runKernelFunc((t=>t.gatherND(r,n)),o,null,ht.q1)}});var er=n(7020),nr=n(8447),rr=n(3710),or=n(4415),sr=n(1300),ar=n(1483),ir=n(9682),ur=n(7918),cr=n(8441),lr=n(9112),pr=n(8247);function dr(t,e,n,r){const o=((t,e,n)=>{switch(t.category){case"arithmetic":return $.lub((()=>((t,e,n)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[pt.I(I("a",t,e,n),I("b",t,e,n))];case"AddN":return[yt(I("tensors",t,e,n))];case"FloorMod":case"Mod":return[xt.w(I("a",t,e,n),I("b",t,e,n))];case"Mul":return[vt.d(I("a",t,e,n),I("b",t,e,n))];case"RealDiv":case"Div":return[bt.h(I("a",t,e,n),I("b",t,e,n))];case"DivNoNan":return[wt.N(I("a",t,e,n),I("b",t,e,n))];case"FloorDiv":return[$t.q(I("a",t,e,n),I("b",t,e,n))];case"Sub":return[Ct.l(I("a",t,e,n),I("b",t,e,n))];case"Minimum":return[Nt.L(I("a",t,e,n),I("b",t,e,n))];case"Maximum":return[It.g(I("a",t,e,n),I("b",t,e,n))];case"Pow":return[Et.s(I("a",t,e,n),I("b",t,e,n))];case"SquaredDifference":return[Tt.$(I("a",t,e,n),I("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"basic_math":return $.lub((()=>((t,e,n)=>{switch(t.op){case"Abs":case"ComplexAbs":return[kt.W(I("x",t,e,n))];case"Acos":return[St.K(I("x",t,e,n))];case"Acosh":return[Rt._(I("x",t,e,n))];case"Asin":return[_t.Z(I("x",t,e,n))];case"Asinh":return[At.V(I("x",t,e,n))];case"Atan":return[Dt.z(I("x",t,e,n))];case"Atan2":return[Ot.f(I("x",t,e,n),I("y",t,e,n))];case"Atanh":return[Ft.C(I("x",t,e,n))];case"Ceil":return[Bt.m(I("x",t,e,n))];case"Complex":return[Pt.P(I("real",t,e,n),I("imag",t,e,n))];case"Cos":return[Mt.m(I("x",t,e,n))];case"Cosh":return[Lt.f(I("x",t,e,n))];case"Elu":return[Vt.p(I("x",t,e,n))];case"Erf":return[Wt.q(I("x",t,e,n))];case"Exp":return[Ut.Q(I("x",t,e,n))];case"Expm1":return[zt.t(I("x",t,e,n))];case"Floor":return[Gt.G(I("x",t,e,n))];case"Log":return[Xt.c(I("x",t,e,n))];case"Log1p":return[Ht.K(I("x",t,e,n))];case"Imag":return[jt.a(I("x",t,e,n))];case"Neg":return[Kt.W(I("x",t,e,n))];case"Reciprocal":return[qt.M(I("x",t,e,n))];case"Real":return[Yt.k(I("x",t,e,n))];case"Relu":return[Qt.U(I("x",t,e,n))];case"Round":return[Zt.N(I("x",t,e,n))];case"Selu":return[Jt.U(I("x",t,e,n))];case"Sigmoid":return[te.X(I("x",t,e,n))];case"Sin":return[ee.O(I("x",t,e,n))];case"Sign":return[ne.X(I("x",t,e,n))];case"Sinh":return[re.R(I("x",t,e,n))];case"Softplus":return[oe.W(I("x",t,e,n))];case"Sqrt":return[se._(I("x",t,e,n))];case"Square":return[ae.h(I("x",t,e,n))];case"Tanh":return[ie.A(I("x",t,e,n))];case"Tan":return[ue.O(I("x",t,e,n))];case"Relu6":case"ClipByValue":return[ce.i(I("x",t,e,n),I("clipValueMin",t,e,n),I("clipValueMax",t,e,n))];case"Rsqrt":return[le.b(E(t.inputNames[0],e,n))];case"Prod":return[pe.W(I("x",t,e,n),I("axes",t,e,n))];case"LeakyRelu":return[de.h(I("x",t,e,n),I("alpha",t,e,n))];case"Prelu":return[he.A(I("x",t,e,n),I("alpha",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"control":return(async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{const r=I("thenBranch",t,e,n),o=I("elseBranch",t,e,n),s=I("cond",t,e,n),a=I("args",t,e,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap):n.functionMap[o].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=I("body",t,e,n),o=I("cond",t,e,n),s=I("args",t,e,n),a=await n.functionMap[o].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),i=s.map((t=>t.id));let u=await a[0].data();a.forEach((t=>{t.kept||-1!==i.indexOf(t.id)||t.dispose()}));let c=s;for(;u[0];){const t=c;c=await n.functionMap[r].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);const e=c.map((t=>t.id));t.forEach((t=>{t.kept||-1!==i.indexOf(t.id)||-1!==e.indexOf(t.id)||t.dispose()}));const s=await n.functionMap[o].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);u=await s[0].data(),s.forEach((t=>{t.kept||-1!==i.indexOf(t.id)||-1!==e.indexOf(t.id)||t.dispose()}))}return c}case"LoopCond":return[_(I("pred",t,e,n))];case"Switch":{const r=I("pred",t,e,n);let o=I("data",t,e,n);return o.kept||(o=_(o)),(await r.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{const r=t.inputNames.find((t=>void 0!==E(t,e,n)));return r?[_(E(r,e,n))]:void 0}case"Enter":{const r=I("frameName",t,e,n),o=I("tensor",t,e,n);return n.enterFrame(r),[_(o)]}case"Exit":{const r=I("tensor",t,e,n);return n.exitFrame(),[_(r)]}case"NextIteration":{const r=I("tensor",t,e,n);return n.nextIteration(),[_(r)]}case"TensorArrayV3":{const r=I("size",t,e,n),o=I("dtype",t,e,n),s=I("elementShape",t,e,n),a=I("dynamicSize",t,e,n),i=I("clearAfterRead",t,e,n),u=I("identicalElementShapes",t,e,n),c=I("name",t,e,n),l=new me(c,o,r,s,u,a,i);return n.addTensorArray(l),[l.idTensor,(0,$.iD$)(1)]}case"TensorArrayWriteV3":{const r=I("tensorArrayId",t,e,n),o=I("index",t,e,n),s=I("tensor",t,e,n),a=n.getTensorArray(r.id);return a.write(o,s),[a.idTensor]}case"TensorArrayReadV3":{const r=I("tensorArrayId",t,e,n),o=I("index",t,e,n);return[n.getTensorArray(r.id).read(o)]}case"TensorArrayGatherV3":{const r=I("tensorArrayId",t,e,n),o=I("indices",t,e,n),s=I("dtype",t,e,n);return[n.getTensorArray(r.id).gather(o,s)]}case"TensorArrayScatterV3":{const r=I("tensorArrayId",t,e,n),o=I("indices",t,e,n),s=I("tensor",t,e,n),a=n.getTensorArray(r.id);return a.scatter(o,s),[a.idTensor]}case"TensorArrayConcatV3":{const r=I("tensorArrayId",t,e,n),o=n.getTensorArray(r.id),s=I("dtype",t,e,n);return[o.concat(s)]}case"TensorArraySplitV3":{const r=I("tensorArrayId",t,e,n),o=I("tensor",t,e,n),s=I("lengths",t,e,n),a=n.getTensorArray(r.id);return a.split(s,o),[a.idTensor]}case"TensorArraySizeV3":{const r=I("tensorArrayId",t,e,n),o=n.getTensorArray(r.id);return[(0,$.iD$)(o.size(),"int32")]}case"TensorArrayCloseV3":{const r=I("tensorArrayId",t,e,n),o=n.getTensorArray(r.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{const r=I("tensorListId",t,e,n),o=I("index",t,e,n),s=I("tensor",t,e,n),a=n.getTensorList(r.id);return a.setItem(o,s),[a.idTensor]}case"TensorListGetItem":{const r=I("tensorListId",t,e,n),o=I("index",t,e,n),s=I("elementShape",t,e,n),a=I("elementDType",t,e,n);return[n.getTensorList(r.id).getItem(o,s,a)]}case"TensorListScatterV2":case"TensorListScatter":{const r=I("indices",t,e,n),o=function(t,e,n,r){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const o=Math.max(...e);if(null!=r&&-1!==r&&o>=r)throw new Error(`Max index must be < array size (${o}  vs. ${r})`);const s=new ge([],n,t.dtype,r),a=(0,$.HHK)(t,0);return e.forEach(((t,e)=>{s.setItem(t,a[e])})),s}(I("tensor",t,e,n),r,I("elementShape",t,e,n),I("numElements",t,e,n));return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":{const a=(r=I("elementShape",t,e,n),o=I("elementDType",t,e,n),s=I("numElements",t,e,n),new ge([],r,o,s));return n.addTensorList(a),[a.idTensor]}case"TensorListGather":{const r=I("tensorListId",t,e,n),o=I("indices",t,e,n),s=I("elementShape",t,e,n),a=I("elementDType",t,e,n);return[n.getTensorList(r.id).gather(o,a,s)]}case"TensorListStack":{const r=I("tensorListId",t,e,n),o=I("elementShape",t,e,n),s=I("elementDType",t,e,n),a=I("numElements",t,e,n);return[n.getTensorList(r.id).stack(o,s,a)]}case"TensorListFromTensor":{const r=function(t,e,n){const r=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);fe(t.shape.slice(1),e,"TensorList shape mismatch: ");const o=(0,$.HHK)(t);return new ge(o,e,r)}(I("tensor",t,e,n),I("elementShape",t,e,n),I("elementDType",t,e,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":{const r=I("tensorListId",t,e,n),o=n.getTensorList(r.id),s=I("dtype",t,e,n),a=I("elementShape",t,e,n);return[o.concat(s,a)]}case"TensorListPushBack":{const r=I("tensorListId",t,e,n),o=I("tensor",t,e,n),s=n.getTensorList(r.id);return s.pushBack(o),[s.idTensor]}case"TensorListPopBack":{const r=I("tensorListId",t,e,n),o=I("elementShape",t,e,n),s=I("elementDType",t,e,n);return[n.getTensorList(r.id).popBack(o,s)]}case"TensorListSplit":{const r=I("tensor",t,e,n),o=I("elementShape",t,e,n),s=function(t,e,n){let r=0;const o=e.map((t=>(r+=t,r)));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${t.shape}`);const s=0===r?0:t.size/r,a=(0,$.lub)((()=>{const a=[];t=(0,$.XLQ)(t,[1,r,s]);for(let r=0;r<e.length;++r){const i=[0,0===r?0:o[r-1],0],u=[1,e[r],s];a[r]=(0,$.XLQ)((0,$.tPi)(t,i,u),n)}return t.dispose(),a})),i=new ge([],n,t.dtype,e.length);for(let t=0;t<a.length;t++)i.setItem(t,a[t]);return i}(r,I("lengths",t,e,n),o);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}var r,o,s})(t,e,n);case"convolution":return $.lub((()=>((t,e,n)=>{switch(t.op){case"Conv1D":{const r=I("stride",t,e,n),o=I("pad",t,e,n),s=I("dataFormat",t,e,n).toUpperCase(),a=I("dilation",t,e,n);return[ye.P(I("x",t,e,n),I("filter",t,e,n),r,o,s,a)]}case"Conv2D":{const r=I("strides",t,e,n),o=R(t,e,n),s=I("dataFormat",t,e,n).toUpperCase(),a=I("dilations",t,e,n);return[xe.T(I("x",t,e,n),I("filter",t,e,n),[r[1],r[2]],o,s,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:r,pad:o,dataFormat:s,dilations:a,biasArg:i,preluArg:u,activationFunc:c}=Ge(t,e,n);return[Te({x:I("x",t,e,n),filter:I("filter",t,e,n),strides:[r[1],r[2]],pad:o,dataFormat:s,dilations:[a[1],a[2]],bias:i,activation:c,preluActivationWeights:u})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:o,dataFormat:s,dilations:a,biasArg:i,preluArg:u,activationFunc:c}=Ge(t,e,n);return[_e({x:I("x",t,e,n),filter:I("filter",t,e,n),strides:[r[1],r[2]],pad:o,dataFormat:s,dilations:[a[1],a[2]],bias:i,activation:c,preluActivationWeights:u})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=I("outputShape",t,e,n),o=I("strides",t,e,n),s=R(t,e,n);return[Oe.b(I("x",t,e,n),I("filter",t,e,n),r,[o[1],o[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=I("strides",t,e,n),o=R(t,e,n),s=I("dilations",t,e,n),a=I("dataFormat",t,e,n).toUpperCase();return[ke.B(I("input",t,e,n),I("filter",t,e,n),[r[1],r[2]],o,a,[s[1],s[2]])]}case"Conv3D":{const r=I("strides",t,e,n),o=I("pad",t,e,n),s=I("dataFormat",t,e,n).toUpperCase(),a=I("dilations",t,e,n);return[Fe(I("x",t,e,n),I("filter",t,e,n),[r[1],r[2],r[3]],o,s,[a[1],a[2],a[3]])]}case"AvgPool":{const r=I("strides",t,e,n),o=I("pad",t,e,n),s=I("kernelSize",t,e,n);return[Be.w(I("x",t,e,n),[s[1],s[2]],[r[1],r[2]],o)]}case"MaxPool":{const r=I("strides",t,e,n),o=I("pad",t,e,n),s=I("kernelSize",t,e,n);return[Pe._(I("x",t,e,n),[s[1],s[2]],[r[1],r[2]],o)]}case"MaxPoolWithArgmax":{const r=I("strides",t,e,n),o=I("pad",t,e,n),s=I("kernelSize",t,e,n),a=I("includeBatchInIndex",t,e,n),{result:i,indexes:u}=Me(I("x",t,e,n),[s[1],s[2]],[r[1],r[2]],o,a);return[i,u]}case"AvgPool3D":{const r=I("strides",t,e,n),o=I("pad",t,e,n),s=I("kernelSize",t,e,n);return[We(I("x",t,e,n),[s[1],s[2],s[3]],[r[1],r[2],r[3]],o)]}case"MaxPool3D":{const r=I("strides",t,e,n),o=I("pad",t,e,n),s=I("kernelSize",t,e,n);return[Ue(I("x",t,e,n),[s[1],s[2],s[3]],[r[1],r[2],r[3]],o)]}case"Dilation2D":{const r=I("strides",t,e,n),o=I("pad",t,e,n),s=I("dilations",t,e,n),a=r[1],i=r[2],u=s[1],c=s[2];return[ze.W(I("x",t,e,n),I("filter",t,e,n),[a,i],o,[u,c],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"creation":return $.lub((()=>((t,e,n)=>{switch(t.op){case"Fill":{const r=I("shape",t,e,n),o=I("dtype",t,e,n),s=I("value",t,e,n);return[Xe.h(r,s,o)]}case"LinSpace":return[He(I("start",t,e,n),I("stop",t,e,n),I("num",t,e,n))];case"Multinomial":{const r=I("logits",t,e,n),o=I("numSamples",t,e,n),s=I("seed",t,e,n);return[je(r,o,s)]}case"OneHot":{const r=I("indices",t,e,n),o=I("depth",t,e,n),s=I("onValue",t,e,n),a=I("offValue",t,e,n);return[Ke.l(r,o,s,a)]}case"Ones":return[qe.i(I("shape",t,e,n),I("dtype",t,e,n))];case"OnesLike":return[Ye.J(I("x",t,e,n))];case"RandomUniform":return[en(I("shape",t,e,n),I("minval",t,e,n),I("maxval",t,e,n),I("dtype",t,e,n))];case"Range":{const r=I("start",t,e,n),o=I("stop",t,e,n),s=I("step",t,e,n);return[nn.w(r,o,s,I("dtype",t,e,n))]}case"TruncatedNormal":{const r=I("shape",t,e,n),o=I("mean",t,e,n),s=I("stdDev",t,e,n),a=I("seed",t,e,n);return[rn(r,o,s,I("dtype",t,e,n),a)]}case"Zeros":return[on.l(I("shape",t,e,n),I("dtype",t,e,n))];case"ZerosLike":return[sn.P(I("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"dynamic":return(async(t,e,n)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:o,maxOutputSize:s,iouThreshold:a,scoreThreshold:i,softNmsSigma:u}=pn(t,e,n),c=await an.BHj.nonMaxSuppressionWithScoreAsync(r,o,s,a,i,u);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:o,maxOutputSize:s,iouThreshold:a,scoreThreshold:i}=pn(t,e,n),u=I("padToMaxOutputSize",t,e,n),c=await an.BHj.nonMaxSuppressionPaddedAsync(r,o,s,a,i,u);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:o,maxOutputSize:s,iouThreshold:a,scoreThreshold:i}=pn(t,e,n);return[await an.BHj.nonMaxSuppressionAsync(r,o,s,a,i)]}case"Where":{const r=Ve.p(I("condition",t,e,n),"bool"),o=[await cn(r)];return r.dispose(),o}case"ListDiff":return async function(t,e){const n=(0,ft._1)(t,"x","setdiff1d"),r=(0,ft._1)(e,"y","setdiff1d");mt.hu(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),mt.hu(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),mt.hu(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));const o=await n.data(),s=await r.data(),a=new Set(s);let i=0;for(let t=0;t<o.length;t++)a.has(o[t])||i++;const u=new ln.YD([i],n.dtype),c=new ln.YD([i],"int32");for(let t=0,e=0;t<o.length;t++)a.has(o[t])||(u.values[e]=o[t],c.values[e]=t,e++);return[u.toTensor(),c.toTensor()]}(I("x",t,e,n),I("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n);case"evaluation":return $.lub((()=>((t,e,n)=>{switch(t.op){case"TopKV2":{const r=I("x",t,e,n),o=I("k",t,e,n),s=I("sorted",t,e,n),a=dn.h(r,o,s);return[a.values,a.indices]}case"Unique":{const r=I("x",t,e,n),o=hn.T(r);return[o.values,o.indices]}case"UniqueV2":{const r=I("x",t,e,n),o=I("axis",t,e,n),s=hn.T(r,o);return[s.values,s.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"image":return $.lub((()=>((t,e,n)=>{switch(t.op){case"ResizeBilinear":{const r=I("images",t,e,n),o=I("size",t,e,n),s=I("alignCorners",t,e,n);return[an.BHj.resizeBilinear(r,[o[0],o[1]],s)]}case"ResizeNearestNeighbor":{const r=I("images",t,e,n),o=I("size",t,e,n),s=I("alignCorners",t,e,n);return[an.BHj.resizeNearestNeighbor(r,[o[0],o[1]],s)]}case"CropAndResize":{const r=I("image",t,e,n),o=I("boxes",t,e,n),s=I("boxInd",t,e,n),a=I("cropSize",t,e,n),i=I("method",t,e,n),u=I("extrapolationValue",t,e,n);return[an.BHj.cropAndResize(r,o,s,a,i,u)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"graph":return $.lub((()=>((t,e,n)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const r=I("default",t,e,n);return[E(t.name,e,n)||r];case"Placeholder":return[E(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[_(I("x",t,e,n))];case"IdentityN":return I("x",t,e,n).map((t=>_(t)));case"Snapshot":return[_(I("x",t,e,n))];case"Shape":return[fn.R(I("x",t,e,n).shape,"int32")];case"ShapeN":return I("x",t,e,n).map((t=>fn.R(t.shape)));case"Size":return[mn.i(I("x",t,e,n).size,"int32")];case"Rank":return[mn.i(I("x",t,e,n).rank,"int32")];case"NoOp":return[mn.i(1)];case"Print":const o=I("x",t,e,n),s=I("data",t,e,n),a=I("message",t,e,n),i=I("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(a);for(let t=0;t<s.length;t++)console.log(Array.prototype.slice.call(s[t].dataSync()).slice(0,i));return[o];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"logical":return $.lub((()=>((t,e,n)=>{switch(t.op){case"Equal":return[yn.D(I("a",t,e,n),I("b",t,e,n))];case"NotEqual":return[xn.Q(I("a",t,e,n),I("b",t,e,n))];case"Greater":return[vn.p(I("a",t,e,n),I("b",t,e,n))];case"GreaterEqual":return[bn.b(I("a",t,e,n),I("b",t,e,n))];case"Less":return[wn.d(I("a",t,e,n),I("b",t,e,n))];case"LessEqual":return[$n.z(I("a",t,e,n),I("b",t,e,n))];case"LogicalAnd":return[Cn.H(I("a",t,e,n),I("b",t,e,n))];case"LogicalNot":return[Nn.h(I("a",t,e,n))];case"LogicalOr":return[In.K(I("a",t,e,n),I("b",t,e,n))];case"Select":case"SelectV2":return[En.a(I("condition",t,e,n),I("a",t,e,n),I("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"matrices":return $.lub((()=>((t,e,n)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Ae.O(I("a",t,e,n),I("b",t,e,n),I("transposeA",t,e,n),I("transposeB",t,e,n))];case"Transpose":return[Tn.p(I("x",t,e,n),I("perm",t,e,n))];case"_FusedMatMul":const[r,o]=I("fusedOps",t,e,n),s="biasadd"===r,a="prelu"===o,i=I("numArgs",t,e,n);if(s){if(a&&2!==i)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&1!==i)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,c]=I("args",t,e,n);return[De({a:I("a",t,e,n),b:I("b",t,e,n),transposeA:I("transposeA",t,e,n),transposeB:I("transposeB",t,e,n),bias:u,activation:o,preluActivationWeights:c})];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"normalization":return $.lub((()=>((t,e,n)=>{switch(t.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[kn.t(I("x",t,e,n),I("mean",t,e,n),I("variance",t,e,n),I("offset",t,e,n),I("scale",t,e,n),I("epsilon",t,e,n))];case"LRN":return[Sn.G(I("x",t,e,n),I("radius",t,e,n),I("bias",t,e,n),I("alpha",t,e,n),I("beta",t,e,n))];case"Softmax":return[Rn.X(I("x",t,e,n))];case"LogSoftmax":return[_n.C(I("x",t,e,n))];case"SparseToDense":return[An(I("sparseIndices",t,e,n),I("outputShape",t,e,n),I("sparseValues",t,e,n),I("defaultValue",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"reduction":return $.lub((()=>((t,e,n)=>{switch(t.op){case"Max":{const r=I("axis",t,e,n),o=I("keepDims",t,e,n);return[Dn.F(I("x",t,e,n),r,o)]}case"Mean":{const r=I("axis",t,e,n),o=I("keepDims",t,e,n);return[On.J(I("x",t,e,n),r,o)]}case"Min":{const r=I("axis",t,e,n),o=I("keepDims",t,e,n);return[Fn.V(I("x",t,e,n),r,o)]}case"Sum":{const r=I("axis",t,e,n),o=I("keepDims",t,e,n);return[Bn.S(I("x",t,e,n),r,o)]}case"All":{const r=I("axis",t,e,n),o=I("keepDims",t,e,n);return[Pn.$(I("x",t,e,n),r,o)]}case"Any":{const r=I("axis",t,e,n),o=I("keepDims",t,e,n);return[Mn.Y(I("x",t,e,n),r,o)]}case"ArgMax":{const r=I("axis",t,e,n);return[Ln.N(I("x",t,e,n),r)]}case"ArgMin":{const r=I("axis",t,e,n);return[Vn.v(I("x",t,e,n),r)]}case"Prod":{const r=I("axis",t,e,n),o=I("keepDims",t,e,n);return[pe.W(I("x",t,e,n),r,o)]}case"Cumsum":{const r=I("axis",t,e,n),o=I("exclusive",t,e,n),s=I("reverse",t,e,n);return[Wn.z(I("x",t,e,n),r,o,s)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"slice_join":return $.lub((()=>((t,e,n)=>{switch(t.op){case"ConcatV2":case"Concat":{const r=I("n",t,e,n),o=I("axis",t,e,n);let s=I("tensors",t,e,n);return s=s.slice(0,r),[Un.z(s,o)]}case"GatherV2":case"Gather":{const r=I("axis",t,e,n),o=I("x",t,e,n),s=I("indices",t,e,n);return[zn.I(o,Ve.p(s,"int32"),r)]}case"ReverseV2":case"Reverse":{const r=I("axis",t,e,n),o=I("x",t,e,n);return[Gn.G(o,r)]}case"Slice":{const r=I("begin",t,e,n),o=I("size",t,e,n);return[Xn.t(I("x",t,e,n),r,o)]}case"StridedSlice":{const r=I("begin",t,e,n),o=I("end",t,e,n),s=I("strides",t,e,n),a=I("beginMask",t,e,n),i=I("endMask",t,e,n),u=I("ellipsisMask",t,e,n),c=I("newAxisMask",t,e,n),l=I("shrinkAxisMask",t,e,n),p=I("x",t,e,n);return[Hn.N(p,r,o,s,a,i,u,c,l)]}case"Pack":return(0,$.lub)((()=>{const r=I("axis",t,e,n),o=I("tensors",t,e,n),s=o[0].shape,a=jn.L(o[0]).shape,i=o.map((t=>{const e=$.D5U.cO(t.shape,s);if(!e&&!$.D5U.cO(jn.L(t).shape,a))throw new Error("the input tensors shape does not match");return e?t:Ee.X(t,s)}));return[Kn.k(i,r)]}));case"Unpack":{const r=I("axis",t,e,n),o=I("tensor",t,e,n);return qn.H(o,r)}case"Tile":{const r=I("reps",t,e,n);return[Yn.G(I("x",t,e,n),r)]}case"Split":case"SplitV":{const r=I("axis",t,e,n),o=I("numOrSizeSplits",t,e,n),s=I("x",t,e,n);return Qn.V(s,o,r)}case"ScatterNd":{const r=I("indices",t,e,n),o=I("values",t,e,n),s=I("shape",t,e,n);return[Jn(r,o,s)]}case"GatherNd":{const r=I("x",t,e,n),o=I("indices",t,e,n);return[tr(r,o)]}case"SparseToDense":{const r=I("sparseIndices",t,e,n),o=I("outputShape",t,e,n),s=I("sparseValues",t,e,n),a=I("defaultValue",t,e,n);return[An(r,s,o,s.dtype===a.dtype?a:Ve.p(a,s.dtype))]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"spectral":return $.lub((()=>((t,e,n)=>{switch(t.op){case"FFT":return[er.k(I("x",t,e,n))];case"IFFT":return[nr.S(I("x",t,e,n))];case"RFFT":return[rr.Q(I("x",t,e,n))];case"IRFFT":return[or.w(I("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"transformation":return $.lub((()=>((t,e,n)=>{switch(t.op){case"Cast":return[Ve.p(I("x",t,e,n),I("dtype",t,e,n))];case"ExpandDims":{const r=I("axis",t,e,n);return[sr.d(I("x",t,e,n),r)]}case"Squeeze":{const r=I("axis",t,e,n);return[jn.L(I("x",t,e,n),r)]}case"Reshape":return[Ee.X(I("x",t,e,n),I("shape",t,e,n))];case"MirrorPad":return[ar.V(I("x",t,e,n),I("padding",t,e,n),I("mode",t,e,n))];case"PadV2":case"Pad":return[ir.v(I("x",t,e,n),I("padding",t,e,n),I("constantValue",t,e,n))];case"SpaceToBatchND":{const r=I("blockShape",t,e,n),o=I("paddings",t,e,n);return[ur.f(I("x",t,e,n),r,o)]}case"BatchToSpaceND":{const r=I("blockShape",t,e,n),o=I("crops",t,e,n);return[cr.E(I("x",t,e,n),r,o)]}case"DepthToSpace":{const r=I("blockSize",t,e,n),o=I("dataFormat",t,e,n).toUpperCase();return[lr.n(I("x",t,e,n),r,o)]}case"BroadcastTo":return[pr.U(I("x",t,e,n),I("shape",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n)));case"hash_table":return(async(t,e,n,r)=>{switch(t.op){case"HashTable":case"HashTableV2":{const o=I("keyDType",t,e,n),s=I("valueDType",t,e,n),a=new gn(o,s);return r.addHashTable(t.name,a),[a.handle]}case"LookupTableImport":case"LookupTableImportV2":{const o=I("tableHandle",t,e,n,r),s=I("keys",t,e,n),a=I("values",t,e,n),i=r.getHashTableById(o.id);return[await i.import(s,a)]}case"LookupTableFind":case"LookupTableFindV2":{const o=I("tableHandle",t,e,n,r),s=I("keys",t,e,n),a=I("defaultValue",t,e,n),i=r.getHashTableById(o.id);return[await i.find(s,a)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n,r);case"custom":const o=N(t.op);if(o&&o.customExecutor)return o.customExecutor(new lt(t,e,n));throw TypeError(`Custom op ${t.op} is not registered.`);default:throw TypeError(`Unknown op '${t.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return $.D5U.tI(o)?o.then((t=>[].concat(t))):[].concat(o)}class hr{constructor(t={},e={},n={},r={}){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=n,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const n=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(n))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map((t=>0===t.id&&0===t.iterationId?"":`${t.frameName}-${t.iterationId}`)).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function fr(t,e,n,r){const o=new Set,s=[];let a=null,i=null;const u=new Set,c=Object.keys(t).map((t=>S(t)[0]));let l=[];null!=r&&(l=r.map((t=>S(t.name)[0])));const p=[...e];for(;p.length>0;){const t=p.pop();(xr(t)||vr(t)||br(t))&&null==a&&(a=t,i=a.children.map((t=>t.name)).filter((t=>o.has(t)))),o.add(t.name),null==n[t.name]&&-1===c.indexOf(t.name)&&-1===l.indexOf(t.name)&&(0!==t.inputs.length?t.inputs.forEach((t=>{u.has(t.name)||(u.add(t.name),p.push(t))})):s.push(t.name))}return{inputs:t,outputs:e,usedNodes:o,missingInputs:s,dynamicNode:a,syncInputs:i}}const mr=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],gr=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],yr=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2"];function xr(t){return mr.indexOf(t.op)>=0}function vr(t){return gr.indexOf(t.op)>=0}function br(t){return yr.indexOf(t.op)>=0}class wr{constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach((e=>{this._functionExecutorMap[e]=new wr(t.functions[e],this)}))}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map((e=>t[e].map((t=>t.id))));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map((t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((t=>t.signatureKey||t.name))}get outputNodes(){return this._outputs.map((t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e}))}get functions(){return Object.keys(this._functions).reduce(((t,e)=>(t[e]=this._functions[e].signature,t)),{})}getCompilationKey(t,e){const n=t.map((t=>t.name)).sort(),r=e.map((t=>t.name)).sort();return n.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(t,e){const n=fr(t,e,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:o,syncInputs:s}=n;if(null!=o)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(r.length>0){const n=e.map((t=>t.name)),o=Object.keys(t);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${o}]. Missing the following inputs: [${r}]`)}return function(t,e,n){const{usedNodes:r,inputs:o}=n,s=[],a=Object.keys(o).map((t=>S(t)[0])).map((e=>t.nodes[e])),i=t.initNodes;a.forEach((t=>{r.has(t.name)&&s.push(t)})),t.weights.forEach((t=>{r.has(t.name)&&s.push(t)})),null!=i&&i.forEach((t=>{r.has(t.name)&&s.push(t)}));const u=new Set,c=[];for(;s.length>0;){const t=s.pop();u.add(t.name),e[t.name]||c.push(t),t.children.forEach((t=>{!u.has(t.name)&&r.has(t.name)&&t.inputs.every((t=>u.has(t.name)))&&s.push(t)}))}return c}(this.graph,this.weightMap,n)}execute(t,e){t=this.mapInputs(t);const n=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const r=n.map((t=>this.graph.nodes[S(t)[0]])),o=e.map((t=>S(t)[0]));let s=o.map((t=>this.graph.nodes[t]));0===s.length&&(s=this._outputs);const a=this.getCompilationKey(r,s);let i=this.compiledMap.get(a);null==i&&(i=this.compile(t,s),this.compiledMap.set(a,i));const u={},c={};return(0,$.lub)((()=>{const n=new hr(this.weightMap,u,c,this.functionExecutorMap),r=Object.assign({},this.weightMap);Object.keys(t).forEach((e=>{const[n,o]=S(e),s=[];s[o]=t[e],r[n]=s}));const s=this.getFrozenTensorIds(r),a={};for(let t=0;t<i.length;t++){const e=i[t];if(!r[e.name]){const t=dr(e,r,n,this._resourceManager);if($.D5U.tI(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.checkTensorForDisposal(e.name,e,r,n,s,o,a)}}return null==this.parent&&n.dispose(s),e.map((t=>E(t,r,n)))}))}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map((e=>t[e])).map((t=>t.map((t=>t.id)))));return new Set(e)}checkTensorForDisposal(t,e,n,r,o,s,a){"control"!==e.category&&-1===s.indexOf(t)&&(n[t].forEach((t=>{null!=t&&(a[t.id]=(a[t.id]||0)+e.children.length)})),e.inputs.forEach((t=>{if("control"!==t.category){const e=function(t,e,n){return e[k(t,n.currentContextId)]}(t.name,n,r);null!=e&&e.forEach((t=>{if(t&&!o.has(t.id)){const e=a[t.id];1===e?(t.dispose(),delete a[t.id]):null!=e&&a[t.id]--}}))}})))}async executeAsync(t,e){return this._executeAsync(t,e)}async _executeAsync(t,e,n=!1,r={},o={}){n||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));const s=new hr(this.weightMap,r,o,this.functionExecutorMap),a=await this.executeWithControlFlow(t,s,e,n),i=e.map((t=>E(t,a,s))),u=i.map((t=>t.id)),c=Object.keys(t).map((e=>t[e].id)),l=new Set([...u,...c,...this.weightIds]);return Object.keys(a).forEach((t=>{a[t].forEach((t=>{!t||t.isDisposed||l.has(t.id)||t.dispose()}))})),null==this.parent&&s.dispose(l),i}async executeFunctionAsync(t,e,n){const r=t.reduce(((t,e,n)=>(t[this.inputs[n].name]=e,t)),{});return this._executeAsync(r,this.outputNodes,!0,e,n)}async executeWithControlFlow(t,e,n,r){const o=Object.keys(t),s=o.map((t=>this.graph.nodes[S(t)[0]])),a=n.map((t=>S(t)[0]));let i=a.map((t=>this.graph.nodes[t]));0===i.length&&(i=this._outputs);const{usedNodes:u,missingInputs:c,dynamicNode:l,syncInputs:p}=fr(t,i,this.weightMap,this._initNodes),d=[...s,...this.graph.weights,...this._initNodes||[]].map((t=>({node:t,contexts:e.currentContext}))),h=Object.assign({},this.weightMap);Object.keys(t).forEach((e=>{const[n,r]=S(e),o=[];o[r]=t[e],h[n]=o}));const f={},m=this.getFrozenTensorIds(h),g={};for(;d.length>0;){const t=this.processStack(s,d,e,h,g,m,a,f,u);await Promise.all(t)}null!=l||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const y=i.filter((t=>!xr(t)&&!E(t.name,h,e))).map((t=>t.name));if(y.length>0){let t="";throw null!=l&&(t=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${y}] from the provided inputs [${o}]. Consider providing the following inputs: [${c}]. ${t}`)}return h}processStack(t,e,n,r,o,s,a,i,u){const c=[];for(;e.length>0;){const t=e.pop();n.currentContext=t.contexts;let l="";if("Enter"===t.node.op&&I("isConstant",t.node,r,n)&&([l]=T(t.node.name,n)),null==r[t.node.name]){const p=dr(t.node,r,n,this._resourceManager);l||([l]=T(t.node.name,n));const d=n.currentContext;$.D5U.tI(p)?c.push(p.then((c=>(r[l]=c,n.currentContext=d,this.checkTensorForDisposal(l,t.node,r,n,s,a,i),this.processChildNodes(t.node,e,n,r,o,u),c)))):(r[l]=p,this.checkTensorForDisposal(l,t.node,r,n,s,a,i),this.processChildNodes(t.node,e,n,r,o,u))}else this.processChildNodes(t.node,e,n,r,o,u)}return c}processChildNodes(t,e,n,r,o,s){t.children.forEach((t=>{const[a]=T(t.name,n);!o[a]&&s.has(t.name)&&("Merge"===t.op?t.inputNames.some((t=>!!E(t,r,n)))&&(o[a]=!0,e.push({contexts:n.currentContext,node:t})):t.inputNames.every((t=>!!E(t,r,n)))&&(o[a]=!0,e.push({contexts:n.currentContext,node:t})))}))}dispose(){Object.keys(this.weightMap).forEach((t=>this.weightMap[t].forEach((t=>t.dispose()))))}checkInputShapeAndType(t){Object.keys(t).forEach((e=>{const n=t[e],[r]=S(e),o=this.graph.nodes[r];if(o.attrParams.shape&&o.attrParams.shape.value){const t=o.attrParams.shape.value,e=t.length===n.shape.length&&n.shape.every(((e,n)=>-1===t[n]||t[n]===e));$.D5U.hu(e,(()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${t}], but was [${n.shape}]`))}o.attrParams.dtype&&o.attrParams.dtype.value&&$.D5U.hu(n.dtype===o.attrParams.dtype.value,(()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(t){const e={};for(const n in t)null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[n]?e[this._signature.inputs[n].name]=t[n]:e[n]=t[n];return e}checkInputs(t){const e=Object.keys(t).filter((t=>{const[e]=S(t);return null==this.graph.nodes[e]}));if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map((t=>null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[t]?this._signature.outputs[t].name:t),{})}checkOutputs(t){t.forEach((t=>{const[e]=S(t);if(!this.graph.nodes[e])throw new Error(`The output '${t}' is not found in the graph`)}))}}class $r{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}class Cr{constructor(t,e={}){this.modelUrl=t,this.loadOptions=e,this.version="n/a",null==e&&(this.loadOptions={}),this.resourceManager=new $r}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=$.io.MP(t,this.loadOptions);else{const e=$.io.rM(t,this.loadOptions);if(0===e.length)e.push($.io.MP(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}async load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=await this.handler.load();return this.loadSync(t)}loadSync(t){this.artifacts=t;const e=this.artifacts.modelTopology;let n={};null!=this.artifacts.userDefinedMetadata&&(n=this.artifacts.userDefinedMetadata.signature),this.version=`${e.versions.producer}.${e.versions.minConsumer}`;const r=$.io.dI(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new wr(q.Instance.transformGraph(e,n)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,null!=t.modelInitializer){const e=q.Instance.transformGraph(t.modelInitializer);this.initializer=new wr(e),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(t,e){if("string"==typeof t){const e=$.io.yB(t);if(0===e.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(e.length>1)throw new Error(`Found more than one (${e.length}) save handlers for URL '${t}'`);t=e[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}predict(t,e){return this.execute(t,this.outputNodes)}normalizeInputs(t){if(!(t instanceof $.esB||Array.isArray(t)))return t;if((t=Array.isArray(t)?t:[t]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${t.length} input tensors.`);return this.inputNodes.reduce(((e,n,r)=>(e[n]=t[r],e)),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}execute(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const n=this.executor.execute(t,e);return n.length>1?n:n[0]}async executeAsync(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const n=await this.executor.executeAsync(t,e);return n.length>1?n:n[0]}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce(((e,n)=>(e[n]=[t[n]],e)),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function Nr(t,e={}){if(null==t)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==e&&(e={}),e.fromTFHub&&null==t.load&&(t.endsWith("/")||(t+="/"),t=`${t}model.json?tfjs-format=file`);const n=new Cr(t,e);return await n.load(),n}},8713:function(t,e,n){"use strict";n.d(e,{JL:function(){return r},Zu:function(){return o}});class r{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class o{time(t){return s("time")}read(t){return s("read")}readSync(t){return s("readSync")}numDataIds(){return s("numDataIds")}disposeData(t){return s("disposeData")}write(t,e,n){return s("write")}move(t,e,n,r){return s("move")}memory(){return s("memory")}floatPrecision(){return s("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}batchMatMul(t,e,n,r){return s("batchMatMul")}fusedBatchMatMul({a:t,b:e,transposeA:n,transposeB:r,bias:o,activation:a,preluActivationWeights:i}){return s("fusedBatchMatMul")}slice(t,e,n){return s("slice")}stridedSlice(t,e,n,r){return s("stridedSlice")}unstack(t,e){return s("unstack")}reverse(t,e){return s("reverse")}concat(t,e){return s("concat")}neg(t){return s("neg")}add(t,e){return s("add")}addN(t){return s("addN")}subtract(t,e){return s("subtract")}multiply(t,e){return s("multiply")}realDivide(t,e){return s("realDivide")}floorDiv(t,e){return s("floorDiv")}sum(t,e){return s("sum")}prod(t,e){return s("prod")}unsortedSegmentSum(t,e,n){return s("unsortedSegmentSum")}argMin(t,e){return s("argMin")}argMax(t,e){return s("argMax")}equal(t,e){return s("equal")}notEqual(t,e){return s("notEqual")}less(t,e){return s("less")}lessEqual(t,e){return s("lessEqual")}greater(t,e){return s("greater")}greaterEqual(t,e){return s("greaterEqual")}logicalNot(t){return s("logicalNot")}logicalAnd(t,e){return s("logicalAnd")}logicalOr(t,e){return s("logicalOr")}where(t){return s("where")}select(t,e,n){return s("select")}topk(t,e,n){return s("topk")}min(t,e){return s("min")}minimum(t,e){return s("minimum")}mod(t,e){return s("mod")}max(t,e){return s("max")}maximum(t,e){return s("maximum")}all(t,e){return s("all")}any(t,e){return s("any")}squaredDifference(t,e){return s("squaredDifference")}ceil(t){return s("ceil")}floor(t){return s("floor")}round(t){return s("round")}sign(t){return s("sign")}isNaN(t){return s("isNaN")}isInf(t){return s("isInf")}isFinite(t){return s("isFinite")}pow(t,e){return s("pow")}exp(t){return s("exp")}expm1(t){return s("expm1")}softmax(t,e){return s("softmax")}log(t){return s("log")}log1p(t){return s("log1p")}sqrt(t){return s("sqrt")}rsqrt(t){return s("rsqrt")}square(t){return s("square")}reciprocal(t){return s("reciprocal")}relu(t){return s("relu")}relu6(t){return s("relu6")}prelu(t,e){return s("prelu")}elu(t){return s("elu")}eluDer(t,e){return s("eluDer")}selu(t){return s("selu")}int(t){return s("int")}clip(t,e,n){return s("clip")}abs(t){return s("abs")}complexAbs(t){return s("complexAbs")}sigmoid(t){return s("sigmoid")}softplus(t){return s("softplus")}sin(t){return s("sin")}cos(t){return s("cos")}tan(t){return s("tan")}asin(t){return s("asin")}acos(t){return s("acos")}atan(t){return s("atan")}atan2(t,e){return s("atan2")}sinh(t){return s("sinh")}cosh(t){return s("cosh")}tanh(t){return s("tanh")}asinh(t){return s("asinh")}acosh(t){return s("acosh")}atanh(t){return s("atanh")}erf(t){return s("erf")}step(t,e){return s("step")}fusedConv2d({input:t,filter:e,convInfo:n,bias:r,activation:o,preluActivationWeights:a}){return s("fusedConv2d")}conv2d(t,e,n){return s("conv2d")}conv2dDerInput(t,e,n){return s("conv2dDerInput")}conv2dDerFilter(t,e,n){return s("conv2dDerFilter")}fusedDepthwiseConv2D({input:t,filter:e,convInfo:n,bias:r,activation:o,preluActivationWeights:a}){return s("fusedDepthwiseConv2D")}depthwiseConv2D(t,e,n){return s("depthwiseConv2D")}depthwiseConv2DDerInput(t,e,n){return s("depthwiseConv2DDerInput")}depthwiseConv2DDerFilter(t,e,n){return s("depthwiseConv2DDerFilter")}conv3d(t,e,n){return s("conv3d")}conv3dDerInput(t,e,n){return s("conv3dDerInput")}conv3dDerFilter(t,e,n){return s("conv3dDerFilter")}maxPool(t,e){return s("maxPool")}maxPoolBackprop(t,e,n,r){return s("maxPoolBackprop")}avgPool(t,e){return s("avgPool")}avgPoolBackprop(t,e,n){return s("avgPoolBackprop")}avgPool3d(t,e){return s("avgPool3d")}avgPool3dBackprop(t,e,n){return s("avgPool3dBackprop")}maxPool3d(t,e){return s("maxPool3d")}maxPool3dBackprop(t,e,n,r){return s("maxPool3dBackprop")}reshape(t,e){return s("reshape")}cast(t,e){return s("cast")}tile(t,e){return s("tile")}pad(t,e,n){return s("pad")}transpose(t,e){return s("transpose")}gather(t,e,n){return s("gather")}gatherND(t,e){return s("gatherND")}scatterND(t,e,n){return s("scatterND")}batchToSpaceND(t,e,n){return s("batchToSpaceND")}spaceToBatchND(t,e,n){return s("spaceToBatchND")}resizeBilinear(t,e,n,r){return s("resizeBilinear")}resizeBilinearBackprop(t,e,n){return s("resizeBilinearBackprop")}resizeNearestNeighbor(t,e,n,r){return s("resizeNearestNeighbor")}resizeNearestNeighborBackprop(t,e,n){return s("resizeNearestNeighborBackprop")}batchNorm(t,e,n,r,o,a){return s("batchNorm")}localResponseNormalization4D(t,e,n,r,o){return s("localResponseNormalization4D")}LRNGrad(t,e,n,r,o,a,i){return s("LRNGrad")}multinomial(t,e,n,r){return s("multinomial")}oneHot(t,e,n,r){return s("oneHot")}cumsum(t,e,n,r){return s("cumsum")}nonMaxSuppression(t,e,n,r,o){return s("nonMaxSuppression")}fft(t){return s("fft")}ifft(t){return s("ifft")}complex(t,e){return s("complex")}real(t){return s("real")}imag(t){return s("imag")}cropAndResize(t,e,n,r,o,a){return s("cropAndResize")}depthToSpace(t,e,n){return s("depthToSpace")}split(t,e,n){return s("split")}sparseToDense(t,e,n,r){return s("sparseToDense")}diag(t){return s("diag")}fill(t,e,n){return s("fill")}onesLike(t){return s("onesLike")}zerosLike(t){return s("zerosLike")}linspace(t,e,n){return s("linspace")}dispose(){return s("dispose")}}function s(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},2055:function(t,e,n){"use strict";n.d(e,{GP:function(){return i},qP:function(){return u},pA:function(){return c}});var r=n(9494),o=n(6092);function s(t,e,n){const r=function(t,e,n){return function(t,e,n){let r=0,o=t.length,s=0,a=!1;for(;r<o;){s=r+(o-r>>>1);const i=n(e,t[s]);i>0?r=s+1:(o=s,a=!i)}return a?r:-r-1}(t,e,n||a)}(t,e,n),o=r<0?-(r+1):r;t.splice(o,0,e)}function a(t,e){return t>e?1:t<e?-1:0}function i(t,e,n,r,o){return l(t,e,n,r,o,0).selectedIndices}function u(t,e,n,r,o,s){return l(t,e,n,r,o,0,!1,s,!0)}function c(t,e,n,r,o,s){return l(t,e,n,r,o,s,!0)}function l(t,e,n,a,i,u,c=!1,l=!1,f=!1){const m=[];for(let t=0;t<e.length;t++)e[t]>i&&m.push({score:e[t],boxIndex:t,suppressBeginIndex:0});m.sort(h);const g=u>0?-.5/u:0,y=[],x=[];for(;y.length<n&&m.length>0;){const e=m.pop(),{score:n,boxIndex:r,suppressBeginIndex:o}=e;if(n<i)break;let u=!1;for(let n=y.length-1;n>=o;--n){const o=p(t,r,y[n]);if(o>=a){u=!0;break}if(e.score=e.score*d(a,g,o),e.score<=i)break}e.suppressBeginIndex=y.length,u||(e.score===n?(y.push(r),x.push(e.score)):e.score>i&&s(m,e,h))}const v=y.length,b=n-v;l&&b>0&&(y.push(...new Array(b).fill(0)),x.push(...new Array(b).fill(0)));const w={selectedIndices:(0,o.R)(y,"int32")};return c&&(w.selectedScores=(0,o.R)(x,"float32")),f&&(w.validOutputs=(0,r.i)(v,"int32")),w}function p(t,e,n){const r=t.subarray(4*e,4*e+4),o=t.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),a=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),c=Math.min(o[0],o[2]),l=Math.min(o[1],o[3]),p=Math.max(o[0],o[2]),d=Math.max(o[1],o[3]),h=(i-s)*(u-a),f=(p-c)*(d-l);if(h<=0||f<=0)return 0;const m=Math.max(s,c),g=Math.max(a,l),y=Math.min(i,p),x=Math.min(u,d),v=Math.max(y-m,0)*Math.max(x-g,0);return v/(h+f-v)}function d(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function h(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}},8333:function(t,e,n){"use strict";n.d(e,{Z:function(){return o}});var r=n(2657);function o(t,e){const n=[];for(let t=0;t<e.length;t++)e[t]&&n.push(t);const o=(0,r.f)(t,"int32"),s=(0,r.f)([n.length,t.length],"int32");for(let e=0;e<n.length;e++){const r=o.indexToLoc(n[e]),a=e*t.length;s.values.set(r,a)}return s.toTensor()}},7097:function(t,e,n){"use strict";n.d(e,{BV:function(){return x},wv:function(){return y}});var r=n(8713),o=n(2885),s=n(5938),a=n(9121),i=n(6151),u=n(569);class c{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new p)}profileKernel(t,e,n){let r;const o=this.backendTimer.time((()=>{r=n()}));for(let e=0;e<r.length;e++){const n=r[e];n.data().then((e=>{l(e,n.dtype,t)}))}return{kernelName:t,outputs:r,inputs:e,timeMs:o.then((t=>t.kernelMs)),extraInfo:o.then((t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():""))}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:o,extraInfo:s}=t;n.forEach((t=>{Promise.all([t.data(),r,s]).then((n=>{this.logger.logKernelProfile(e,t,n[0],n[1],o,n[2])}))}))}}function l(t,e,n){if("float32"!==e)return!1;for(let e=0;e<t.length;e++){const r=t[e];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class p{logKernelProfile(t,e,n,r,o,s){const a="number"==typeof r?u.oj(`${r}ms`,9):r.error,i=u.oj(t,25),c=e.rank,l=e.size,p=u.oj(e.shape.toString(),14);let d="";for(const t in o){const n=o[t];if(null!=n){const r=n.shape||e.shape,o=r.length;d+=`${t}: ${o}D ${o>0?r:""} `}}console.log(`%c${i}\t%c${a}\t%c${c}D ${p}\t%c${l}\t%c${d}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}var d=n(4077),h=n(747),f=n(9155);class m{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class g{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new m}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(console.warn(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new c(this.backendInstance),!0}setupRegisteredKernels(){(0,i.tr)(this.backendName).forEach((t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(t){(0,i.tr)(t).forEach((e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])}))}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(!n||n instanceof r.Zu||"function"!=typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,r=n.then((n=>!(e<this.pendingBackendInitId||(this.registry[t]=n,this.pendingBackendInit=null,0)))).catch((n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(e){return console.warn(`Initialization of backend ${t} failed`),console.warn(e.stack||e.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:o}=this.initializeBackend(n);if(o||r)return{name:n,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,o=this.readSync(e);r.disposeData(e),n.backend=t,t.move(e,o,n.shape,n.dtype),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(t){throw e(),t}}nextTensorId(){return g.nextTensorId++}nextVariableId(){return g.nextVariableId++}clone(t){const e=this.makeTensorFromDataId(t.dataId,t.shape,t.dtype),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],(t=>({x:()=>{const e="float32",n={x:t},r={dtype:e};return x.runKernelFunc((n=>n.cast(t,e)),n,null,a.RF,r)}})),[],{}),e}runKernel(t,e,n,r,o){return this.runKernelFunc(null,e,null,t,n,r,o)}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let o=0;n.forEach((t=>{o+="complex64"===t.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-e-o-s;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${t}'`)}runKernelFunc(t,e,n,r,o,s,a){let u,c=[];const l=this.isTapeOn();null==r&&(r=null!=this.state.activeScope?this.state.activeScope.name:"");const p=this.state.numBytes,d=this.state.numTensors;let h;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const f=(0,i.pI)(r,this.backendName);let m,g;if(null!=f)h=()=>{const t=this.backend.numDataIds();m=f.kernelFunc({inputs:e,attrs:o,backend:this.backend});const n=Array.isArray(m)?m:[m];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(r,t,n);const i=n.map((({dataId:t,shape:e,dtype:n})=>this.makeTensorFromDataId(t,e,n)));if(l){let t=this.getTensorsForGradient(r,e,i);if(null==t){null==a&&(a=[]);const e=i.filter(((t,e)=>a[e]));t=(s||[]).slice().concat(e)}c=this.saveTensorsForBackwardMode(t)}return i};else{const e=t=>{l&&(c=t.map((t=>this.keep(this.clone(t)))))};h=()=>{const n=this.backend.numDataIds();m=this.tidy((()=>t(this.backend,e)));const o=Array.isArray(m)?m:[m];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(r,n,o),o}}return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(g=this.profiler.profileKernel(r,e,(()=>h())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(g),u=g.outputs):u=h()})),l&&this.addTapeNode(r,e,u,n,c,o),this.state.profiling&&this.state.activeProfile.kernels.push({name:r,bytesAdded:this.state.numBytes-p,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-d,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(e).map((t=>null!=e[t]?e[t].shape:null)),outputShapes:u.map((t=>t.shape)),kernelTimeMs:g.timeMs,extraInfo:g.extraInfo}),Array.isArray(m)?u:u[0]}saveTensorsForBackwardMode(t){return t.map((t=>this.keep(this.clone(t))))}getTensorsForGradient(t,e,n){const r=(0,i.uk)(t);if(null!=r){const t=r.inputsToSave||[],o=r.outputsToSave||[];let s;r.saveAllInputs?(u.hu(Array.isArray(e),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(e).map((t=>e[t]))):s=t.map((t=>e[t]));const a=n.filter(((t,e)=>o[e]));return s.concat(a)}return null}makeTensor(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let o=t;"string"===n&&u.HD(t[0])&&(o=t.map((t=>f.YW(t))));const s=r.write(o,e,n),a=new d.es(e,n,s,this.nextTensorId());if(this.incRef(a,r),"string"===n){const t=this.state.tensorInfo.get(s),e=(0,u.Ub)(o);this.state.numBytes+=e-t.bytes,t.bytes=e}return a}makeTensorFromDataId(t,e,n,r){n=n||"float32";const o=new d.es(e,n,t,this.nextTensorId());return this.incRef(o,r),o}makeVariable(t,e=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const o=new d._w(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[o.name])throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}incRef(t,e){const n=this.state.tensorInfo.has(t.dataId)?this.state.tensorInfo.get(t.dataId).refCount:0;if(this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++,0===n){this.state.numDataBuffers++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*u.bT(t.dtype)),this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n,refCount:0}),this.state.numBytes+=n}this.state.tensorInfo.get(t.dataId).refCount++,t instanceof d._w||this.track(t)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;this.state.numTensors--,"string"===t.dtype&&this.state.numStringTensors--;const e=this.state.tensorInfo.get(t.dataId);e.refCount<=1?("complex64"!==t.dtype&&(this.state.numBytes-=e.bytes),this.state.numDataBuffers--,e.backend.disposeData(t.dataId),this.state.tensorInfo.delete(t.dataId)):this.state.tensorInfo.get(t.dataId).refCount--}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const t of this.state.activeProfile.kernels)t.kernelTimeMs=await t.kernelTimeMs,t.extraInfo=await t.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,r,o,s){const a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:o},c=(0,i.uk)(t);null!=c&&(r=c.gradFunc),null!=r&&(a.gradient=t=>(t=t.map(((t,e)=>{if(null==t){const t=n[e],r=u.wT(t.size,t.dtype);return this.makeTensor(r,t.shape,t.dtype)}return t})),r(t.length>1?t:t[0],o,s))),this.state.activeTape.push(a)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=(0,h.Vu)(t),n=new Set(e.map((t=>t.id)));for(let t=0;t<this.state.activeScope.track.length;t++){const e=this.state.activeScope.track[t];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach((t=>{t.kept||t.scopeId!==r.id||this.track(t)}))}gradients(t,e,n,r=!1){if(u.hu(e.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const o=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));u.hu(o instanceof d.es,(()=>"The result y returned by f() must be a tensor."));const s=function(t,e,n){const r={},o={};for(let t=0;t<e.length;t++)r[e[t].id]=!0;for(let n=0;n<t.length;n++){const s=t[n],a=s.inputs;for(const t in a){const n=a[t];let i=!1;for(let t=0;t<e.length;t++)if(r[n.id]){s.outputs.forEach((t=>r[t.id]=!0)),i=!0,o[s.id]=!0;break}if(i)break}}const s={};s[n.id]=!0;const a={};for(let e=t.length-1;e>=0;e--){const n=t[e],r=n.inputs;for(let t=0;t<n.outputs.length;t++)if(s[n.outputs[t].id]){for(const t in r)s[r[t].id]=!0,a[n.id]=!0;break}}const i=[];for(let e=0;e<t.length;e++){const n=t[e];if(o[n.id]&&a[n.id]){const t={};for(const e in n.inputs){const o=n.inputs[e];r[o.id]&&(t[e]=o)}const e=Object.assign({},n);e.inputs=t,e.outputs=n.outputs,i.push(e)}}return i}(this.state.activeTape,e,o);if(!r&&0===s.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const t={};t[o.id]=null==n?function(t){const e=(0,u.p8)((0,u.NA)(t),"float32");return x.makeTensor(e,t,"float32")}(o.shape):n,function(t,e,n,r){for(let o=e.length-1;o>=0;o--){const s=e[o],a=[];if(s.outputs.forEach((e=>{const n=t[e.id];null!=n?a.push(n):a.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const i=s.gradient(a);for(const e in s.inputs){if(!(e in i))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(i)}.`);const o=n((()=>i[e]()));if("float32"!==o.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${o.dtype}'`);const a=s.inputs[e];if(!u.cO(o.shape,a.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${e}' has shape '${o.shape}', which does not match the shape of the input '${a.shape}'`);if(null==t[a.id])t[a.id]=o;else{const e=t[a.id];t[a.id]=r(e,o),e.dispose()}}}}(t,s,(t=>this.tidy(t)),v);const r=e.map((e=>t[e.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((t=>{for(const e of t.saved)e.dispose()})),this.state.activeTape=null),{value:o,grads:r}}))}customGrad(t){return u.hu(u.mf(t),(()=>"The f passed in customGrad(f) must be a function.")),(...e)=>{let n;u.hu(e.every((t=>t instanceof d.es)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};return e.forEach(((t,e)=>{r[e]=t})),this.runKernelFunc(((r,o)=>(n=t(...e,o),u.hu(n.value instanceof d.es,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),u.hu(u.mf(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value)),r,((t,r)=>{const o=n.gradFunc(t,r),s=Array.isArray(o)?o:[o];u.hu(s.length===e.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),u.hu(s.every((t=>t instanceof d.es)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const a={};return s.forEach(((t,e)=>{a[e]=()=>t})),a}))}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}async time(t){const e=(0,f.zO)(),n=await this.backend.time(t);return n.wallMs=(0,f.zO)()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new m;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function y(){const t=(0,s.D)();if(null==t._tfengine){const e=new o.qA(t);t._tfengine=new g(e)}return(0,o.iG)(t._tfengine.ENV),(0,d.Vi)((()=>t._tfengine)),t._tfengine}g.nextTensorId=0,g.nextVariableId=0;const x=y();function v(t,e){const n={a:t,b:e};return x.runKernelFunc(((n,r)=>{const o=n.add(t,e);return r([t,e]),o}),n,null,a.mm)}},2885:function(t,e,n){"use strict";n.d(e,{qA:function(){return o},OB:function(){return s},iG:function(){return i}});var r=n(569);class o{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if((0,r.tI)(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=function(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("=")))),e}(this.global.location.search);"tfjsflags"in t&&t.tfjsflags.split(",").forEach((t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}(e,n)}))}}function s(){return a}let a=null;function i(t){a=t}},5938:function(t,e,n){"use strict";let r;function o(){if(null==r){let t;if("undefined"!=typeof window)t=window;else if(void 0!==n.g)t=n.g;else if("undefined"!=typeof process)t=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}r=t}return r}function s(t,e){const n=function(){const t=o();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}n.d(e,{D:function(){return o},R:function(){return s}})},4368:function(t,e,n){"use strict";n.d(e,{MX:function(){return i},SR:function(){return u},lu:function(){return c},B9:function(){return l},Cn:function(){return p},N_:function(){return d},jq:function(){return h}});var r=n(7097),o=n(2885),s=n(4077),a=n(747);function i(t){(0,o.OB)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function u(){return r.BV}function c(t,e){return r.BV.tidy(t,e)}function l(t){(0,a.Vu)(t).forEach((t=>t.dispose()))}function p(t){return r.BV.keep(t)}function d(){return r.BV.backendName}function h(t,e,n=1){return r.BV.registerBackend(t,e,n)}(0,s.FZ)(i)},633:function(t,e,n){"use strict";n.d(e,{cb:function(){return o}});var r=n(7097);function o(t){return r.BV.customGrad(t)}},6743:function(t,e,n){"use strict";n.d(e,{SYM:function(){return ct.SY},mm_:function(){return ct.mm},QCc:function(){return ct.QC},JhU:function(){return ct.Jh},xts:function(){return ct.xt},RFZ:function(){return ct.RF},gJX:function(){return ct.gJ},Zz9:function(){return ct.Zz},Eh3:function(){return ct.Eh},mc4:function(){return ct.mc},JLz:function(){return he.JL},ZCY:function(){return ct.ZC},NEP:function(){return ct.NE},Y0y:function(){return ct.Y0},vwp:function(){return ct.vw},Uyb:function(){return ct.Uy},OR:function(){return ct.OR},eBW:function(){return ct.eB},sHE:function(){return ct.sH},Qg5:function(){return ct.Qg},iJz:function(){return ct.iJ},J_u:function(){return ct.J_},Zuw:function(){return he.Zu},ZbH:function(){return ct.Zb},YoZ:function(){return ct.Yo},mTV:function(){return ct.mT},GvW:function(){return ct.Gv},vFR:function(){return ct.vF},q2K:function(){return ct.q2},jQs:function(){return ct.jQ},wYn:function(){return ct.wY},uv1:function(){return ct.uv},cye:function(){return ct.cy},W0H:function(){return ct.W0},yQU:function(){return ct.yQ},xJR:function(){return ct.xJ},HZH:function(){return ct.HZ},b9H:function(){return ct.b9},bV0:function(){return ct.bV},RQH:function(){return ct.RQ},p2w:function(){return ct.p2},bK0:function(){return ct.bK},_tC:function(){return ct._t},Tr8:function(){return ct.Tr},sEM:function(){return ct.sE},esB:function(){return Z.es},YDk:function(){return Z.YD},G3Y:function(){return ct.G3},kpP:function(){return ct.kp},IHx:function(){return vt.IHx},Wap:function(){return a},Xhn:function(){return s},f3b:function(){return vt.f3b},d9v:function(){return vt.d9v},zoF:function(){return vt.zoF},Izb:function(){return vt.Izb},C2$:function(){return r},hiC:function(){return vt.hiC},SRH:function(){return bt.SR},OBj:function(){return p.OB},N_N:function(){return bt.N_},BHj:function(){return vt.BHj},io:function(){return o},CnY:function(){return bt.Cn},GDt:function(){return i},Fp7:function(){return vt.Fp7},dC7:function(){return vt.dC7},w6H:function(){return vt.w6H},jqO:function(){return bt.jq},wCN:function(){return lt.wC},XLQ:function(){return vt.XLQ},iD$:function(){return vt.iD$},XD2:function(){return vt.XD2},tPi:function(){return vt.tPi},kuN:function(){return gt},XAC:function(){return vt.XAC},knu:function(){return vt.knu},luU:function(){return vt.luU},z4k:function(){return xt.z4},XeE:function(){return vt.XeE},RRF:function(){return vt.RRF},odF:function(){return vt.odF},lub:function(){return bt.lu},p4s:function(){return vt.p4s},HHK:function(){return vt.HHK},x8V:function(){return xt.x8},D5U:function(){return yt},lls:function(){return vt.lls}});var r={};n.r(r),n.d(r,{j:function(){return l},t:function(){return c}});var o={};n.r(o),n.d(o,{MP:function(){return ut},dI:function(){return y},rM:function(){return I},yB:function(){return N}});var s={};n.r(s),n.d(s,{n:function(){return mt}});var a={};n.r(a),n.d(a,{ERF_A1:function(){return Wt},ERF_A2:function(){return Ut},ERF_A3:function(){return zt},ERF_A4:function(){return Gt},ERF_A5:function(){return Xt},ERF_P:function(){return Vt},PARALLELIZE_THRESHOLD:function(){return St.g},SELU_SCALE:function(){return Lt},SELU_SCALEALPHA:function(){return Mt},applyActivation:function(){return kt.QH},assertAndGetBroadcastShape:function(){return It.$N},assertAxesAreInnerMostDims:function(){return Nt.lB},assertParamsConsistent:function(){return Et.o},assignToTypedArray:function(){return Jt},axesAreInnerMostDims:function(){return Nt.YB},calculateShapes:function(){return Pt.SU},castTensor:function(){return oe},combineLocations:function(){return Nt.Vh},complexWithEvenIndex:function(){return Yt},complexWithOddIndex:function(){return Qt},computeConv2DInfo:function(){return Tt.Ix},computeConv3DInfo:function(){return Tt.jw},computeDefaultPad:function(){return Tt.aO},computeDilation2DInfo:function(){return Tt.Rf},computeOptimalWindowSize:function(){return St.A},computeOutAndReduceShapes:function(){return Nt.kz},computeOutShape:function(){return Et.N},computePool2DInfo:function(){return Tt.Xw},computePool3DInfo:function(){return Tt.pl},convertConv2DDataFormat:function(){return Tt.sl},eitherStridesOrDilationsAreOne:function(){return Tt.jT},expandShapeToKeepDim:function(){return Nt.rv},exponent:function(){return ee},exponents:function(){return te},getAxesPermutation:function(){return Nt.Q3},getBroadcastDims:function(){return It.XF},getComplexWithIndex:function(){return Zt},getFusedBiasGradient:function(){return kt.pf},getFusedDyActivation:function(){return kt.Fr},getImageCenter:function(){return Rt},getInnerMostAxes:function(){return Nt.sY},getPermuted:function(){return At},getReductionAxes:function(){return It.RR},getReshaped:function(){return _t},getReshapedPermuted:function(){return Dt},getSliceBeginCoords:function(){return Ot},getSliceSize:function(){return Ft},getUndoAxesPermutation:function(){return Nt.LJ},linspaceImpl:function(){return ae},log:function(){return jt},mergeRealAndImagArrays:function(){return Kt},prepareAndValidate:function(){return Bt},prepareSplitSize:function(){return ne.O},reshapeTensor:function(){return se},segment_util:function(){return re},shouldFuse:function(){return kt.uy},slice_util:function(){return gt},splitRealAndImagArrays:function(){return qt},tupleValuesAreOne:function(){return Tt.I0},upcastType:function(){return xt.x8},validateInput:function(){return Pt.b0},validateUpdateShape:function(){return Pt.l5},warn:function(){return Ht}});var i={};n.r(i),n.d(i,{GP:function(){return ie.GP},qP:function(){return ie.qP},pA:function(){return ie.pA},Vl:function(){return ce},Gg:function(){return le},vN:function(){return pe},ZA:function(){return de.Z}});var u=n(7097);function c(){if("undefined"!=typeof navigator&&null!=navigator){const t=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function l(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}var p=n(2885);const d=(0,p.OB)();d.registerFlag("DEBUG",(()=>!1),(t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),d.registerFlag("IS_BROWSER",(()=>l())),d.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node)),d.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),d.registerFlag("PROD",(()=>!1)),d.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>d.getBool("DEBUG"))),d.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),d.registerFlag("IS_TEST",(()=>!1));var h=n(1661),f=n(701),m=n(569);const g={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};function y(t,e){const n={};let r,o=0;for(const s of e){const e=s.name,a=s.dtype,i=s.shape,u=(0,m.NA)(i);let c;if("quantization"in s){const n=s.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${s.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${s.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${s.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${a}.`)}const i=g[n.dtype],l=t.slice(o,o+u*i),p="uint8"===n.dtype?new Uint8Array(l):new Uint16Array(l);if("float32"===a)if("uint8"===n.dtype||"uint16"===n.dtype){c=new Float32Array(p.length);for(let t=0;t<p.length;t++){const e=p[t];c[t]=e*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===r&&(r=$()),c=r(p)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${e}': ${a}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);c=new Int32Array(p.length);for(let t=0;t<p.length;t++){const e=p[t];c[t]=Math.round(e*n.scale+n.min)}}o+=u*i}else if("string"===a){const e=(0,m.NA)(s.shape);c=[];for(let n=0;n<e;n++){const e=new Uint32Array(t.slice(o,o+4))[0];o+=4;const n=new Uint8Array(t.slice(o,o+e));c.push(n),o+=e}}else{const r=g[a],s=t.slice(o,o+u*r);if("float32"===a)c=new Float32Array(s);else if("int32"===a)c=new Int32Array(s);else if("bool"===a)c=new Uint8Array(s);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${e}': ${a}`);{c=new Float32Array(s);const t=new Float32Array(c.length/2),r=new Float32Array(c.length/2);for(let e=0;e<t.length;e++)t[e]=c[2*e],r[e]=c[2*e+1];const o=(0,f.X)(t,i,"float32"),a=(0,f.X)(r,i,"float32");n[e]=(0,h.P)(o,a),o.dispose(),a.dispose()}}o+=u*r}"complex64"!==a&&(n[e]=(0,f.X)(c,i,a))}return n}const x="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function v(t){return x?Buffer.byteLength(t):new Blob([t]).size}function b(t){if(1===t.length)return t[0];let e=0;t.forEach((t=>{e+=t.byteLength}));const n=new Uint8Array(e);let r=0;return t.forEach((t=>{n.set(new Uint8Array(t),r),r+=t.byteLength})),n.buffer}function w(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:v(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:v(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function $(){const t=function(){const t=t=>{let e=t<<13,n=0;for(;0==(8388608&e);)n-=8388608,e<<=1;return e&=-8388609,n+=947912704,e|n},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}(),e=function(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}(),n=function(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}();return r=>{const o=new ArrayBuffer(4*r.length),s=new Uint32Array(o);for(let o=0;o<r.length;o++){const a=r[o],i=t[n[a>>10]+(1023&a)]+e[a>>10];s[o]=i}return new Float32Array(o)}}class C{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==C.instance&&(C.instance=new C),C.instance}static registerSaveRouter(t){C.getInstance().saveRouters.push(t)}static registerLoadRouter(t){C.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return C.getHandlers(t,"save")}static getLoadHandlers(t,e){return C.getHandlers(t,"load",e)}static getHandlers(t,e,n){const r=[];return("load"===e?C.getInstance().loadRouters:C.getInstance().saveRouters).forEach((e=>{const o=e(t,n);null!==o&&r.push(o)})),r}}const N=t=>C.getSaveHandlers(t),I=(t,e)=>C.getLoadHandlers(t,e),E="tensorflowjs",T="models_store",k="model_info_store";function S(){if(!(0,p.OB)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"==typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function R(t){const e=t.result;e.createObjectStore(T,{keyPath:"modelPath"}),e.createObjectStore(k,{keyPath:"modelPath"})}class _{constructor(t){if(this.indexedDB=S(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise(((t,n)=>{const r=this.indexedDB.open(E,1);r.onupgradeneeded=()=>R(r),r.onsuccess=()=>{const o=r.result;if(null==e){const e=o.transaction(T,"readonly"),r=e.objectStore(T).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return o.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));t(r.result.modelArtifacts)},r.onerror=t=>(o.close(),n(r.error)),e.oncomplete=()=>o.close()}else{const r=w(e),s=o.transaction(k,"readwrite");let a=s.objectStore(k);const i=a.put({modelPath:this.modelPath,modelArtifactsInfo:r});let u;i.onsuccess=()=>{u=o.transaction(T,"readwrite");const i=u.objectStore(T).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:r});i.onsuccess=()=>t({modelArtifactsInfo:r}),i.onerror=t=>{a=s.objectStore(k);const e=a.delete(this.modelPath);e.onsuccess=()=>(o.close(),n(i.error)),e.onerror=t=>(o.close(),n(i.error))}},i.onerror=t=>(o.close(),n(i.error)),s.oncomplete=()=>{null==u?o.close():u.oncomplete=()=>o.close()}}},r.onerror=t=>n(r.error)}))}}_.URL_SCHEME="indexeddb://";const A=t=>{return(0,p.OB)().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(_.URL_SCHEME)?(e=t.slice(_.URL_SCHEME.length),new _(e)):null;var e};C.registerSaveRouter(A),C.registerLoadRouter(A);class D{constructor(){this.indexedDB=S()}async listModels(){return new Promise(((t,e)=>{const n=this.indexedDB.open(E,1);n.onupgradeneeded=()=>R(n),n.onsuccess=()=>{const r=n.result,o=r.transaction(k,"readonly"),s=o.objectStore(k).getAll();s.onsuccess=()=>{const e={};for(const t of s.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},s.onerror=t=>(r.close(),e(s.error)),o.oncomplete=()=>r.close()},n.onerror=t=>e(n.error)}))}async removeModel(t){var e;return t=(e=t).startsWith(_.URL_SCHEME)?e.slice(_.URL_SCHEME.length):e,new Promise(((e,n)=>{const r=this.indexedDB.open(E,1);r.onupgradeneeded=()=>R(r),r.onsuccess=()=>{const o=r.result,s=o.transaction(k,"readwrite"),a=s.objectStore(k),i=a.get(t);let u;i.onsuccess=()=>{if(null==i.result)return o.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const r=a.delete(t),s=()=>{u=o.transaction(T,"readwrite");const r=u.objectStore(T).delete(t);r.onsuccess=()=>e(i.result.modelArtifactsInfo),r.onerror=t=>n(i.error)};r.onsuccess=s,r.onerror=t=>(s(),o.close(),n(i.error))}},i.onerror=t=>(o.close(),n(i.error)),s.oncomplete=()=>{null==u?o.close():u.oncomplete=()=>o.close()}},r.onerror=t=>n(r.error)}))}}const O="/",F="tensorflowjs_models",B="info",P="model_topology",M="weight_specs",L="weight_data",V="model_metadata";function W(t){return{info:[F,t,B].join(O),topology:[F,t,P].join(O),weightSpecs:[F,t,M].join(O),weightData:[F,t,L].join(O),modelMetadata:[F,t,V].join(O)}}function U(t){const e=t.split(O);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(O)}class z{constructor(t){if(!(0,p.OB)().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=W(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),r=w(t);try{return this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(t){if(x)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let t=0,r=e.length;t<r;t++)n+=String.fromCharCode(e[t]);return btoa(n)}(t.weightData)),this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,userDefinedMetadata:t.userDefinedMetadata})),{modelArtifactsInfo:r}}catch(t){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=r;const o=this.LS.getItem(this.keys.modelMetadata);if(null!=o){const t=JSON.parse(o);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,e.userDefinedMetadata=t.userDefinedMetadata}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=function(t){if(x){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let t=0;t<e.length;++t)n.set([e.charCodeAt(t)],t);return n.buffer}(s),e}}z.URL_SCHEME="localstorage://";const G=t=>{return(0,p.OB)().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(z.URL_SCHEME)?(e=t.slice(z.URL_SCHEME.length),new z(e)):null;var e};C.registerSaveRouter(G),C.registerLoadRouter(G);class X{constructor(){(0,m.hu)((0,p.OB)().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),(0,m.hu)("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const t={},e=F+O,n=O+B;for(let r=0;r<this.LS.length;++r){const o=this.LS.key(r);o.startsWith(e)&&o.endsWith(n)&&(t[U(o)]=JSON.parse(this.LS.getItem(o)))}return t}async removeModel(t){var e;const n=W(t=(e=t).startsWith(z.URL_SCHEME)?e.slice(z.URL_SCHEME.length):e);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(this.LS.getItem(n.info));return this.LS.removeItem(n.info),this.LS.removeItem(n.topology),this.LS.removeItem(n.weightSpecs),this.LS.removeItem(n.weightData),r}}class H{constructor(){this.managers={}}static getInstance(){return null==H.instance&&(H.instance=new H),H.instance}static registerManager(t,e){(0,m.hu)(null!=t,(()=>"scheme must not be undefined or null.")),t.endsWith("://")&&(t=t.slice(0,t.indexOf("://"))),(0,m.hu)(t.length>0,(()=>"scheme must not be an empty string."));const n=H.getInstance();(0,m.hu)(null==n.managers[t],(()=>`A model store manager is already registered for scheme '${t}'.`)),n.managers[t]=e}static getManager(t){const e=this.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}}class j{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}}if((0,p.OB)().get("IS_BROWSER")){(0,p.OB)().setPlatform("browser",new j);try{H.registerManager(z.URL_SCHEME,new X)}catch(t){}try{H.registerManager(_.URL_SCHEME,new D)}catch(t){}}let K;(0,p.OB)().get("IS_NODE")&&(0,p.OB)().setPlatform("node",new class{constructor(){this.util=n(1758),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=(0,p.OB)().global.fetch?(0,p.OB)().global.fetch(t,e):(null==K&&(K=n(8352)),K(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}});var q=n(2657),Y=n(2271),Q=n(8723),Z=n(4077);(0,u.wv)();const J={buffer:q.f,cast:Y.p,clone:Q.d,print:function(t,e=!1){console.log(t.toString(e))}};function tt(t){return new Promise((t=>setTimeout(t))).then(t)}(0,Z.Vp)(J);class et{constructor(t){if(!(0,p.OB)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(et.URL_SCHEME)&&(t=t.slice(et.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelTopologyFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:n},o=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),s=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor;if(s.download=this.modelTopologyFileName,s.href=o,await tt((()=>s.dispatchEvent(new MouseEvent("click")))),null!=t.weightData){const t=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName,t.href=e,await tt((()=>t.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:w(t)}}}}function nt(t,e,n,r){!function(t){(0,m.hu)(null!=t&&Array.isArray(t)&&t.length>0,(()=>"promises must be a none empty array"))}(t),function(t,e){(0,m.hu)(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${t}`)),(0,m.hu)(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${e}`)),(0,m.hu)(e>=t,(()=>`startFraction must be no more than endFraction, but got startFraction ${t} and endFraction ${e}`))}(n=null==n?0:n,r=null==r?1:r);let o=0;return Promise.all(t.map((s=>(s.then((s=>{const a=n+ ++o/t.length*(r-n);return e(a),s})),s))))}async function rt(t,e){null==e&&(e={});const n=null==e.fetchFunc?(0,p.OB)().platform.fetch:e.fetchFunc,r=t.map((t=>n(t,e.requestInit,{isBinary:!0}))),o=(null==e.onProgress?await Promise.all(r):await nt(r,e.onProgress,0,.5)).map((t=>t.arrayBuffer()));return null==e.onProgress?await Promise.all(o):await nt(o,e.onProgress,.5,1)}et.URL_SCHEME="downloads://",C.registerSaveRouter((t=>(0,p.OB)().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(et.URL_SCHEME)?function(t="model"){return new et(t)}(t.slice(et.URL_SCHEME.length)):null));class ot{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?((0,m.hu)("function"==typeof e.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=e.fetchFunc):this.fetch=(0,p.OB)().platform.fetch,(0,m.hu)(null!=t&&t.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(t)&&(0,m.hu)(2===t.length,(()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`)),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,userDefinedMetadata:t.userDefinedMetadata,weightsManifest:n};e.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const o=await this.fetch(this.path,e);if(o.ok)return{modelArtifactsInfo:w(t),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(t){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=e.modelTopology,r=e.weightsManifest,o=e.generatedBy,s=e.convertedBy,a=e.format,i=e.userDefinedMetadata;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let u,c;if(null!=r){const t=await this.loadWeights(r);[u,c]=t}const l={modelTopology:n,weightSpecs:u,weightData:c,userDefinedMetadata:i,generatedBy:o,convertedBy:s,format:a},p=e.modelInitializer;return p&&(l.modelInitializer=p),l}async loadWeights(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?");return[t.substring(0,e)+"/",n>e?t.substring(n):""]}(e),o=this.weightPathPrefix||n,s=[];for(const e of t)s.push(...e.weights);const a=[],i=[];for(const e of t)for(const t of e.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(t)):a.push(o+t+r);return this.weightUrlConverter&&a.push(...await Promise.all(i)),[s,b(await rt(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function st(t){return null!=t.match(ot.URL_SCHEME_REGEX)}ot.URL_SCHEME_REGEX=/^https?:\/\//;const at=(t,e)=>{if("undefined"==typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every((t=>st(t))):st(t),n)return it(t,e)}return null};function it(t,e){return new ot(t,e)}function ut(t,e){return it(t,e)}C.registerSaveRouter(at),C.registerLoadRouter(at);var ct=n(9121),lt=n(6151),pt=n(2668),dt=n(3740),ht=n(7852);let ft;const mt=(0,pt.op)({fromPixels_:function(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,o=!1,s=!1,a=!1;if(t.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&t instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement)o=!0;else if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement)s=!0;else{if(null==t.getContext)throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);a=!0}if(o){const e=2;if(o&&t.readyState<e)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=(0,lt.pI)(ct.eB,u.BV.backendName)){const n={pixels:t},r={numChannels:e};return u.BV.runKernel(ct.eB,n,r)}const[i,c]=o?[t.videoWidth,t.videoHeight]:[t.width,t.height];let l,p;if(a?l=t.getContext("2d").getImageData(0,0,i,c).data:r||n?l=t.data:(s||o)&&(null==ft&&(ft=document.createElement("canvas").getContext("2d")),ft.canvas.width=i,ft.canvas.height=c,ft.drawImage(t,0,0,i,c),l=ft.getImageData(0,0,i,c).data),4===e)p=new Int32Array(l);else{const t=i*c;p=new Int32Array(t*e);for(let n=0;n<t;n++)for(let t=0;t<e;++t)p[n*e+t]=l[4*n+t]}return function(t,e,n){if((0,m.Cq)(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");const r=(0,dt.C)(t,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,ht.H)(t,e,r,n)}(p,[c,i,e],"int32")}});var gt=n(7650),yt=n(9155),xt=n(1221),vt=n(5410),bt=n(4368),wt=n(9494),$t=n(6092),Ct=n(9640),Nt=n(3591),It=n(2200),Et=n(398),Tt=n(2582),kt=n(9323),St=n(5466);function Rt(t,e,n){return[n*("number"==typeof t?t:t[0]),e*("number"==typeof t?t:t[1])]}function _t(t,e,n,r=!0){let o=[];if(r)o=o.concat(e.slice(0)),o.push(t[0]/n),o=o.concat(t.slice(1));else{o=o.concat(t[0]);const n=e.length;for(let r=0;r<n;++r)o=o.concat([t[r+1]/e[r],e[r]]);o=o.concat(t.slice(n+1))}return o}function At(t,e,n=!0){const r=[];if(n){r.push(e);for(let n=e+1;n<t;++n)n<=2*e?(r.push(n),r.push(n-(e+1))):r.push(n)}else{const n=[],o=[];for(let r=1;r<t;++r)r>=2*e+1||r%2==1?o.push(r):n.push(r);r.push(...n),r.push(0),r.push(...o)}return r}function Dt(t,e,n,r=!0){const o=[];r?o.push(t[0]/n):o.push(t[0]*n);for(let n=1;n<t.length;++n)n<=e.length?r?o.push(e[n-1]*t[n]):o.push(t[n]/e[n-1]):o.push(t[n]);return o}function Ot(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function Ft(t,e,n){const r=t.slice(0,1);for(let o=0;o<n;++o)r.push(t[o+1]-e[o][0]-e[o][1]);return r}function Bt(t,e){if(t.rank<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==e.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[e.rank-1]>t.rank)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[e.rank-1]} vs. ${t.rank}`);if(0===t.size)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const n=e.shape,r=n[n.length-1];let o=1;for(let t=0;t<n.length-1;++t)o*=n[t];const s=t.shape,a=n.slice();a.pop();let i=1;for(let e=r;e<t.rank;++e)i*=s[e],a.push(s[e]);const u=[...(0,m.e3)(t.shape).map((t=>t/i)),1].slice(0,r);return[a,o,i,u]}var Pt=n(3028);const Mt=1.7580993408473768,Lt=1.0507009873554805,Vt=.3275911,Wt=.254829592,Ut=-.284496736,zt=1.421413741,Gt=-1.453152027,Xt=1.061405429;function Ht(...t){(0,p.OB)().getBool("IS_TEST")||console.warn(...t)}function jt(...t){(0,p.OB)().getBool("IS_TEST")||console.log(...t)}function Kt(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(2*t.length);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function qt(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function Yt(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let e=0;e<t.length;e+=4)n[Math.floor(e/4)]=t[e],r[Math.floor(e/4)]=t[e+1];return{real:n,imag:r}}function Qt(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let e=2;e<t.length;e+=4)n[Math.floor(e/4)]=t[e],r[Math.floor(e/4)]=t[e+1];return{real:n,imag:r}}function Zt(t,e){return{real:t[2*e],imag:t[2*e+1]}}function Jt(t,e,n,r){t[2*r]=e,t[2*r+1]=n}function te(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let o=0;o<Math.ceil(t/2);o++){const s=(e?2:-2)*Math.PI*(o/t);n[o]=Math.cos(s),r[o]=Math.sin(s)}return{real:n,imag:r}}function ee(t,e,n){const r=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(r),imag:Math.sin(r)}}var ne=n(4099),re=n(4931);function oe(t,e,n){if("complex64"===e){if("complex64"===t.dtype)return t.clone();const e=(0,Ct.l)(t.shape),r=(0,Y.p)(t,"float32"),o=n.complex(r,e);return e.dispose(),r.dispose(),o}if(!(0,m.QB)(t.dtype,e))return u.BV.makeTensorFromDataId(t.dataId,t.shape,e);if("complex64"===t.dtype){const r=n.real(t),o=(0,Y.p)(r,e);return r.dispose(),o}if("int32"===e)return n.int(t);if("bool"===e){const e=(0,wt.i)(0,t.dtype),r=n.notEqual(t,e);return e.dispose(),r}throw new Error(`Error in Cast: failed to cast ${t.dtype} to ${e}`)}function se(t,e){return u.BV.makeTensorFromDataId(t.dataId,e,t.dtype)}function ae(t,e,n){const r=(e-t)/(n-1),o=(0,m.wT)(n,"float32");o[0]=t;for(let t=1;t<o.length;t++)o[t]=o[t-1]+r;return(0,$t.R)(o,"float32")}var ie=n(2055),ue=n(2676);function ce(t,e,n){const r=new Array(t.rank).fill(0),o=t.shape.slice();return e.map((e=>{const s=[...o];s[n]=e;const a=(0,ue.t)(t,r,s);return r[n]+=e,a}))}function le(t,e){const n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=t.shape[r]*e[r];const r=(0,q.f)(n,t.dtype);for(let e=0;e<r.values.length;++e){const n=r.indexToLoc(e),o=new Array(t.rank);for(let e=0;e<o.length;e++)o[e]=n[e]%t.shape[e];const s=t.locToIndex(o);r.values[e]=t.values[s]}return r.toTensor()}function pe(t,e,n,r,o){const s=e[e.length-1],[a,i]=[t.length/s,s],u=(0,m.WP)(n,a*r),c=(0,m.WP)("int32",a*r);for(let e=0;e<a;e++){const n=e*i,o=t.subarray(n,n+i),s=[];for(let t=0;t<o.length;t++)s.push({value:o[t],index:t});s.sort(((t,e)=>e.value-t.value));const a=e*r,l=u.subarray(a,a+r),p=c.subarray(a,a+r);for(let t=0;t<r;t++)l[t]=s[t].value,p[t]=s[t].index}const l=e.slice();return l[l.length-1]=r,[(0,f.X)(u,l,n),(0,f.X)(c,l,"int32")]}var de=n(8333),he=n(8713),fe=n(4841),me=n(1901);const ge={kernelName:ct.SY,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,fe.d)(t,(0,me.N)((0,Y.p)(n,"float32"),-1))}}};var ye=n(1274),xe=n(7370),ve=n(3261),be=n(248),we=n(827);const $e={kernelName:ct.VG,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=(0,be.h)((0,Y.p)(n,"float32")),r=(0,ve._)((0,we.l)((0,wt.i)(1),e));return(0,xe.W)((0,ye.h)(t,r))}}}},Ce={kernelName:ct.Sp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=(0,ve._)((0,we.l)((0,be.h)((0,Y.p)(n,"float32")),1));return(0,ye.h)(t,e)}}}};var Ne=n(4968),Ie=n(5475);const Ee={kernelName:ct.mm,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,o=It.$N(n.shape,r.shape);return{a:()=>{let e=t;const r=It.RR(n.shape,o);return r.length>0&&(e=(0,Ie.S)(e,r)),(0,Ne.X)(e,n.shape)},b:()=>{let e=t;const n=It.RR(r.shape,o);return n.length>0&&(e=(0,Ie.S)(e,n)),(0,Ne.X)(e,r.shape)}}}},Te={kernelName:ct.Xz,saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach(((e,r)=>{n[r]=()=>t.clone()})),n}};var ke=n(6577);const Se={kernelName:ct.sJ,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,ke.P)(n)}}},Re={kernelName:ct.aJ,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,ke.P)(n)}}},_e={kernelName:ct.M2,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,ye.h)(t,(0,ve._)((0,we.l)((0,wt.i)(1),(0,be.h)((0,Y.p)(n,"float32")))))}}};var Ae=n(6407);const De={kernelName:ct.qw,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=(0,ve._)((0,Ae.I)((0,wt.i)(1),(0,be.h)((0,Y.p)(n,"float32"))));return(0,ye.h)(t,e)}}}},Oe={kernelName:ct.QC,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,o=(0,It.$N)(n.shape,r.shape);return{a:()=>{const e=(0,Ae.I)((0,be.h)(n),(0,be.h)(r));let s=(0,fe.d)(t,(0,ye.h)(r,e));const a=(0,It.RR)(n.shape,o);return a.length>0&&(s=(0,Ie.S)(s,a)),(0,Ne.X)(s,n.shape)},b:()=>{const e=(0,Ae.I)((0,be.h)(n),(0,be.h)(r));let s=(0,xe.W)((0,fe.d)(t,(0,ye.h)(n,e)));const a=(0,It.RR)(r.shape,o);return a.length>0&&(s=(0,Ie.S)(s,a)),(0,Ne.X)(s,r.shape)}}}},Fe={kernelName:ct.jM,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,ye.h)(t,(0,Ae.I)((0,be.h)((0,Y.p)(n,"float32")),1))}}},Be={kernelName:ct.Oy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,ye.h)(t,(0,we.l)((0,wt.i)(1),(0,be.h)((0,Y.p)(n,"float32"))))}}},Pe=(0,pt.op)({avgPool3dBackprop_:function(t,e,n,r,o=[1,1,1],s,a){const i=(0,dt._1)(t,"dy","avgPool3dBackprop"),c=(0,dt._1)(e,"input","avgPool3dBackprop");let l=i,p=c,d=!1;4===c.rank&&(d=!0,l=(0,Ne.X)(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),p=(0,Ne.X)(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),m.hu(5===l.rank,(()=>`Error in avgPool3dBackprop: dy must be rank 5 but got rank ${l.rank}.`)),m.hu(5===p.rank,(()=>`Error in avgPool3dBackprop: input must be rank 5 but got rank ${p.rank}.`)),m.hu(Tt.jT(r,o),(()=>`Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides ${r} and dilations '${o}'`)),null!=a&&m.hu(m.GN(s),(()=>`Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`));const h={dy:l,input:p},f={filterSize:n,strides:r,dilations:o,pad:s,dimRoundingMode:a},g=u.BV.runKernelFunc((t=>{const e=Tt.pl(p.shape,n,r,o,s,a);return t.avgPool3dBackprop(l,p,e)}),h,null,ct.DC,f);return d?(0,Ne.X)(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),Me={kernelName:ct._k,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:o,strides:s,dilations:a,pad:i,dimRoundingMode:u}=n,c=null==a?[1,1,1]:a;return{x:()=>Pe(t,r,o,s,c,i,u)}}},Le=(0,pt.op)({avgPoolBackprop_:function(t,e,n,r,o){const s=(0,dt._1)(t,"dy","avgPoolBackprop"),a=(0,dt._1)(e,"input","avgPoolBackprop");m.hu(a.rank===s.rank,(()=>`Rank of input (${a.rank}) does not match rank of dy (${s.rank})`));let i=a,c=s,l=!1;3===a.rank&&(l=!0,i=(0,Ne.X)(a,[1,a.shape[0],a.shape[1],a.shape[2]]),c=(0,Ne.X)(s,[1,s.shape[0],s.shape[1],s.shape[2]])),m.hu(4===c.rank,(()=>`Error in avgPoolBackprop: dy must be rank 4 but got rank ${c.rank}.`)),m.hu(4===i.rank,(()=>`Error in avgPoolBackprop: input must be rank 4 but got rank ${i.rank}.`));const p={dy:c,input:i},d={filterSize:n,strides:r,pad:o},h=u.BV.runKernelFunc((t=>{const e=Tt.Xw(i.shape,n,r,1,o);return t.avgPoolBackprop(c,i,e)}),p,null,ct.xt,d);return l?(0,Ne.X)(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Ve={kernelName:ct.Jh,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:o,strides:s,pad:a}=n;return{x:()=>Le(t,r,o,s,a)}}};var We=n(8687);const Ue={kernelName:ct.XL,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[r,o]=e,{transposeA:s,transposeB:a}=n;return s||a?!s&&a?{a:()=>(0,We.O)(t,o,!1,!1),b:()=>(0,We.O)(t,r,!0,!1)}:s&&!a?{a:()=>(0,We.O)(o,t,!1,!0),b:()=>(0,We.O)(r,t,!1,!1)}:{a:()=>(0,We.O)(o,t,!0,!0),b:()=>(0,We.O)(t,r,!0,!0)}:{a:()=>(0,We.O)(t,o,!1,!0),b:()=>(0,We.O)(r,t,!0,!1)}}};var ze=n(7918);const Ge={kernelName:ct.zw,gradFunc:(t,e,n)=>{const{blockShape:r,crops:o}=n;return{x:()=>(0,ze.f)(t,r,o)}}},Xe={kernelName:ct.Ly,gradFunc:(t,e,n)=>{const r=n,o=r.inputShape,s=r.shape,a=Array.from(s);for(let t=o.length-1;t>=0;t--)if(o[t]===s[t])a[t]=1;else if(1!==o[t])throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${s}].`);const i=[];for(let t=0;t<a.length;t++)a[t]>1&&i.push(t);return{x:()=>(0,Ie.S)(t,i,!0)}}},He={kernelName:ct.RF,gradFunc:t=>({x:()=>t.clone()})},je={kernelName:ct.gJ,gradFunc:t=>({x:()=>(0,ke.P)(t)})};var Ke=n(7630),qe=n(624),Ye=n(2856),Qe=n(5912);const Ze={kernelName:ct.xn,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{clipValueMin:o,clipValueMax:s}=n;return{x:()=>(0,Qe.a)((0,Ye.H)((0,Ke.b)(r,o),(0,qe.z)(r,s)),t,(0,ke.P)(t))}}};var Je=n(8644);const tn={kernelName:ct.Eh,saveAllInputs:!0,gradFunc:(t,e,n)=>{const r=e.map((t=>t.shape)),{axis:o}=n,s=(0,m.EC)(o,e[0].shape)[0],a=r.map((t=>t[s]));return(0,Je.V)(t,a,s).map((t=>()=>t))}};var en=n(6013),nn=n(9832);const rn={kernelName:ct.mh,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,o]=e,{dilations:s,strides:a,pad:i,dataFormat:u}=n;return m.hu(Tt.I0(s),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`)),{x:()=>(0,nn._)(r.shape,t,o,a,i,u),filter:()=>(0,en.p)(r,t,o.shape,a,i,u)}}};var on=n(4794);const sn={kernelName:ct.wm,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[r,o]=e,{strides:s,pad:a,dataFormat:i,dimRoundingMode:u}=n;return{dy:()=>(0,on.T)(t,o,s,a,i,1,u),filter:()=>(0,en.p)(t,r,o.shape,s,a,i,u)}}},an=(0,pt.op)({conv3DBackpropFilter_:function(t,e,n,r,o){let s=t;4===t.rank&&(s=(0,Ne.X)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let a=e;4===a.rank&&(a=(0,Ne.X)(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),m.hu(5===s.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`)),m.hu(5===a.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`)),m.hu(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),m.hu(s.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`)),m.hu(a.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${n[4]}).`));const i={x:s,dy:a},c={strides:r,pad:o,filterShape:n};return u.BV.runKernelFunc((t=>{const e=Tt.jw(s.shape,n,r,1,o);return t.conv3dDerFilter(s,a,e)}),i,null,ct.o2,c)}}),un=(0,pt.op)({conv3DBackpropInput_:function(t,e,n,r,o){m.hu(t.length===e.rank,(()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`));let s=t,a=e,i=!1;4===e.rank&&(i=!0,a=(0,Ne.X)(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,t[0],t[1],t[2],t[3]]);const c=s[4],l=a.shape[4];m.hu(5===s.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`)),m.hu(5===a.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`)),m.hu(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),m.hu(c===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[3]}.`)),m.hu(l===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`));const p={dy:a,filter:n},d={pad:o,strides:r,inputShape:s},h=u.BV.runKernelFunc((t=>{const e=Tt.jw(s,n.shape,r,1,o);return t.conv3dDerInput(a,n,e)}),p,null,ct.ik,d);return i?(0,Ne.X)(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),cn={kernelName:ct.x1,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:o,pad:s}=n;m.hu((0,Tt.I0)(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[a,i]=e;return{x:()=>un(a.shape,t,i,o,s),filter:()=>an(a,t,i.shape,o,s)}}};var ln=n(9331);const pn={kernelName:ct.mc,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,fe.d)((0,xe.W)((0,ln.O)((0,Y.p)(n,"float32"))),t)}}};var dn=n(3254);const hn={kernelName:ct.TR,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,fe.d)((0,dn.R)((0,Y.p)(n,"float32")),t)}}};var fn=n(7405),mn=n(9065);const gn={kernelName:ct.iH,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:o,exclusive:s,reverse:a}=n;return{x:()=>{const e=(0,Nt.Q3)([o],r.rank);let n=(0,fn.z)(t,o,s,!a);return null!=e&&(n=(0,mn.p)(n,e)),n}}}};var yn=n(8098),xn=n(4375);const vn={kernelName:ct.ci,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:o,pad:s,dimRoundingMode:a}=n,i=null==r?[1,1]:r;m.hu(Tt.I0(i),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`));const[u,c]=e;return m.hu(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`)),m.hu(4===c.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`)),m.hu(u.shape[3]===c.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`)),m.hu(Tt.jT(o,i),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${i}'.`)),null!=a&&m.hu(m.GN(s),(()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`)),{x:()=>(0,xn.v)(u.shape,t,c,o,s,r,a),filter:()=>(0,yn.z)(u,t,c.shape,o,s,r,a)}}},bn={kernelName:ct.p4,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,o]=e,s={x:r,filter:o,dy:t},a={x:r,filter:o,dy:t};return{x:()=>u.BV.runKernel(ct.ek,s,n),filter:()=>u.BV.runKernel(ct.Vn,a,n)}}},wn={kernelName:ct.ZC,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,o=It.$N(n.shape,r.shape);return{a:()=>{const e=(0,ye.h)(t,(0,Y.p)(r,"float32")),s=It.RR(n.shape,o);return s.length>0?(0,Ne.X)((0,Ie.S)(e,s),n.shape):e},b:()=>{let e=(0,fe.d)(t,(0,Y.p)(n,"float32"));const s=It.RR(r.shape,o);s.length>0&&(e=(0,Ne.X)((0,Ie.S)(e,s),r.shape));const a=(0,be.h)(r);return(0,xe.W)((0,ye.h)(e,(0,Y.p)(a,"float32")))}}}},$n={kernelName:ct.SX,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,r=e=>e.eluDer(t,n),o={dy:t,y:n};return{x:()=>u.BV.runKernelFunc(r,o,null,ct.HE)}}};var Cn=n(4842);const Nn={kernelName:ct.Om,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=(0,fe.d)((0,Cn.Q)((0,xe.W)((0,be.h)(n))),2/Math.sqrt(Math.PI));return{x:()=>(0,fe.d)(t,r)}}},In={kernelName:ct.NE,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,fe.d)(t,n)}}},En={kernelName:ct.Y0,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,fe.d)(t,(0,Cn.Q)(n))}}},Tn={kernelName:ct.OR,gradFunc:t=>({x:()=>(0,ke.P)(t)})},kn={kernelName:ct.je,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,o=(0,It.$N)(n.shape,r.shape);return{a:()=>{const e=(0,ye.h)(t,(0,Y.p)(r,"float32")),s=(0,It.RR)(n.shape,o);return s.length>0?(0,Ne.X)((0,Ie.S)(e,s),n.shape):e},b:()=>{let e=(0,fe.d)(t,(0,Y.p)(n,"float32"));const s=(0,It.RR)(r.shape,o);s.length>0&&(e=(0,Ne.X)((0,Ie.S)(e,s),r.shape));const a=(0,be.h)(r);return(0,xe.W)((0,ye.h)(e,(0,Y.p)(a,"float32")))}}}};var Sn=n(2634),Rn=n(7501);const _n={kernelName:ct.sH,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:r}=n,[o,s,a,i]=e,u=null==i?(0,wt.i)(1):i,c=(0,It.RR)(s.shape,o.shape),l=[];if(1===s.rank){for(let t=0;t<o.shape.length-1;++t)l.push(o.shape[t]);l.push(1)}const p=(0,we.l)(o,s),d=(0,fe.d)(t,u),h=(0,Sn.b)((0,Ae.I)(a,(0,wt.i)(r))),f=(0,fe.d)((0,fe.d)((0,fe.d)(h,h),h),(0,wt.i)(-.5));return{x:()=>1===s.rank?(0,Ne.X)((0,fe.d)((0,fe.d)(t,(0,Rn.G)((0,Ne.X)(h,[1,1,1,s.shape[0]]),l)),u),o.shape):(0,Ne.X)((0,fe.d)((0,fe.d)(t,h),u),o.shape),mean:()=>{let t=(0,fe.d)((0,fe.d)(h,(0,wt.i)(-1)),d);return 1===s.rank&&(t=(0,Ie.S)(t,c)),(0,Ne.X)(t,s.shape)},variance:()=>{let t=(0,fe.d)((0,fe.d)(f,p),d);return 1===s.rank&&(t=(0,Ie.S)(t,c)),(0,Ne.X)(t,s.shape)},scale:()=>{const e=(0,fe.d)(p,h);let n=(0,fe.d)(t,e);return 1===s.rank&&(n=(0,Ie.S)(n,c)),(0,Ne.X)(n,s.shape)},offset:()=>{let e=t;return 1===s.rank&&(e=(0,Ie.S)(e,c)),(0,Ne.X)(e,s.shape)}}}},An=(0,pt.op)({unsortedSegmentSum_:function(t,e,n){const r=(0,dt._1)(t,"x","unsortedSegmentSum"),o=(0,dt._1)(e,"segmentIds","unsortedSegmentSum","int32");(0,m.hu)((0,m.GN)(n),(()=>"numSegments must be of dtype int"));const s={x:r,segmentIds:o},a={numSegments:n};return u.BV.runKernelFunc(((t,e)=>{const s=t.unsortedSegmentSum(r,o,n);return e([o]),s}),s,null,ct.Qv,a)}}),Dn={kernelName:ct.qi,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[r,o]=e,{axis:s}=n,a=(0,m.EC)(s,r.shape)[0];return{x:()=>{const e=r.shape,n=o.size,i=e.slice(0,a),u=i.length,c=e.slice(s,e.length).slice(1),l=c.length,p=On(0,u),d=On(u+1,u+1+l),h=Fn([i,[n],c]),f=(0,Ne.X)(t,h),m=(0,Ne.X)(o,[n]),g=Fn([[u],p,d]),y=(0,mn.p)(f,g);let x=An(y,m,r.shape[a]);const v=(0,Nt.LJ)(g);return x=(0,mn.p)(x,v),x},indices:()=>o}}};function On(t,e){const n=[];for(let r=t;r<e;++r)n.push(r);return n}function Fn(t){const e=[];for(let n=0;n<t.length;++n)for(let r=0;r<t[n].length;++r)e.push(t[n][r]);return e}const Bn={kernelName:ct.Ac,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>(0,ke.P)(n),b:()=>(0,ke.P)(r)}}},Pn={kernelName:ct.iJ,gradFunc:t=>({x:()=>(0,Y.p)(t,"float32")})},Mn={kernelName:ct.av,gradFunc:t=>({x:()=>(0,ke.P)(t)})},Ln={kernelName:ct.iW,gradFunc:t=>({x:()=>(0,ke.P)(t)})},Vn={kernelName:ct.r7,gradFunc:t=>({x:()=>(0,ke.P)(t)})},Wn={kernelName:ct.kU,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,ye.h)(t,(0,Ae.I)(n,1))}}},Un={kernelName:ct.Zb,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,ye.h)(t,(0,Y.p)(n,"float32"))}}},zn={kernelName:ct.qC,inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{axis:o}=n;return{logits:()=>{const e=(0,Cn.Q)(r);return(0,we.l)(t,(0,fe.d)((0,Ie.S)(t,o,!0),e))}}}},Gn=(0,pt.op)({localResponseNormalizationBackprop_:function(t,e,n,r=5,o=1,s=1,a=.5){const i={x:t,y:e,dy:n},c={depthRadius:r,bias:o,alpha:s,beta:a};return u.BV.runKernelFunc((i=>i.LRNGrad(n,t,e,r,o,s,a)),i,null,ct.vI,c)}}),Xn={kernelName:ct.eZ,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,o]=e,{depthRadius:s,bias:a,alpha:i,beta:u}=n;return{x:()=>Gn(r,o,t,s,a,i,u)}}};var Hn=n(6477);function jn(t,e,n,r){return e.rank<n.rank&&(e=(0,Ne.X)(e,Nt.rv(e.shape,r))),t.rank<n.rank&&(t=(0,Ne.X)(t,Nt.rv(t.shape,r))),{x:()=>(0,fe.d)(t,(0,Y.p)((0,Hn.D)(n,e),t.dtype))}}const Kn={kernelName:ct.Yo,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{reductionIndices:o}=r,s=e[0],a=jn(t,e[1],s,m.EC(o,s.shape));return{x:()=>a.x()}}};var qn=n(6573);const Yn={kernelName:ct.BM,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>(0,fe.d)(t,(0,Y.p)((0,Ke.b)(n,r),"float32")),b:()=>(0,fe.d)(t,(0,Y.p)((0,qn.d)(n,r),"float32"))}}},Qn=(0,pt.op)({maxPool3dBackprop_:function(t,e,n,r,o,s=[1,1,1],a,i){const c=(0,dt._1)(t,"dy","maxPool3dBackprop"),l=(0,dt._1)(e,"input","maxPool3dBackprop"),p=(0,dt._1)(n,"output","maxPool3dBackprop");let d=c,h=l,f=p,g=!1;4===l.rank&&(g=!0,d=(0,Ne.X)(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),h=(0,Ne.X)(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),f=(0,Ne.X)(p,[1,p.shape[0],p.shape[1],p.shape[2],p.shape[3]])),m.hu(5===d.rank,(()=>`Error in maxPool3dBackprop: dy must be rank 5 but got rank ${d.rank}.`)),m.hu(5===h.rank,(()=>`Error in maxPool3dBackprop: input must be rank 5 but got rank ${h.rank}.`)),m.hu(5===f.rank,(()=>`Error in maxPool3dBackprop: output must be rank 5 but got rank ${f.rank}.`)),m.hu(Tt.jT(o,s),(()=>`Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`)),null!=i&&m.hu(m.GN(a),(()=>`Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ${i} but got pad ${a}.`));const y={dy:d,input:h,output:f},x={filterSize:r,strides:o,dilations:s,pad:a,dimRoundingMode:i},v=u.BV.runKernelFunc((t=>{const e=Tt.pl(h.shape,r,o,s,a,i);return t.maxPool3dBackprop(d,h,f,e)}),y,null,ct.f,x);return g?(0,Ne.X)(v,[v.shape[1],v.shape[2],v.shape[3],v.shape[4]]):v}}),Zn={kernelName:ct.OA,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,o]=e,{filterSize:s,strides:a,dilations:i,pad:u,dimRoundingMode:c}=n,l=null==i?[1,1,1]:i;return{x:()=>Qn(t,r,o,s,a,l,u,c)}}},Jn=(0,pt.op)({maxPoolBackprop_:function(t,e,n,r,o,s,a){const i=(0,dt._1)(t,"dy","maxPoolBackprop"),c=(0,dt._1)(e,"input","maxPoolBackprop"),l=(0,dt._1)(n,"output","maxPoolBackprop");m.hu(c.rank===i.rank,(()=>`Rank of input (${c.rank}) does not match rank of dy (${i.rank})`)),m.hu(4===i.rank,(()=>`Error in maxPoolBackprop: dy must be rank 4 but got rank ${i.rank}.`)),m.hu(4===c.rank,(()=>`Error in maxPoolBackprop: input must be rank 4 but got rank ${c.rank}.`)),null!=a&&m.hu(m.GN(s),(()=>`Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`));const p={dy:i,input:c,output:l},d={filterSize:r,strides:o,pad:s,dimRoundingMode:a};return u.BV.runKernelFunc((t=>{const e=Tt.Xw(c.shape,r,o,1,s,a);return t.maxPoolBackprop(i,c,l,e)}),p,null,ct.Gv,d)}}),tr={kernelName:ct.mT,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,o]=e,{filterSize:s,strides:a,pad:i}=n;return{x:()=>Jn(t,r,o,s,a,i)}}},er={kernelName:ct.c1,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{axis:o}=r,[s,a]=e,i=jn(t,a,s,m.EC(o,s.shape));return{x:()=>i.x()}}};var nr=n(636);const rr={kernelName:ct.q8,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>(0,fe.d)(t,(0,Y.p)((0,qe.z)(n,r),"float32")),b:()=>(0,fe.d)(t,(0,Y.p)((0,nr.p)(n,r),"float32"))}}},or={kernelName:ct.jQ,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:o}=n,s=o.map((t=>t[0]));return{x:()=>(0,ue.t)(t,s,r.shape)}}};var sr=n(6943);const ar={kernelName:ct.Vb,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,o=(0,It.$N)(n.shape,r.shape);return{a:()=>{const e=(0,It.RR)(n.shape,o);return e.length>0?(0,Ne.X)((0,Ie.S)(t,e),n.shape):t},b:()=>{const e=(0,fe.d)(t,(0,xe.W)((0,sr.G)((0,ye.h)(n,r)))),s=(0,It.RR)(r.shape,o);return s.length>0?(0,Ne.X)((0,Ie.S)(e,s),r.shape):e}}}},ir={kernelName:ct.wY,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,o=(0,It.$N)(n.shape,r.shape);return{a:()=>{const e=(0,fe.d)(t,(0,Y.p)(r,"float32")),s=(0,It.RR)(n.shape,o);return s.length>0?(0,Ne.X)((0,Ie.S)(e,s),n.shape):e},b:()=>{const e=(0,fe.d)(t,(0,Y.p)(n,"float32")),s=(0,It.RR)(r.shape,o);return s.length>0?(0,Ne.X)((0,Ie.S)(e,s),r.shape):e}}}},ur={kernelName:ct.L0,gradFunc:t=>({x:()=>(0,xe.W)(t)})},cr={kernelName:ct.we,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>(0,Ct.l)(n.shape,"float32")}}},lr={kernelName:ct.qW,gradFunc:t=>({x:()=>(0,ke.P)(t)})},pr={kernelName:ct.ly,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:o}=n,s=o.map((t=>t[0]));return{x:()=>(0,ue.t)(t,s,r.shape)}}};var dr=n(2597),hr=n(3453);const fr={kernelName:ct.pe,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,r,o]=e,s=n,a=r,i=It.$N(s.shape,a.shape);return{a:()=>{const e=(0,Y.p)(a,"float32");let n=(0,fe.d)(t,(0,fe.d)(e,(0,hr.s)(s,(0,we.l)(e,(0,wt.i)(1)))));const r=It.RR(s.shape,i);return r.length>0&&(n=(0,Ie.S)(n,r)),(0,Ne.X)(n,s.shape)},b:()=>{const e=(0,nr.p)(s,0),n=(0,Qe.a)(e,(0,dr.c)(s),(0,ke.P)(s));let r=(0,fe.d)(t,(0,fe.d)(o,n));const u=It.RR(a.shape,i);return u.length>0&&(r=(0,Ie.S)(r,u)),(0,Ne.X)(r,a.shape)}}}},mr={kernelName:ct.o0,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,r]=e,o=(0,nr.p)(n,0);return{x:()=>(0,Qe.a)(o,t,(0,fe.d)(t,r)),alpha:()=>{let e=(0,Qe.a)(o,(0,ke.P)(t),(0,fe.d)(t,n));const s=(0,It.RR)(r.shape,t.shape);return s.length>0&&(e=(0,Ie.S)(e,s)),(0,Ne.X)(e,r.shape)}}}},gr={kernelName:ct.$H,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,ye.h)(t,(0,xe.W)((0,be.h)(n)))}}},yr={kernelName:ct.Sb,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=(0,fe.d)((0,qe.z)(n,6),(0,me.N)(n));return{x:()=>(0,fe.d)(t,(0,Y.p)(r,"float32"))}}},xr={kernelName:ct.qk,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,fe.d)(t,(0,Y.p)((0,me.N)(n),"float32"))}}},vr={kernelName:ct.HZ,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,Ne.X)(t,n.shape)}}},br={kernelName:ct._Y,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,o=e=>{const{alignCorners:o}=n;return e.resizeBilinearBackprop(t,r,o)},s={images:r};return{images:()=>u.BV.runKernelFunc(o,s,null,ct.zb,n)}}},wr={kernelName:ct.dp,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,o=e=>{const{alignCorners:o}=n;return e.resizeNearestNeighborBackprop(t,r,o)},s={images:r};return{images:()=>u.BV.runKernelFunc(o,s,null,ct.Hm,n)}}};var $r=n(7486);const Cr={kernelName:ct.mK,gradFunc:(t,e,n)=>{const{dims:r}=n,o=(0,m.EC)(r,t.shape);return{x:()=>(0,$r.G)(t,o)}}},Nr={kernelName:ct.e0,gradFunc:t=>({x:()=>(0,ke.P)(t)})},Ir={kernelName:ct.bV,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,xe.W)((0,ye.h)(t,(0,fe.d)((0,hr.s)(n,1.5),2)))}}};var Er=n(8651);const Tr={kernelName:ct.xc,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>(0,Y.p)((0,ke.P)(n),"float32"),t:()=>(0,fe.d)(t,(0,Y.p)(n,t.dtype)),e:()=>(0,fe.d)(t,(0,Y.p)((0,Er.h)(n),t.dtype))}}},kr={kernelName:ct.oF,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=(0,nr.p)(n,(0,wt.i)(0)),r=(0,wt.i)(Mt),o=(0,wt.i)(Lt),s=(0,fe.d)(t,o),a=(0,fe.d)((0,fe.d)(t,r),(0,Cn.Q)((0,Y.p)(n,"float32")));return(0,Qe.a)(e,s,a)}}}},Sr={kernelName:ct.a5,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,fe.d)(t,(0,fe.d)(n,(0,we.l)((0,wt.i)(1),n)))}}},Rr={kernelName:ct.i5,gradFunc:t=>({x:()=>(0,ke.P)(t)})};var _r=n(173);const Ar={kernelName:ct.RQ,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,fe.d)((0,_r.m)((0,Y.p)(n,"float32")),t)}}};var Dr=n(2699);const Or={kernelName:ct.w3,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,fe.d)((0,Dr.f)((0,Y.p)(n,"float32")),t)}}};var Fr=n(9682);const Br={kernelName:ct.p2,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{begin:o,size:s}=n,a=r.shape,[i,u]=(0,gt.parseSliceParams)(r,o,s),c=[];for(let e=0;e<t.rank;e++)c.push([i[e],a[e]-i[e]-u[e]]);return{x:()=>(0,Fr.v)(t,c)}}},Pr={kernelName:ct.Gc,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{dim:o}=n,s=(0,fe.d)(t,r);return{logits:()=>(0,we.l)(s,(0,fe.d)((0,Ie.S)(s,[o],!0),r))}}};var Mr=n(625);const Lr={kernelName:ct.MR,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,fe.d)(t,(0,Mr.X)(n))}}};var Vr=n(8441);const Wr={kernelName:ct.TQ,gradFunc:(t,e,n)=>{const{blockShape:r,paddings:o}=n;return{x:()=>(0,Vr.E)(t,r,o)}}};var Ur=n(6884);const zr={kernelName:ct.L8,gradFunc:(t,e,n)=>{const{axis:r}=n;return{x:()=>(0,Ur.z)(t,r)}}},Gr={kernelName:ct.FK,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,ye.h)(t,(0,fe.d)((0,ve._)((0,Y.p)(n,"float32")),2))}}},Xr={kernelName:ct.bK,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,fe.d)(t,(0,fe.d)((0,Y.p)(n,"float32"),2))}}},Hr={kernelName:ct._t,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,o=(0,wt.i)(2);return{a:()=>(0,fe.d)(t,(0,fe.d)(o,(0,we.l)(n,r))),b:()=>(0,fe.d)(t,(0,fe.d)(o,(0,we.l)(r,n)))}}},jr={kernelName:ct.h8,gradFunc:t=>({x:()=>(0,ke.P)(t)})},Kr={kernelName:ct.Tr,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,o=It.$N(n.shape,r.shape);return{a:()=>{let e=t;const r=It.RR(n.shape,o);return r.length>0&&(e=(0,Ie.S)(e,r)),(0,Ne.X)(e,n.shape)},b:()=>{let e=t;const n=It.RR(r.shape,o);return n.length>0&&(e=(0,Ie.S)(e,n)),(0,Ne.X)((0,xe.W)(e),r.shape)}}}};var qr=n(4917);const Yr={kernelName:ct.GB,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,o=r.shape.slice(),{axis:s}=n;(0,m.EC)(s,r.shape).forEach((t=>{o[t]=1}));const a=(0,Ne.X)(t,o),i=(0,fe.d)(a,(0,qr.i)(r.shape,"float32"));return{x:()=>i}}},Qr={kernelName:ct.sE,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,ye.h)(t,(0,be.h)((0,_r.m)(n)))}}},Zr={kernelName:ct.MI,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>(0,fe.d)((0,we.l)((0,wt.i)(1),(0,be.h)(n)),t)}}},Jr={kernelName:ct.n9,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{reps:o}=n;return{x:()=>{let e=(0,ke.P)(r);if(1===r.rank)for(let n=0;n<o[0];++n)e=(0,Ae.I)(e,(0,ue.t)(t,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<o[0];++n)for(let s=0;s<o[1];++s)e=(0,Ae.I)(e,(0,ue.t)(t,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<o[0];++n)for(let s=0;s<o[1];++s)for(let a=0;a<o[2];++a)e=(0,Ae.I)(e,(0,ue.t)(t,[n*r.shape[0],s*r.shape[1],a*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<o[0];++n)for(let s=0;s<o[1];++s)for(let a=0;a<o[2];++a)for(let i=0;i<o[3];++i)e=(0,Ae.I)(e,(0,ue.t)(t,[n*r.shape[0],s*r.shape[1],a*r.shape[2],i*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return e}}}},to={kernelName:ct.G3,gradFunc:(t,e,n)=>{const r=n,{perm:o}=r,s=Nt.LJ(o);return{x:()=>(0,mn.p)(t,s)}}};var eo=n(2991);const no={kernelName:ct.To,gradFunc:(t,e,n)=>{const r=n,{axis:o}=r;return{value:()=>(0,eo.k)(t,o)}}};var ro=n(1300),oo=n(4926),so=n(632);const ao=[ge,$e,Ce,Ee,Te,Se,Re,_e,De,Oe,Fe,Be,Me,Ve,Ue,Ge,Xe,He,je,Ze,tn,sn,rn,cn,pn,hn,gn,vn,bn,wn,$n,Nn,In,En,kn,Tn,_n,Dn,Bn,Pn,Mn,Ln,Vn,Wn,Un,zn,Xn,Kn,Kn,Yn,Zn,tr,er,rr,or,ar,ir,ur,cr,lr,pr,pr,fr,mr,gr,yr,xr,vr,br,wr,Cr,Nr,Ir,Tr,kr,Sr,Rr,Ar,Or,Br,Pr,Lr,Wr,Wr,zr,zr,Gr,Hr,Xr,jr,Kr,Yr,Qr,Zr,Jr,to,no,{kernelName:ct.Qv,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=(0,so.g)(e,(0,ke.P)(e)),r=(0,oo.I)(t,n);let o=(0,Ke.b)(e,(0,wt.i)(0,"int32"));const s=r.rank-o.rank;for(let t=0;t<s;++t)o=(0,ro.d)(o,t+1);o=(0,Ye.H)(o,(0,qr.i)(r.shape,"bool"));const a=(0,ke.P)(r);return(0,Qe.a)(o,r,a)}(t,n)}}},{kernelName:ct.Ru,gradFunc:t=>({x:()=>(0,ke.P)(t)})}];for(const t of ao)(0,lt.Li)(t);var io=n(6235);Z.es.prototype.abs=function(){return this.throwIfDisposed(),(0,io.W)(this)};var uo=n(7839);Z.es.prototype.acos=function(){return this.throwIfDisposed(),(0,uo.K)(this)};var co=n(1470);Z.es.prototype.acosh=function(){return this.throwIfDisposed(),(0,co._)(this)};var lo=n(4513),po=n(5228),ho=n(5265);const fo=(0,pt.op)({addStrict_:function(t,e){(0,bt.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,dt._1)(t,"a","addStrict"),r=(0,dt._1)(e,"b","addStrict");return m.k5(n.shape,r.shape,"Error in addStrict: "),(0,Ae.I)(n,r)}}),mo=(0,pt.op)({divStrict_:function(t,e){(0,bt.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,dt._1)(t,"a","div"),r=(0,dt._1)(e,"b","div");return m.k5(n.shape,r.shape,"Error in divideStrict: "),(0,ye.h)(n,r)}}),go=(0,pt.op)({maximumStrict_:function(t,e){(0,bt.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,dt._1)(t,"a","maximumStrict"),r=(0,dt._1)(e,"b","maximumStrict");return m.k5(n.shape,r.shape,"Error in maximumStrict: "),(0,so.g)(n,r)}}),yo=(0,pt.op)({minimumStrict_:function(t,e){(0,bt.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,dt._1)(t,"a","minimumStrict"),r=(0,dt._1)(e,"b","minimumStrict");return m.k5(n.shape,r.shape,"Error in minimumStrict: "),(0,lo.L)(n,r)}}),xo=(0,pt.op)({modStrict_:function(t,e){(0,bt.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,dt._1)(t,"a","modStrict"),r=(0,dt._1)(e,"b","modStrict");return m.k5(n.shape,r.shape,"Error in modStrict: "),(0,po.w)(n,r)}}),vo=(0,pt.op)({mulStrict_:function(t,e){(0,bt.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,dt._1)(t,"a","mul"),r=(0,dt._1)(e,"b","mul");return m.k5(n.shape,r.shape,"Error in multiplyStrict: "),(0,fe.d)(n,r)}}),bo=(0,pt.op)({powStrict_:function(t,e){return(0,bt.MX)("strict variants of ops have been deprecated and will be removed in future"),m.k5(t.shape,e.shape,"Error in powStrict: "),(0,hr.s)(t,e)}}),wo=(0,pt.op)({squaredDifferenceStrict_:function(t,e){(0,bt.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,dt._1)(t,"a","squaredDifferenceStrict"),r=(0,dt._1)(e,"b","squaredDifferenceStrict");return m.k5(n.shape,r.shape,"Error in squaredDifferenceStrict: "),(0,ho.$)(n,r)}}),$o=(0,pt.op)({subStrict_:function(t,e){(0,bt.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,dt._1)(t,"a","subStrict"),r=(0,dt._1)(e,"b","subStrict");return m.k5(n.shape,r.shape,"Error in subStrict: "),(0,we.l)(n,r)}});Z.es.prototype.addStrict=function(t){return this.throwIfDisposed(),fo(this,t)},Z.es.prototype.add=function(t){return this.throwIfDisposed(),(0,Ae.I)(this,t)};var Co=n(781);Z.es.prototype.all=function(t,e){return this.throwIfDisposed(),(0,Co.$)(this,t,e)};var No=n(2998);Z.es.prototype.any=function(t,e){return this.throwIfDisposed(),(0,No.Y)(this,t,e)};var Io=n(47);Z.es.prototype.argMax=function(t){return this.throwIfDisposed(),(0,Io.N)(this,t)};var Eo=n(7394);Z.es.prototype.argMin=function(t){return this.throwIfDisposed(),(0,Eo.v)(this,t)},Z.es.prototype.asScalar=function(){return this.throwIfDisposed(),(0,m.hu)(1===this.size,(()=>"The array must have only 1 element.")),(0,Ne.X)(this,[])},Z.es.prototype.asType=function(t){return this.throwIfDisposed(),(0,Y.p)(this,t)},Z.es.prototype.as1D=function(){return this.throwIfDisposed(),(0,Ne.X)(this,[this.size])},Z.es.prototype.as2D=function(t,e){return this.throwIfDisposed(),(0,Ne.X)(this,[t,e])},Z.es.prototype.as3D=function(t,e,n){return this.throwIfDisposed(),(0,Ne.X)(this,[t,e,n])},Z.es.prototype.as4D=function(t,e,n,r){return this.throwIfDisposed(),(0,Ne.X)(this,[t,e,n,r])},Z.es.prototype.as5D=function(t,e,n,r,o){return this.throwIfDisposed(),(0,Ne.X)(this,[t,e,n,r,o])};var To=n(2421);Z.es.prototype.asin=function(){return this.throwIfDisposed(),(0,To.Z)(this)};var ko=n(1891);Z.es.prototype.asinh=function(){return this.throwIfDisposed(),(0,ko.V)(this)};var So=n(7037);Z.es.prototype.atan=function(){return this.throwIfDisposed(),(0,So.z)(this)};var Ro=n(9812);Z.es.prototype.atan2=function(t){return this.throwIfDisposed(),(0,Ro.f)(this,t)};var _o=n(369);Z.es.prototype.atanh=function(){return this.throwIfDisposed(),(0,_o.C)(this)};var Ao=n(5176);Z.es.prototype.avgPool=function(t,e,n,r){return this.throwIfDisposed(),(0,Ao.w)(this,t,e,n,r)},Z.es.prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),(0,Vr.E)(this,t,e)};var Do=n(7505);Z.es.prototype.batchNorm=function(t,e,n,r,o){return this.throwIfDisposed(),(0,Do.t)(this,t,e,n,r,o)};var Oo=n(8247);Z.es.prototype.broadcastTo=function(t){return this.throwIfDisposed(),(0,Oo.U)(this,t)},Z.es.prototype.cast=function(t){return this.throwIfDisposed(),(0,Y.p)(this,t)};var Fo=n(6825);Z.es.prototype.ceil=function(){return this.throwIfDisposed(),(0,Fo.m)(this)};var Bo=n(2279);Z.es.prototype.clipByValue=function(t,e){return this.throwIfDisposed(),(0,Bo.i)(this,t,e)},Z.es.prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof Z.es&&(t=[t]),(0,Ur.z)([this,...t],e)};var Po=n(1355);Z.es.prototype.conv1d=function(t,e,n,r,o,s){return this.throwIfDisposed(),(0,Po.P)(this,t,e,n,r,o,s)};var Mo=n(1405);Z.es.prototype.conv2dTranspose=function(t,e,n,r,o){return this.throwIfDisposed(),(0,Mo.b)(this,t,e,n,r,o)},Z.es.prototype.conv2d=function(t,e,n,r,o,s){return this.throwIfDisposed(),(0,on.T)(this,t,e,n,r,o,s)},Z.es.prototype.cos=function(){return this.throwIfDisposed(),(0,_r.m)(this)},Z.es.prototype.cosh=function(){return this.throwIfDisposed(),(0,Dr.f)(this)},Z.es.prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),(0,fn.z)(this,t,e,n)};var Lo=n(9112);Z.es.prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),(0,Lo.n)(this,t,e)};var Vo=n(4718);Z.es.prototype.depthwiseConv2D=function(t,e,n,r,o,s){return(0,bt.MX)("depthwiseConv2D is deprecated, use depthwiseConv2d instead"),this.throwIfDisposed(),(0,Vo.B)(this,t,e,n,r,o,s)},Z.es.prototype.depthwiseConv2d=function(t,e,n,r,o,s){return this.throwIfDisposed(),(0,Vo.B)(this,t,e,n,r,o,s)};var Wo=n(557);Z.es.prototype.dilation2d=function(t,e,n,r,o){return this.throwIfDisposed(),(0,Wo.W)(this,t,e,n,r,o)};var Uo=n(9322);Z.es.prototype.divNoNan=function(t){return this.throwIfDisposed(),(0,Uo.N)(this,t)},Z.es.prototype.divStrict=function(t){return this.throwIfDisposed(),mo(this,t)},Z.es.prototype.div=function(t){return this.throwIfDisposed(),(0,ye.h)(this,t)};const zo=(0,pt.op)({dot_:function(t,e){const n=(0,dt._1)(t,"t1","dot"),r=(0,dt._1)(e,"t2","dot");m.hu(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));const o=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(m.hu(o===s,(()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${s}.`)),1===n.rank&&1===r.rank){const t=(0,Ne.X)(n,[1,-1]),e=(0,Ne.X)(r,[-1,1]),o=(0,We.O)(t,e);return(0,Ne.X)(o,[])}if(1===n.rank&&2===r.rank){const t=(0,Ne.X)(n,[1,-1]),e=(0,Ne.X)(r,[r.shape[0],r.shape[1]]),o=(0,We.O)(t,e);return(0,Ne.X)(o,[o.size])}if(2===n.rank&&1===r.rank){const t=(0,Ne.X)(r,[-1,1]),e=(0,We.O)(n,t);return(0,Ne.X)(e,[e.size])}{const t=(0,Ne.X)(r,[r.shape[0],r.shape[1]]);return(0,We.O)(n,t)}}});Z.es.prototype.dot=function(t){return this.throwIfDisposed(),zo(this,t)};var Go=n(3233);Z.es.prototype.elu=function(){return this.throwIfDisposed(),(0,Go.p)(this)};var Xo=n(6500);const Ho=(0,pt.op)({equalStrict_:function(t,e){(0,bt.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,dt._1)(t,"a","equalStrict"),r=(0,dt._1)(e,"b","equalStrict");return(0,m.k5)(n.shape,r.shape,"Error in equalStrict: "),(0,Hn.D)(n,r)}}),jo=(0,pt.op)({greaterEqualStrict_:function(t,e){(0,bt.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,dt._1)(t,"a","greaterEqualStrict"),r=(0,dt._1)(e,"b","greaterEqualStrict");return(0,m.k5)(n.shape,r.shape,"Error in greaterEqualStrict: "),(0,Ke.b)(n,r)}}),Ko=(0,pt.op)({greaterStrict_:function(t,e){(0,bt.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,dt._1)(t,"a","greaterStrict"),r=(0,dt._1)(e,"b","greaterStrict");return(0,m.k5)(n.shape,r.shape,"Error in greaterStrict: "),(0,nr.p)(n,r)}}),qo=(0,pt.op)({lessEqualStrict_:function(t,e){(0,bt.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,dt._1)(t,"a","lessEqualStrict"),r=(0,dt._1)(e,"b","lessEqualStrict");return(0,m.k5)(n.shape,r.shape,"Error in lessEqualStrict: "),(0,qe.z)(n,r)}}),Yo=(0,pt.op)({lessStrict_:function(t,e){(0,bt.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,dt._1)(t,"a","lessStrict"),r=(0,dt._1)(e,"b","lessStrict");return(0,m.k5)(n.shape,r.shape,"Error in lessStrict: "),(0,qn.d)(n,r)}}),Qo=(0,pt.op)({notEqualStrict_:function(t,e){(0,bt.MX)("strict variants of ops have been deprecated and will be removed in future");const n=(0,dt._1)(t,"a","notEqualStrict"),r=(0,dt._1)(e,"b","notEqualStrict");return(0,m.k5)(n.shape,r.shape,"Error in notEqualStrict: "),(0,Xo.Q)(n,r)}});Z.es.prototype.equalStrict=function(t){return this.throwIfDisposed(),Ho(this,t)},Z.es.prototype.equal=function(t){return this.throwIfDisposed(),(0,Hn.D)(this,t)};var Zo=n(4650);Z.es.prototype.erf=function(){return this.throwIfDisposed(),(0,Zo.q)(this)},Z.es.prototype.exp=function(){return this.throwIfDisposed(),(0,Cn.Q)(this)},Z.es.prototype.expandDims=function(t){return this.throwIfDisposed(),(0,ro.d)(this,t)};var Jo=n(3426);Z.es.prototype.expm1=function(){return this.throwIfDisposed(),(0,Jo.t)(this)};var ts=n(7020);Z.es.prototype.fft=function(){return this.throwIfDisposed(),(0,ts.k)(this)},Z.es.prototype.flatten=function(){return this.throwIfDisposed(),(0,Ne.X)(this,[this.size])},Z.es.prototype.floor=function(){return this.throwIfDisposed(),(0,sr.G)(this)};var es=n(9165);Z.es.prototype.floorDiv=function(t){return this.throwIfDisposed(),(0,es.q)(this,t)},Z.es.prototype.gather=function(t,e){return this.throwIfDisposed(),(0,oo.I)(this,t,e)},Z.es.prototype.greaterEqualStrict=function(t){return this.throwIfDisposed(),jo(this,t)},Z.es.prototype.greaterEqual=function(t){return this.throwIfDisposed(),(0,Ke.b)(this,t)},Z.es.prototype.greaterStrict=function(t){return this.throwIfDisposed(),Ko(this,t)},Z.es.prototype.greater=function(t){return this.throwIfDisposed(),(0,nr.p)(this,t)};var ns=n(8447);Z.es.prototype.ifft=function(){return this.throwIfDisposed(),(0,ns.S)(this)};var rs=n(4415);Z.es.prototype.irfft=function(){return this.throwIfDisposed(),(0,rs.w)(this)};const os=(0,pt.op)({isFinite_:function(t){const e=(0,dt._1)(t,"x","isFinite"),n={x:e};return u.BV.runKernelFunc((t=>t.isFinite(e)),n,null,ct.av)}});Z.es.prototype.isFinite=function(){return this.throwIfDisposed(),os(this)};const ss=(0,pt.op)({isInf_:function(t){const e=(0,dt._1)(t,"x","isInf"),n={x:e};return u.BV.runKernelFunc((t=>t.isInf(e)),n,null,ct.iW)}});Z.es.prototype.isInf=function(){return this.throwIfDisposed(),ss(this)};const as=(0,pt.op)({isNaN_:function(t){const e=(0,dt._1)(t,"x","isNaN"),n={x:e};return u.BV.runKernelFunc((t=>t.isNaN(e)),n,null,ct.r7)}});Z.es.prototype.isNaN=function(){return this.throwIfDisposed(),as(this)};var is=n(9133);Z.es.prototype.leakyRelu=function(t){return this.throwIfDisposed(),(0,is.h)(this,t)},Z.es.prototype.lessEqualStrict=function(t){return this.throwIfDisposed(),qo(this,t)},Z.es.prototype.lessEqual=function(t){return this.throwIfDisposed(),(0,qe.z)(this,t)},Z.es.prototype.lessStrict=function(t){return this.throwIfDisposed(),Yo(this,t)},Z.es.prototype.less=function(t){return this.throwIfDisposed(),(0,qn.d)(this,t)};var us=n(9648);Z.es.prototype.localResponseNormalization=function(t,e,n,r){return this.throwIfDisposed(),(0,us.G)(this,t,e,n,r)};var cs=n(633),ls=n(3694);const ps=(0,pt.op)({logSigmoid_:function(t){const e=(0,dt._1)(t,"x","logSigmoid");return(0,cs.cb)((t=>({value:(0,xe.W)((0,ls.W)((0,xe.W)(t))),gradFunc:e=>(0,fe.d)(e,(0,Mr.X)((0,xe.W)(t)))})))(e)}});Z.es.prototype.logSigmoid=function(){return this.throwIfDisposed(),ps(this)};var ds=n(1510);Z.es.prototype.logSoftmax=function(t){return this.throwIfDisposed(),(0,ds.C)(this,t)};var hs=n(1391);Z.es.prototype.logSumExp=function(t,e){return this.throwIfDisposed(),(0,hs.l)(this,t,e)},Z.es.prototype.log=function(){return this.throwIfDisposed(),(0,dr.c)(this)};var fs=n(7474);Z.es.prototype.log1p=function(){return this.throwIfDisposed(),(0,fs.K)(this)},Z.es.prototype.logicalAnd=function(t){return this.throwIfDisposed(),(0,Ye.H)(this,t)},Z.es.prototype.logicalNot=function(){return this.throwIfDisposed(),(0,Er.h)(this)};var ms=n(5750);Z.es.prototype.logicalOr=function(t){return this.throwIfDisposed(),(0,ms.K)(this,t)};const gs=(0,pt.op)({logicalXor_:function(t,e){const n=(0,dt._1)(t,"a","logicalXor","bool"),r=(0,dt._1)(e,"b","logicalXor","bool");return(0,It.$N)(n.shape,r.shape),(0,Ye.H)((0,ms.K)(t,e),(0,Er.h)((0,Ye.H)(t,e)))}});Z.es.prototype.logicalXor=function(t){return this.throwIfDisposed(),gs(this,t)},Z.es.prototype.matMul=function(t,e,n){return this.throwIfDisposed(),(0,We.O)(this,t,e,n)};var ys=n(1174);Z.es.prototype.maxPool=function(t,e,n,r){return this.throwIfDisposed(),(0,ys._)(this,t,e,n,r)};var xs=n(3307);Z.es.prototype.max=function(t,e){return this.throwIfDisposed(),(0,xs.F)(this,t,e)},Z.es.prototype.maximumStrict=function(t){return this.throwIfDisposed(),go(this,t)},Z.es.prototype.maximum=function(t){return this.throwIfDisposed(),(0,so.g)(this,t)};var vs=n(5130);Z.es.prototype.mean=function(t,e){return this.throwIfDisposed(),(0,vs.J)(this,t,e)};var bs=n(5735);Z.es.prototype.min=function(t,e){return this.throwIfDisposed(),(0,bs.V)(this,t,e)},Z.es.prototype.minimumStrict=function(t){return this.throwIfDisposed(),yo(this,t)},Z.es.prototype.minimum=function(t){return this.throwIfDisposed(),(0,lo.L)(this,t)};var ws=n(1483);Z.es.prototype.mirrorPad=function(t,e){return this.throwIfDisposed(),(0,ws.V)(this,t,e)},Z.es.prototype.modStrict=function(t){return this.throwIfDisposed(),xo(this,t)},Z.es.prototype.mod=function(t){return this.throwIfDisposed(),(0,po.w)(this,t)},Z.es.prototype.mulStrict=function(t){return this.throwIfDisposed(),vo(this,t)},Z.es.prototype.mul=function(t){return this.throwIfDisposed(),(0,fe.d)(this,t)},Z.es.prototype.neg=function(){return this.throwIfDisposed(),(0,xe.W)(this)};var $s=n(3561);Z.es.prototype.norm=function(t,e,n){return this.throwIfDisposed(),(0,$s.K)(this,t,e,n)},Z.es.prototype.notEqualStrict=function(t){return this.throwIfDisposed(),Qo(this,t)},Z.es.prototype.notEqual=function(t){return this.throwIfDisposed(),(0,Xo.Q)(this,t)};var Cs=n(6708);Z.es.prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),(0,Cs.l)(this,t,e,n)};var Ns=n(7846);Z.es.prototype.onesLike=function(){return this.throwIfDisposed(),(0,Ns.J)(this)},Z.es.prototype.pad=function(t,e){return this.throwIfDisposed(),(0,Fr.v)(this,t,e)};const Is=(0,pt.op)({pool_:function(t,e,n,r,o,s){null==o&&(o=[1,1]),null==s&&(s=1),0===r&&(r="valid");const a=(0,dt._1)(t,"x","maxPool");let i=a,u=!1;3===a.rank&&(u=!0,i=(0,Ne.X)(a,[1,a.shape[0],a.shape[1],a.shape[2]])),m.hu(Tt.jT(s,o),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${o}'`));const c=Tt.Xw(i.shape,e,s,o,r),l=[c.dilationHeight,c.dilationWidth];let p;p="same"===r?function(t,e){const n=t.map(((t,n)=>t+(t-1)*(e[n]-1))).map((t=>t-1)),r=n.map((t=>Math.floor(t/2))),o=n.map(((t,e)=>t-r[e]));return n.map(((t,e)=>[r[e],o[e]]))}([c.filterHeight,c.filterWidth],l):[[0,0],[0,0]];const d=1===l[0]&&1===l[1],[h,f]=function(t,e,n){const r=n.map((t=>t[0])),o=n.map((t=>t[1])),s=t.concat(r,o),a=e.map(((t,e)=>(t-s[e]%t)%t)),i=o.map(((t,e)=>t+a[e]));return[e.map(((t,e)=>[r[e],i[e]])),e.map(((t,e)=>[0,a[e]]))]}([c.inHeight,c.inWidth],l,p),g=d?r:"valid",y=d?i:(0,ze.f)(i,l,h),x=("avg"===n?()=>(0,Ao.w)(y,e,s,g):()=>(0,ys._)(y,e,s,g))(),v=d?x:(0,Vr.E)(x,l,f);return u?(0,Ne.X)(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});Z.es.prototype.pool=function(t,e,n,r,o){return this.throwIfDisposed(),Is(this,t,e,n,r,o)},Z.es.prototype.powStrict=function(t){return this.throwIfDisposed(),bo(this,t)},Z.es.prototype.pow=function(t){return this.throwIfDisposed(),(0,hr.s)(this,t)};var Es=n(8151);Z.es.prototype.prelu=function(t){return this.throwIfDisposed(),(0,Es.A)(this,t)};var Ts=n(9451);Z.es.prototype.prod=function(t,e){return this.throwIfDisposed(),(0,Ts.W)(this,t,e)};var ks=n(9036);Z.es.prototype.reciprocal=function(){return this.throwIfDisposed(),(0,ks.M)(this)};var Ss=n(7409);Z.es.prototype.relu=function(){return this.throwIfDisposed(),(0,Ss.U)(this)};var Rs=n(3582);Z.es.prototype.relu6=function(){return this.throwIfDisposed(),(0,Rs.b)(this)},Z.es.prototype.reshapeAs=function(t){return this.throwIfDisposed(),(0,Ne.X)(this,t.shape)},Z.es.prototype.reshape=function(t){return this.throwIfDisposed(),(0,Ne.X)(this,t)};var _s=n(3305);Z.es.prototype.resizeBilinear=function(t,e){return this.throwIfDisposed(),(0,_s.I)(this,t,e)};var As=n(5098);Z.es.prototype.resizeNearestNeighbor=function(t,e){return this.throwIfDisposed(),(0,As.j)(this,t,e)},Z.es.prototype.reverse=function(t){return this.throwIfDisposed(),(0,$r.G)(this,t)};var Ds=n(3710);Z.es.prototype.rfft=function(){return this.throwIfDisposed(),(0,Ds.Q)(this)};var Os=n(7809);Z.es.prototype.round=function(){return this.throwIfDisposed(),(0,Os.N)(this)},Z.es.prototype.rsqrt=function(){return this.throwIfDisposed(),(0,Sn.b)(this)};var Fs=n(5503);Z.es.prototype.selu=function(){return this.throwIfDisposed(),(0,Fs.U)(this)};const Bs=(0,pt.op)({separableConv2d_:function(t,e,n,r,o,s=[1,1],a="NHWC"){const i=(0,dt._1)(t,"x","separableConv2d"),u=(0,dt._1)(e,"depthwiseFilter","separableConv2d"),c=(0,dt._1)(n,"pointwiseFilter","separableConv2d");let l=i,p=!1;if(3===i.rank&&(p=!0,l=(0,Ne.X)(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===a)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");m.hu(4===l.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${l.rank}.`)),m.hu(4===u.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`)),m.hu(4===c.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`)),m.hu(1===c.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`)),m.hu(1===c.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`));const d=u.shape[2],h=u.shape[3];m.hu(c.shape[2]===d*h,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*h}, but got ${c.shape[2]}.`));const f=(0,Vo.B)(l,u,r,o,a,s),g=(0,on.T)(f,c,1,"valid",a);return p?(0,Ne.X)(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});Z.es.prototype.separableConv2d=function(t,e,n,r,o,s){return this.throwIfDisposed(),Bs(this,t,e,n,r,o,s)},Z.es.prototype.sigmoid=function(){return this.throwIfDisposed(),(0,Mr.X)(this)};var Ps=n(4434);Z.es.prototype.sign=function(){return this.throwIfDisposed(),(0,Ps.X)(this)},Z.es.prototype.sin=function(){return this.throwIfDisposed(),(0,ln.O)(this)},Z.es.prototype.sinh=function(){return this.throwIfDisposed(),(0,dn.R)(this)},Z.es.prototype.slice=function(t,e){return this.throwIfDisposed(),(0,ue.t)(this,t,e)};var Ms=n(682);Z.es.prototype.softmax=function(t){return this.throwIfDisposed(),(0,Ms.X)(this,t)},Z.es.prototype.softplus=function(){return this.throwIfDisposed(),(0,ls.W)(this)},Z.es.prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),(0,ze.f)(this,t,e)},Z.es.prototype.split=function(t,e){return this.throwIfDisposed(),(0,Je.V)(this,t,e)},Z.es.prototype.sqrt=function(){return this.throwIfDisposed(),(0,ve._)(this)},Z.es.prototype.square=function(){return this.throwIfDisposed(),(0,be.h)(this)},Z.es.prototype.squaredDifference=function(t){return this.throwIfDisposed(),(0,ho.$)(this,t)},Z.es.prototype.squaredDifferenceStrict=function(t){return this.throwIfDisposed(),wo(this,t)};var Ls=n(9590);Z.es.prototype.squeeze=function(t){return this.throwIfDisposed(),(0,Ls.L)(this,t)},Z.es.prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof Z.es?[this,t]:[this,...t];return(0,eo.k)(n,e)},Z.es.prototype.step=function(t){return this.throwIfDisposed(),(0,me.N)(this,t)};var Vs=n(5158);Z.es.prototype.stridedSlice=function(t,e,n,r,o,s,a,i){return this.throwIfDisposed(),(0,Vs.N)(this,t,e,n,r,o,s,a,i)},Z.es.prototype.subStrict=function(t){return this.throwIfDisposed(),$o(this,t)},Z.es.prototype.sub=function(t){return this.throwIfDisposed(),(0,we.l)(this,t)},Z.es.prototype.sum=function(t,e){return this.throwIfDisposed(),(0,Ie.S)(this,t,e)};var Ws=n(1173);Z.es.prototype.tan=function(){return this.throwIfDisposed(),(0,Ws.O)(this)};var Us=n(1869);Z.es.prototype.tanh=function(){return this.throwIfDisposed(),(0,Us.A)(this)},Z.es.prototype.tile=function(t){return this.throwIfDisposed(),(0,Rn.G)(this,t)},Z.es.prototype.toBool=function(){return this.throwIfDisposed(),(0,Y.p)(this,"bool")},Z.es.prototype.toFloat=function(){return this.throwIfDisposed(),(0,Y.p)(this,"float32")},Z.es.prototype.toInt=function(){return this.throwIfDisposed(),(0,Y.p)(this,"int32")};var zs=n(3243);Z.es.prototype.topk=function(t,e){return this.throwIfDisposed(),(0,zs.h)(this,t,e)},Z.es.prototype.transpose=function(t){return this.throwIfDisposed(),(0,mn.p)(this,t)};var Gs=n(9608);Z.es.prototype.unique=function(t){return this.throwIfDisposed(),(0,Gs.T)(this,t)},Z.es.prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),An(this,t,e)};var Xs=n(4136);Z.es.prototype.unstack=function(t){return this.throwIfDisposed(),(0,Xs.H)(this,t)},Z.es.prototype.where=function(t,e){return this.throwIfDisposed(),(0,Qe.a)(t,this,e)},Z.es.prototype.zerosLike=function(){return this.throwIfDisposed(),(0,ke.P)(this)}},9121:function(t,e,n){"use strict";n.d(e,{SY:function(){return r},VG:function(){return o},Sp:function(){return s},mm:function(){return a},Xz:function(){return i},oT:function(){return u},IK:function(){return c},sJ:function(){return l},aJ:function(){return p},M2:function(){return d},qw:function(){return h},jM:function(){return f},Oy:function(){return m},QC:function(){return g},Jh:function(){return y},xt:function(){return x},_k:function(){return v},DC:function(){return b},XL:function(){return w},zw:function(){return $},Ly:function(){return C},RF:function(){return N},gJ:function(){return I},xn:function(){return E},Zz:function(){return T},Eh:function(){return k},mh:function(){return S},wU:function(){return R},wm:function(){return _},x1:function(){return A},o2:function(){return D},ik:function(){return O},mc:function(){return F},TR:function(){return B},iH:function(){return P},Vc:function(){return M},T0:function(){return L},ci:function(){return V},sL:function(){return W},y7:function(){return U},p4:function(){return z},ek:function(){return G},Vn:function(){return X},ZC:function(){return H},SX:function(){return j},HE:function(){return K},Om:function(){return q},hd:function(){return Y},NE:function(){return Q},Y0:function(){return Z},vw:function(){return J},de:function(){return tt},Uy:function(){return et},OR:function(){return nt},je:function(){return rt},sH:function(){return ot},qi:function(){return st},q1:function(){return at},iZ:function(){return it},Ac:function(){return ut},iJ:function(){return ct},Qg:function(){return lt},J_:function(){return pt},av:function(){return dt},iW:function(){return ht},r7:function(){return ft},vt:function(){return mt},CA:function(){return gt},e7:function(){return yt},Zb:function(){return xt},kU:function(){return vt},PY:function(){return bt},Vf:function(){return wt},MZ:function(){return $t},qC:function(){return Ct},eZ:function(){return Nt},vI:function(){return It},Yo:function(){return Et},BM:function(){return Tt},mT:function(){return kt},Gv:function(){return St},OA:function(){return Rt},f:function(){return _t},vF:function(){return At},q2:function(){return Dt},c1:function(){return Ot},q8:function(){return Ft},jQ:function(){return Bt},Vb:function(){return Pt},wY:function(){return Mt},L0:function(){return Lt},yQ:function(){return Vt},uv:function(){return Wt},cy:function(){return Ut},W0:function(){return zt},qW:function(){return Gt},we:function(){return Xt},ly:function(){return Ht},pe:function(){return jt},o0:function(){return Kt},Dl:function(){return qt},e6:function(){return Yt},xJ:function(){return Qt},$H:function(){return Zt},qk:function(){return Jt},HZ:function(){return te},dp:function(){return ee},Hm:function(){return ne},_Y:function(){return re},zb:function(){return oe},Sb:function(){return se},mK:function(){return ae},e0:function(){return ie},bV:function(){return ue},xQ:function(){return ce},xc:function(){return le},oF:function(){return pe},p2:function(){return de},RQ:function(){return he},w3:function(){return fe},i5:function(){return me},a5:function(){return ge},MR:function(){return ye},FK:function(){return xe},GB:function(){return ve},TQ:function(){return be},L8:function(){return we},Gc:function(){return $e},_t:function(){return Ce},bK:function(){return Ne},Tr:function(){return Ie},D2:function(){return Ee},m2:function(){return Te},sE:function(){return ke},MI:function(){return Se},n9:function(){return Re},cW:function(){return _e},G3:function(){return Ae},kp:function(){return De},To:function(){return Oe},Qv:function(){return Fe},Ru:function(){return Be},h8:function(){return Pe},eB:function(){return Me},b9:function(){return Le},us:function(){return Ve},_V:function(){return We},lu:function(){return Ue}});const r="Abs",o="Acos",s="Acosh",a="Add",i="AddN",u="All",c="Any",l="ArgMax",p="ArgMin",d="Asin",h="Asinh",f="Atan",m="Atanh",g="Atan2",y="AvgPool",x="AvgPoolBackprop",v="AvgPool3D",b="AvgPool3DBackprop",w="BatchMatMul",$="BatchToSpaceND",C="BroadcastTo",N="Cast",I="Ceil",E="ClipByValue",T="Complex",k="Concat",S="Conv2D",R="Conv2DBackpropFilter",_="Conv2DBackpropInput",A="Conv3D",D="Conv3DBackpropFilterV2",O="Conv3DBackpropInputV2",F="Cos",B="Cosh",P="Cumsum",M="CropAndResize",L="DepthToSpace",V="DepthwiseConv2dNative",W="DepthwiseConv2dNativeBackpropFilter",U="DepthwiseConv2dNativeBackpropInput",z="Dilation2D",G="Dilation2DBackpropInput",X="Dilation2DBackpropFilter",H="Div",j="Elu",K="EluGrad",q="Erf",Y="Equal",Q="Exp",Z="Expm1",J="FFT",tt="Fill",et="FlipLeftRight",nt="Floor",rt="FloorDiv",ot="FusedBatchNorm",st="GatherV2",at="GatherNd",it="Greater",ut="GreaterEqual",ct="Identity",lt="IFFT",pt="Imag",dt="IsFinite",ht="IsInf",ft="IsNan",mt="Less",gt="LessEqual",yt="LinSpace",xt="Log",vt="Log1p",bt="LogicalAnd",wt="LogicalNot",$t="LogicalOr",Ct="LogSoftmax",Nt="LRN",It="LRNBackprop",Et="Max",Tt="Maximum",kt="MaxPool",St="MaxPoolBackprop",Rt="MaxPool3D",_t="MaxPool3DBackprop",At="MaxPoolWithArgmax",Dt="Mean",Ot="Min",Ft="Minimum",Bt="MirrorPad",Pt="Mod",Mt="Multiply",Lt="Negate",Vt="NotEqual",Wt="NonMaxSuppressionV3",Ut="NonMaxSuppressionV4",zt="NonMaxSuppressionV5",Gt="OnesLike",Xt="OneHot",Ht="PadV2",jt="Pow",Kt="Prelu",qt="Prod",Yt="Range",Qt="Real",Zt="Reciprocal",Jt="Relu",te="Reshape",ee="ResizeNearestNeighbor",ne="ResizeNearestNeighborGrad",re="ResizeBilinear",oe="ResizeBilinearGrad",se="Relu6",ae="Reverse",ie="Round",ue="Rsqrt",ce="ScatterNd",le="SelectV2",pe="Selu",de="Slice",he="Sin",fe="Sinh",me="Sign",ge="Sigmoid",ye="Softplus",xe="Sqrt",ve="Sum",be="SpaceToBatchND",we="SplitV",$e="Softmax",Ce="SquaredDifference",Ne="Square",Ie="Sub",Ee="SparseToDense",Te="StridedSlice",ke="Tan",Se="Tanh",Re="Tile",_e="TopK",Ae="Transpose",De="Unique",Oe="Unpack",Fe="UnsortedSegmentSum",Be="ZerosLike",Pe="Step",Me="FromPixels",Le="RotateWithOffset",Ve="_FusedMatMul",We="FusedConv2D",Ue="FusedDepthwiseConv2D"},6151:function(t,e,n){"use strict";n.d(e,{pI:function(){return i},uk:function(){return u},tr:function(){return c},wC:function(){return l},Li:function(){return p}});var r=n(2885),o=n(5938);const s=(0,o.R)("kernelRegistry",(()=>new Map)),a=(0,o.R)("gradRegistry",(()=>new Map));function i(t,e){const n=d(t,e);return s.get(n)}function u(t){return a.get(t)}function c(t){const e=s.entries(),n=[];for(;;){const{done:r,value:o}=e.next();if(r)break;const[s,a]=o,[i]=s.split("_");i===t&&n.push(a)}return n}function l(t){const{kernelName:e,backendName:n}=t,r=d(e,n);s.has(r)&&console.warn(`The kernel '${e}' for backend '${n}' is already registered`),s.set(r,t)}function p(t){const{kernelName:e}=t;a.has(e)&&(0,r.OB)().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${e}'`),a.set(e,t)}function d(t,e){return`${e}_${t}`}},6235:function(t,e,n){"use strict";n.d(e,{W:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({abs_:function(t){const e=(0,s._1)(t,"x","abs"),n={x:e};return r.BV.runKernelFunc(((t,n)=>(n([e]),"complex64"===e.dtype?t.complexAbs(e):t.abs(e))),n,null,o.SY)}})},7839:function(t,e,n){"use strict";n.d(e,{K:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({acos_:function(t){const e=(0,s._1)(t,"x","acos"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.acos(e);return n([e]),r}),n,null,o.VG)}})},1470:function(t,e,n){"use strict";n.d(e,{_:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({acosh_:function(t){const e=(0,s._1)(t,"x","acosh"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.acosh(e);return n([e]),r}),n,null,o.Sp)}})},6407:function(t,e,n){"use strict";n.d(e,{I:function(){return i}});var r=n(7097),o=n(9121),s=n(747),a=n(3740);const i=(0,n(2668).op)({add_:function(t,e){let n=(0,a._1)(t,"a","add"),i=(0,a._1)(e,"b","add");[n,i]=(0,s.T_)(n,i);const u={a:n,b:i};return r.BV.runKernelFunc(((t,e)=>{const r=t.add(n,i);return e([n,i]),r}),u,null,o.mm)}})},781:function(t,e,n){"use strict";n.d(e,{$:function(){return p}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(3591),u=n(2668),c=n(4968),l=n(9065);const p=(0,u.op)({all_:function(t,e=null,n=!1){let u=(0,s._1)(t,"x","all","bool");const p={x:u},d={axis:e,keepDims:n};return r.BV.runKernelFunc((t=>{const r=(0,a.EC)(e,u.shape);let o=r;const s=(0,i.Q3)(o,u.rank);null!=s&&(u=(0,l.p)(u,s),o=(0,i.sY)(o.length,u.rank));const p=t.all(u,o);if(n){const t=(0,i.rv)(p.shape,r);return(0,c.X)(p,t)}return p}),p,null,o.oT,d)}})},2998:function(t,e,n){"use strict";n.d(e,{Y:function(){return p}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(3591),u=n(2668),c=n(4968),l=n(9065);const p=(0,u.op)({any_:function(t,e=null,n=!1){let u=(0,s._1)(t,"x","any","bool");const p={x:u},d={axis:e,keepDims:n};return r.BV.runKernelFunc((t=>{const r=(0,a.EC)(e,u.shape);let o=r;const s=(0,i.Q3)(o,u.rank);null!=s&&(u=(0,l.p)(u,s),o=(0,i.sY)(o.length,u.rank));const p=t.any(u,o);if(n){const t=(0,i.rv)(p.shape,r);return(0,c.X)(p,t)}return p}),p,null,o.IK,d)}})},47:function(t,e,n){"use strict";n.d(e,{N:function(){return l}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(3591),u=n(2668),c=n(9065);const l=(0,u.op)({argMax_:function(t,e=0){let n=(0,s._1)(t,"x","argMax");const u={x:n},l={axis:e};return r.BV.runKernelFunc(((t,r)=>{r([n]);let o=a.EC(e,n.shape);const s=i.Q3(o,n.rank);return null!=s&&(n=(0,c.p)(n,s),o=i.sY(o.length,n.rank)),t.argMax(n,o[0])}),u,null,o.sJ,l)}})},7394:function(t,e,n){"use strict";n.d(e,{v:function(){return l}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(3591),u=n(2668),c=n(9065);const l=(0,u.op)({argMin_:function(t,e=0){let n=(0,s._1)(t,"x","argMin");const u={x:n},l={axis:e};return r.BV.runKernelFunc(((t,r)=>{r([n]),null==e&&(e=0);let o=a.EC(e,n.shape);const s=i.Q3(o,n.rank);return null!=s&&(n=(0,c.p)(n,s),o=i.sY(o.length,n.rank)),t.argMin(n,o[0])}),u,null,o.aJ,l)}})},2421:function(t,e,n){"use strict";n.d(e,{Z:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({asin_:function(t){const e=(0,s._1)(t,"x","asin"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.asin(e);return n([e]),r}),n,null,o.M2)}})},1891:function(t,e,n){"use strict";n.d(e,{V:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({asinh_:function(t){const e=(0,s._1)(t,"x","asinh"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.asinh(e);return n([e]),r}),n,null,o.qw)}})},7037:function(t,e,n){"use strict";n.d(e,{z:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({atan_:function(t){const e=(0,s._1)(t,"x","atan"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.atan(e);return n([e]),r}),n,null,o.jM)}})},9812:function(t,e,n){"use strict";n.d(e,{f:function(){return i}});var r=n(7097),o=n(9121),s=n(747),a=n(3740);const i=(0,n(2668).op)({atan2_:function(t,e){let n=(0,a._1)(t,"a","atan2"),i=(0,a._1)(e,"b","atan2");[n,i]=(0,s.T_)(n,i);const u={a:n,b:i};return r.BV.runKernelFunc(((t,e)=>{const r=t.atan2(n,i);return e([n,i]),r}),u,null,o.QC)}})},369:function(t,e,n){"use strict";n.d(e,{C:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({atanh_:function(t){const e=(0,s._1)(t,"x","atanh"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.atanh(e);return n([e]),r}),n,null,o.Oy)}})},5176:function(t,e,n){"use strict";n.d(e,{w:function(){return p}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(2271),u=n(2582),c=n(2668),l=n(4968);const p=(0,c.op)({avgPool_:function(t,e,n,c,p){const d=(0,s._1)(t,"x","avgPool","float32");a.hu(u.jT(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let h=d,f=!1;3===d.rank&&(f=!0,h=(0,l.X)(d,[1,d.shape[0],d.shape[1],d.shape[2]])),a.hu(4===h.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${h.rank}.`)),null!=p&&a.hu(a.GN(c),(()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${p} but got pad ${c}.`));const m={x:h},g={filterSize:e,strides:n,pad:c,dimRoundingMode:p};let y=r.BV.runKernelFunc(((t,r)=>{const o=u.Xw(h.shape,e,n,1,c,p);return r([h]),1===o.filterWidth&&1===o.filterHeight&&a.cO(o.inShape,o.outShape)?h.clone():t.avgPool(h,o)}),m,null,o.Jh,g);return y=(0,i.p)(y,d.dtype),f?(0,l.X)(y,[y.shape[1],y.shape[2],y.shape[3]]):y}})},3591:function(t,e,n){"use strict";n.d(e,{YB:function(){return o},Vh:function(){return s},kz:function(){return a},rv:function(){return i},lB:function(){return u},Q3:function(){return c},LJ:function(){return l},sY:function(){return p}});var r=n(569);function o(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function s(t,e,n){const r=t.length+e.length,o=[];let s=0,a=0;for(let i=0;i<r;i++)-1===n.indexOf(i)?o.push(t[s++]):o.push(e[a++]);return o}function a(t,e){const n=[],r=t.length;for(let o=0;o<r;o++)-1===e.indexOf(o)&&n.push(t[o]);return[n,e.map((e=>t[e]))]}function i(t,e){return s(t,e.map((t=>1)),e)}function u(t,e,n){r.hu(o(e,n),(()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`))}function c(t,e){if(o(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach((t=>n.push(t))),n}function l(t){return t.map(((t,e)=>[e,t])).sort(((t,e)=>t[1]-e[1])).map((t=>t[0]))}function p(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}},8441:function(t,e,n){"use strict";n.d(e,{E:function(){return i}});var r=n(7097),o=n(9121),s=n(3740),a=n(569);const i=(0,n(2668).op)({batchToSpaceND_:function(t,e,n){const i=(0,s._1)(t,"x","batchToSpaceND"),u=e.reduce(((t,e)=>t*e));a.hu(i.rank>=1+e.length,(()=>`input rank is ${i.rank} but should be > than blockShape.length ${e.length}`)),a.hu(n.length===e.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`)),a.hu(i.shape[0]%u==0,(()=>`input tensor batch is ${i.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${u}`));const c={x:i},l={blockShape:e,crops:n};return r.BV.runKernelFunc((t=>t.batchToSpaceND(i,e,n)),c,null,o.zw,l)}})},7505:function(t,e,n){"use strict";n.d(e,{t:function(){return c}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(4968);function u(t){return null==t?null:0===t.rank?(0,i.X)(t,[t.size]):1===t.rank?t:2===t.rank?(0,i.X)(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?(0,i.X)(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t}const c=(0,n(2668).op)({batchNorm_:function(t,e,n,c,l,p){null==p&&(p=.001);const d=(0,s._1)(t,"x","batchNorm"),h=(0,s._1)(e,"mean","batchNorm"),f=(0,s._1)(n,"variance","batchNorm");let m,g;null!=l&&(m=(0,s._1)(l,"scale","batchNorm")),null!=c&&(g=(0,s._1)(c,"offset","batchNorm")),a.hu(h.rank===f.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),a.hu(null==g||h.rank===g.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),a.hu(null==m||h.rank===m.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const y=function(t){let e;return e=0===t.rank||1===t.rank?(0,i.X)(t,[1,1,1,t.size]):2===t.rank?(0,i.X)(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?(0,i.X)(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(d),x={x:y,scale:m,offset:g,mean:h,variance:f},v={varianceEpsilon:p},b=r.BV.runKernelFunc(((t,e)=>(e([y,h,f,m]),t.batchNorm(y,u(h),u(f),u(g),u(m),p))),x,null,o.sH,v);return(0,i.X)(b,d.shape)}})},8247:function(t,e,n){"use strict";n.d(e,{U:function(){return c}});var r=n(7097),o=n(9121),s=n(3740),a=n(8723),i=n(2668),u=n(4968);const c=(0,i.op)({broadcastTo_:function(t,e){let n=(0,s._1)(t,"broadcastTo","x");const i=n.shape;if(e.some((t=>!(t>0)||t%1!=0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=(0,u.X)(n,t)}const c=n.shape,l=Array.from(e);for(let t=e.length-1;t>=0;t--)if(c[t]===e[t])l[t]=1;else if(1!==n.shape[t])throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${e}].`);if(0===l.map(((t,e)=>t>1?e:-1)).filter((t=>t>=0)).length)return(0,a.d)(n);const p={x:n},d={shape:e,inputShape:c};return r.BV.runKernelFunc((t=>t.tile(n,l)),p,null,o.Ly,d)}})},2200:function(t,e,n){"use strict";function r(t,e){const n=t.length,r=[];for(let o=0;o<n;o++){const s=n-1-o,a=t[s]||1;(e[e.length-1-o]||1)>1&&1===a&&r.unshift(s)}return r}function o(t,e){const n=[];for(let r=0;r<e.length;r++){const o=t[t.length-r-1],s=e.length-r-1,a=e[s];(null==o||1===o&&a>1)&&n.unshift(s)}return n}function s(t,e){const n=[],r=Math.max(t.length,e.length);for(let o=0;o<r;o++){let r=t[t.length-o-1];null==r&&(r=1);let s=e[e.length-o-1];if(null==s&&(s=1),1===r)n.unshift(s);else if(1===s)n.unshift(r);else{if(r!==s)throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`);n.unshift(r)}}return n}n.d(e,{XF:function(){return r},RR:function(){return o},$N:function(){return s}})},2657:function(t,e,n){"use strict";n.d(e,{f:function(){return s}});var r=n(4077),o=n(569);function s(t,e="float32",n){return e=e||"float32",o.Mu(t),new r.YD(t,e,n)}},2271:function(t,e,n){"use strict";n.d(e,{p:function(){return i}});var r=n(7097),o=n(9121),s=n(3740),a=n(569);const i=(0,n(2668).op)({cast_:function(t,e){const n=(0,s._1)(t,"x","cast");if(!a.LP(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const i={x:n},u={dtype:e};return r.BV.runKernelFunc((t=>t.cast(n,e)),i,null,o.RF,u)}})},6825:function(t,e,n){"use strict";n.d(e,{m:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({ceil_:function(t){const e=(0,s._1)(t,"x","ceil"),n={x:e};return r.BV.runKernelFunc((t=>t.ceil(e)),n,null,o.gJ)}})},2279:function(t,e,n){"use strict";n.d(e,{i:function(){return i}});var r=n(7097),o=n(9121),s=n(3740),a=n(569);const i=(0,n(2668).op)({clipByValue_:function(t,e,n){const i=(0,s._1)(t,"x","clipByValue");a.hu(e<=n,(()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`));const u={x:i},c={clipValueMin:e,clipValueMax:n};return r.BV.runKernelFunc(((t,r)=>{const o=t.clip(i,e,n);return r([i]),o}),u,null,o.xn,c)}})},8723:function(t,e,n){"use strict";n.d(e,{d:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({clone_:function(t){const e=(0,s._1)(t,"x","clone",null),n={x:e};return r.BV.runKernelFunc((()=>r.BV.makeTensorFromDataId(e.dataId,e.shape,e.dtype)),n,null,o.iJ)}})},1661:function(t,e,n){"use strict";n.d(e,{P:function(){return i}});var r=n(7097),o=n(9121),s=n(3740),a=n(569);const i=(0,n(2668).op)({complex_:function(t,e){const n=(0,s._1)(t,"real","complex"),i=(0,s._1)(e,"imag","complex");a.k5(n.shape,i.shape,`real and imag shapes, ${n.shape} and ${i.shape}, must match in call to tf.complex().`);const u={real:n,imag:i};return r.BV.runKernelFunc((t=>t.complex(n,i)),u,null,o.Zz)}})},6884:function(t,e,n){"use strict";n.d(e,{z:function(){return l}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(398),u=n(2668),c=n(701);const l=(0,u.op)({concat_:function(t,e=0){(0,a.hu)(t.length>=1,(()=>"Pass at least one tensor to concat"));let n=(0,s.sI)(t,"tensors","concat");"complex64"===n[0].dtype&&n.forEach((t=>{if("complex64"!==t.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)}));const u=n,l={axis:e};return r.BV.runKernelFunc(((t,r)=>{const o=(0,a.EC)(e,n[0].shape)[0],s=(0,i.N)(n.map((t=>t.shape)),o);if(0===(0,a.NA)(s))return(0,c.X)([],s);if(n=n.filter((t=>t.size>0)),1===n.length)return n[0];const u=n.map((t=>t.shape));(0,i.o)(u,o);const l=t.concat(n,o);return r(n),l}),u,null,o.Eh,l)}})},398:function(t,e,n){"use strict";n.d(e,{o:function(){return o},N:function(){return s}});var r=n(569);function o(t,e){const n=t[0].length;t.forEach(((t,e)=>{r.hu(t.length===n,(()=>`Error in concat${n}D: rank of tensors[${e}] must be the same as the rank of the rest (${n})`))})),r.hu(e>=0&&e<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const o=t[0];t.forEach(((t,s)=>{for(let a=0;a<n;a++)r.hu(a===e||t[a]===o[a],(()=>`Error in concat${n}D: Shape of tensors[${s}] (${t}) does not match the shape of the rest (${o}) along the non-concatenated axis ${s}.`))}))}function s(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}},1355:function(t,e,n){"use strict";n.d(e,{P:function(){return c}});var r=n(3740),o=n(569),s=n(4794),a=n(2582),i=n(2668),u=n(4968);const c=(0,i.op)({conv1d_:function(t,e,n,i,c="NWC",l=1,p){const d=(0,r._1)(t,"x","conv1d"),h=(0,r._1)(e,"filter","conv1d");let f=d,m=!1;2===d.rank&&(m=!0,f=(0,u.X)(d,[1,d.shape[0],d.shape[1]])),o.hu(3===f.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${f.rank}.`)),o.hu(3===h.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${h.rank}.`)),null!=p&&o.hu(o.GN(i),(()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${p} but got pad ${i}.`)),o.hu(f.shape[2]===h.shape[1],(()=>`Error in conv1d: depth of input (${f.shape[2]}) must match input depth for filter ${h.shape[1]}.`)),o.hu(a.jT(n,l),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${l}'`)),o.hu("NWC"===c,(()=>`Error in conv1d: got dataFormat of ${c} but only NWC is currently supported.`));const g=(0,u.X)(h,[1,h.shape[0],h.shape[1],h.shape[2]]),y=(0,u.X)(f,[f.shape[0],1,f.shape[1],f.shape[2]]),x=[1,n],v=[1,l],b=(0,s.T)(y,g,x,i,"NHWC",v,p);return m?(0,u.X)(b,[b.shape[2],b.shape[3]]):(0,u.X)(b,[b.shape[0],b.shape[2],b.shape[3]])}})},4794:function(t,e,n){"use strict";n.d(e,{T:function(){return l}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(2582),u=n(2668),c=n(4968);const l=(0,u.op)({conv2d_:function(t,e,n,u,l="NHWC",p=[1,1],d){const h=(0,s._1)(t,"x","conv2d"),f=(0,s._1)(e,"filter","conv2d");let m=h,g=!1;3===h.rank&&(g=!0,m=(0,c.X)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),a.hu(4===m.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${m.rank}.`)),a.hu(4===f.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${f.rank}.`)),null!=d&&a.hu(a.GN(u),(()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${d} but got pad ${u}.`));const y="NHWC"===l?m.shape[3]:m.shape[1];a.hu(y===f.shape[2],(()=>`Error in conv2d: depth of input (${y}) must match input depth for filter ${f.shape[2]}.`)),a.hu(i.jT(n,p),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${p}'`));const x={x:m,filter:f},v={strides:n,pad:u,dataFormat:l,dilations:p,dimRoundingMode:d},b=r.BV.runKernelFunc(((t,e)=>{const r=i.sl(l),o=i.Ix(m.shape,f.shape,n,p,u,d,!1,r),s=t.conv2d(m,f,o);return e([m,f]),s}),x,null,o.mh,v);return g?(0,c.X)(b,[b.shape[1],b.shape[2],b.shape[3]]):b}})},6013:function(t,e,n){"use strict";n.d(e,{p:function(){return c}});var r=n(7097),o=n(9121),s=n(569),a=n(2582),i=n(2668),u=n(4968);const c=(0,i.op)({conv2DBackpropFilter_:function(t,e,n,i,c,l="NHWC",p){let d=t;3===t.rank&&(d=(0,u.X)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let h=e;3===h.rank&&(h=(0,u.X)(e,[1,e.shape[0],e.shape[1],e.shape[2]])),s.hu(4===d.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${d.shape}.`)),s.hu(4===h.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${h.shape}.`)),s.hu(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const f="NHWC"===l?d.shape[3]:d.shape[1],m="NHWC"===l?h.shape[3]:h.shape[1];s.hu(f===n[2],(()=>`Error in conv2dDerFilter: depth of input ${f}) must match input depth in filter (${n[2]}.`)),s.hu(m===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${m}) must match output depth for filter (${n[3]}).`)),null!=p&&s.hu(s.GN(c),(()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${p} but got pad ${c}.`));const g={x:d,dy:h},y={strides:i,pad:c,dataFormat:l,dimRoundingMode:p,filterShape:n};return r.BV.runKernelFunc((t=>{const e=a.sl(l),r=a.Ix(d.shape,n,i,1,c,p,!1,e);return t.conv2dDerFilter(d,h,r)}),g,null,o.wU,y)}})},9832:function(t,e,n){"use strict";n.d(e,{_:function(){return c}});var r=n(7097),o=n(9121),s=n(569),a=n(2582),i=n(2668),u=n(4968);const c=(0,i.op)({conv2DBackpropInput_:function(t,e,n,i,c,l="NHWC",p){s.hu(t.length===e.rank,(()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`));let d=t,h=e,f=!1;3===e.rank&&(f=!0,h=(0,u.X)(e,[1,e.shape[0],e.shape[1],e.shape[2]]),d=[1,t[0],t[1],t[2]]),s.hu(4===d.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${d.length}.`)),s.hu(4===h.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${h.rank}`)),s.hu(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const m="NHWC"===l?d[3]:d[1],g="NHWC"===l?h.shape[3]:h.shape[1];s.hu(m===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${m}) must match input depth for filter ${n.shape[2]}.`)),s.hu(g===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${g}) must match output depth for filter ${n.shape[3]}.`)),null!=p&&s.hu(s.GN(c),(()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${p} but got pad ${c}.`));const y={dy:h,filter:n},x={strides:i,pad:c,dataFormat:l,dimRoundingMode:p,inputShape:d},v=r.BV.runKernelFunc(((t,e)=>{const r=a.sl(l),o=a.Ix(d,n.shape,i,1,c,p,!1,r),s=t.conv2dDerInput(h,n,o);return e([h,n]),s}),y,null,o.wm,x);return f?(0,u.X)(v,[v.shape[1],v.shape[2],v.shape[3]]):v}})},1405:function(t,e,n){"use strict";n.d(e,{b:function(){return s}});var r=n(3740),o=n(9832);const s=(0,n(2668).op)({conv2dTranspose_:function(t,e,n,s,a,i){const u=(0,r._1)(t,"x","conv2dTranspose"),c=(0,r._1)(e,"filter","conv2dTranspose");return(0,o._)(n,u,c,s,a,"NHWC",i)}})},2582:function(t,e,n){"use strict";n.d(e,{Rf:function(){return o},Xw:function(){return s},pl:function(){return a},Ix:function(){return i},jw:function(){return u},aO:function(){return c},I0:function(){return f},jT:function(){return m},sl:function(){return g}});var r=n(569);function o(t,e,n,r,o="NHWC",s){return i(t,[...e,t[3]],n,s,r,null,null,g(o))}function s(t,e,n,r,o,s,a="channelsLast"){const[u,c]=l(e);let p;if("channelsLast"===a)p=[u,c,t[3],t[3]];else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);p=[u,c,t[1],t[1]]}return i(t,p,n,r,o,s,!1,a)}function a(t,e,n,r,o,s,a="NDHWC"){const[i,c,l]=p(e);let d,h;if("NDHWC"===a)h="channelsLast",d=[i,c,l,t[4],t[4]];else{if("NCDHW"!==a)throw new Error(`Unknown dataFormat ${a}`);h="channelsFirst",d=[i,c,l,t[1],t[1]]}return u(t,d,n,r,o,!1,h,s)}function i(t,e,n,o,s,a,i=!1,u="channelsLast"){let[p,f,m,g]=[-1,-1,-1,-1];if("channelsLast"===u)[p,f,m,g]=t;else{if("channelsFirst"!==u)throw new Error(`Unknown dataFormat ${u}`);[p,g,f,m]=t}const[y,x,,v]=e,[b,w]=l(n),[$,C]=l(o),N=d(y,$),I=d(x,C),{padInfo:E,outHeight:T,outWidth:k}=function(t,e,n,o,s,a,i,u,l){let p,d,f;if("number"==typeof t){p={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const s=function(t,e,n,o,s){null==o&&(o=c(t,e,n));const a=t[1],i=h((t[0]-e+2*o)/n+1,s);r.hu(r.GN(i),(()=>`The output # of rows (${i}) must be an integer. Change the stride and/or zero pad parameters`));const u=h((a-e+2*o)/n+1,s);return r.hu(r.GN(u),(()=>`The output # of columns (${u}) must be an integer. Change the stride and/or zero pad parameters`)),[i,u]}([e,n],a,o,t,u);d=s[0],f=s[1]}else if("same"===t){d=Math.ceil(e/o),f=Math.ceil(n/s);const t=Math.max(0,(d-1)*o+a-e),r=Math.max(0,(f-1)*s+i-n),u=Math.floor(t/2),c=t-u,l=Math.floor(r/2);p={top:u,bottom:c,left:l,right:r-l,type:"SAME"}}else if("valid"===t)p={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((e-a+1)/o),f=Math.ceil((n-i+1)/s);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const r="channelsLast"===l?t[1][0]:t[2][0],c="channelsLast"===l?t[1][1]:t[2][1],m="channelsLast"===l?t[2][0]:t[3][0],g="channelsLast"===l?t[2][1]:t[3][1];p={top:r,bottom:c,left:m,right:g,type:0===r&&0===c&&0===m&&0===g?"VALID":"EXPLICIT"},d=h((e-a+r+c)/o+1,u),f=h((n-i+m+g)/s+1,u)}}return{padInfo:p,outHeight:d,outWidth:f}}(s,f,m,b,w,N,I,a,u),S=i?v*g:v;let R;return"channelsFirst"===u?R=[p,S,T,k]:"channelsLast"===u&&(R=[p,T,k,S]),{batchSize:p,dataFormat:u,inHeight:f,inWidth:m,inChannels:g,outHeight:T,outWidth:k,outChannels:S,padInfo:E,strideHeight:b,strideWidth:w,filterHeight:y,filterWidth:x,effectiveFilterHeight:N,effectiveFilterWidth:I,dilationHeight:$,dilationWidth:C,inShape:t,outShape:R,filterShape:e}}function u(t,e,n,o,s,a=!1,i="channelsLast",u){let[l,f,m,g,y]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,f,m,g,y]=t;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,y,f,m,g]=t}const[x,v,b,,w]=e,[$,C,N]=p(n),[I,E,T]=p(o),k=d(x,I),S=d(v,E),R=d(b,T),{padInfo:_,outDepth:A,outHeight:D,outWidth:O}=function(t,e,n,o,s,a,i,u,l,p,d){let f,m,g,y;if("number"==typeof t){f={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const a=function(t,e,n,o,s,a){null==s&&(s=c(t,e,o));const i=t[1],u=t[2],l=h((t[0]-e+2*s)/o+1,a);r.hu(r.GN(l),(()=>`The output # of depths (${l}) must be an integer. Change the stride and/or zero pad parameters`));const p=h((i-e+2*s)/o+1,a);r.hu(r.GN(p),(()=>`The output # of rows (${p}) must be an integer. Change the stride and/or zero pad parameters`));const d=h((u-e+2*s)/o+1,a);return r.hu(r.GN(d),(()=>`The output # of columns (${d}) must be an integer. Change the stride and/or zero pad parameters`)),[l,p,d,1]}([e,n,o,1],u,0,s,t,d);m=a[0],g=a[1],y=a[2]}else if("same"===t){m=Math.ceil(e/s),g=Math.ceil(n/a),y=Math.ceil(o/i);const t=(m-1)*s+u-e,r=(g-1)*a+l-n,c=(y-1)*i+p-o,d=Math.floor(t/2),h=t-d,x=Math.floor(r/2),v=r-x,b=Math.floor(c/2);f={top:x,bottom:v,left:b,right:c-b,front:d,back:h,type:"SAME"}}else{if("valid"!==t)throw Error(`Unknown padding parameter: ${t}`);f={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},m=Math.ceil((e-u+1)/s),g=Math.ceil((n-l+1)/a),y=Math.ceil((o-p+1)/i)}return{padInfo:f,outDepth:m,outHeight:g,outWidth:y}}(s,f,m,g,$,C,N,k,S,R,u),F=a?w*y:w;let B;return"channelsFirst"===i?B=[l,F,A,D,O]:"channelsLast"===i&&(B=[l,A,D,O,F]),{batchSize:l,dataFormat:i,inDepth:f,inHeight:m,inWidth:g,inChannels:y,outDepth:A,outHeight:D,outWidth:O,outChannels:F,padInfo:_,strideDepth:$,strideHeight:C,strideWidth:N,filterDepth:x,filterHeight:v,filterWidth:b,effectiveFilterDepth:k,effectiveFilterHeight:S,effectiveFilterWidth:R,dilationDepth:I,dilationHeight:E,dilationWidth:T,inShape:t,outShape:B,filterShape:e}}function c(t,e,n,r=1){const o=d(e,r);return Math.floor((t[0]*(n-1)-n+o)/2)}function l(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function p(t){return"number"==typeof t?[t,t,t]:t}function d(t,e){return e<=1?t:t+(t-1)*(e-1)}function h(t,e){if(!e)return t;switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function f(t){const[e,n,r]=l(t);return 1===e&&1===n&&1===r}function m(t,e){return f(t)||f(e)}function g(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}},173:function(t,e,n){"use strict";n.d(e,{m:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({cos_:function(t){const e=(0,s._1)(t,"x","cos"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.cos(e);return n([e]),r}),n,null,o.mc)}})},2699:function(t,e,n){"use strict";n.d(e,{f:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({cosh_:function(t){const e=(0,s._1)(t,"x","cosh"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.cosh(e);return n([e]),r}),n,null,o.TR)}})},7405:function(t,e,n){"use strict";n.d(e,{z:function(){return c}});var r=n(7097),o=n(9121),s=n(3740),a=n(3591),i=n(2668),u=n(9065);const c=(0,i.op)({cumsum_:function(t,e=0,n=!1,i=!1){const c=(0,s._1)(t,"x","cumsum"),l={x:c},p={axis:e,exclusive:n,reverse:i};return r.BV.runKernelFunc(((t,r)=>{const o=(0,a.Q3)([e],c.rank);let s=c;null!=o&&(s=(0,u.p)(c,o));const l=(0,a.sY)(1,c.rank)[0];let p=t.cumsum(s,l,n,i);if(r([c]),null!=o){const t=(0,a.LJ)(o);p=(0,u.p)(p,t)}return p}),l,null,o.iH,p)}})},9112:function(t,e,n){"use strict";n.d(e,{n:function(){return i}});var r=n(7097),o=n(9121),s=n(3740),a=n(569);const i=(0,n(2668).op)({depthToSpace_:function(t,e,n="NHWC"){const i=(0,s._1)(t,"x","depthToSpace"),u="NHWC"===n?i.shape[1]:i.shape[2],c="NHWC"===n?i.shape[2]:i.shape[3],l="NHWC"===n?i.shape[3]:i.shape[1];a.hu(u*e>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${u} and ${e}  for depthToSpace with input shape\n    ${i.shape}`)),a.hu(c*e>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${c} and ${e} for depthToSpace with input shape\n        ${i.shape}`)),a.hu(l%(e*e)==0,(()=>`Dimension size must be evenly divisible by ${e*e} but is ${l} for depthToSpace with input shape ${i.shape}`));const p={x:i},d={blockSize:e,dataFormat:n};return r.BV.runKernelFunc((t=>t.depthToSpace(i,e,n)),p,null,o.T0,d)}})},4718:function(t,e,n){"use strict";n.d(e,{B:function(){return l}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(2582),u=n(2668),c=n(4968);const l=(0,u.op)({depthwiseConv2d_:function(t,e,n,u,l="NHWC",p=[1,1],d){const h=(0,s._1)(t,"x","depthwiseConv2d"),f=(0,s._1)(e,"filter","depthwiseConv2d");let m=h,g=!1;3===h.rank&&(g=!0,m=(0,c.X)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),a.hu(4===m.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${m.rank}.`)),a.hu(4===f.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`)),a.hu(m.shape[3]===f.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${m.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`)),null!=d&&a.hu(a.GN(u),(()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${d} but got pad ${u}.`));const y={x:m,filter:f},x={strides:n,pad:u,dataFormat:l,dilations:p,dimRoundingMode:d},v=r.BV.runKernelFunc(((t,e)=>{null==p&&(p=[1,1]),a.hu(i.jT(n,p),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${p}'`));const r=i.Ix(m.shape,f.shape,n,p,u,d,!0),o=t.depthwiseConv2D(m,f,r);return e([m,f]),o}),y,null,o.ci,x);return g?(0,c.X)(v,[v.shape[1],v.shape[2],v.shape[3]]):v}})},8098:function(t,e,n){"use strict";n.d(e,{z:function(){return u}});var r=n(7097),o=n(9121),s=n(2582),a=n(2668),i=n(4968);const u=(0,a.op)({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,a,u,c=[1,1],l){let p=t;3===t.rank&&(p=(0,i.X)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let d=e;3===d.rank&&(d=(0,i.X)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const h={x:p,dy:d},f={strides:a,pad:u,dimRoundingMode:l,dilations:c,filterShape:n};return r.BV.runKernelFunc((e=>{const r=s.Ix(t.shape,n,a,c,u,l,!0);return e.depthwiseConv2DDerFilter(p,d,r)}),h,null,o.sL,f)}})},4375:function(t,e,n){"use strict";n.d(e,{v:function(){return u}});var r=n(7097),o=n(9121),s=n(2582),a=n(2668),i=n(4968);const u=(0,a.op)({depthwiseConv2dNativeBackpropInput_:function(t,e,n,a,u,c=[1,1],l){let p=e,d=!1;3===e.rank&&(d=!0,p=(0,i.X)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const h={dy:p,filter:n},f={strides:a,pad:u,dimRoundingMode:l,dilations:c,inputShape:t},m=r.BV.runKernelFunc((e=>{const r=s.Ix(t,n.shape,a,c,u,l,!0);return e.depthwiseConv2DDerInput(p,n,r)}),h,null,o.y7,f);return d?(0,i.X)(m,[m.shape[1],m.shape[2],m.shape[3]]):m}})},557:function(t,e,n){"use strict";n.d(e,{W:function(){return c}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(2668),u=n(4968);const c=(0,i.op)({dilation2d_:function(t,e,n,i,c=[1,1],l="NHWC"){const p=(0,s._1)(t,"x","dilation2d"),d=(0,s._1)(e,"filter","dilation2d");a.hu(3===p.rank||4===p.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${p.rank}.`)),a.hu(3===d.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${d.rank}.`)),a.hu("NHWC"===l,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${l}`));let h=p,f=!1;3===p.rank&&(h=(0,u.X)(p,[1,p.shape[0],p.shape[1],p.shape[2]]),f=!0);const m={x:h,filter:d},g={strides:n,pad:i,dilations:c},y=r.BV.runKernel(o.p4,m,g);return f?(0,u.X)(y,[y.shape[1],y.shape[2],y.shape[3]]):y}})},1274:function(t,e,n){"use strict";n.d(e,{h:function(){return u}});var r=n(7097),o=n(9121),s=n(747),a=n(3740),i=n(9165);const u=(0,n(2668).op)({div_:function(t,e){let n=(0,a._1)(t,"a","div"),u=(0,a._1)(e,"b","div");if([n,u]=(0,s.T_)(n,u),"int32"===n.dtype&&"int32"===u.dtype)return(0,i.q)(n,u);const c={a:n,b:u};return r.BV.runKernelFunc(((t,e)=>{const r=t.realDivide(n,u);return e([n,u]),r}),c,null,o.ZC,{})}})},9322:function(t,e,n){"use strict";n.d(e,{N:function(){return l}});var r=n(747),o=n(3740),s=n(1274),a=n(6477),i=n(2668),u=n(5912),c=n(6577);const l=(0,i.op)({divNoNan_:function(t,e){let n=(0,o._1)(t,"a","div"),i=(0,o._1)(e,"b","div");[n,i]=(0,r.T_)(n,i);const l=(0,s.h)(n,i),p=(0,c.P)(l),d=(0,a.D)(i,p);return(0,u.a)(d,p,l)}})},3233:function(t,e,n){"use strict";n.d(e,{p:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({elu_:function(t){const e=(0,s._1)(t,"x","elu"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.elu(e);return n([r]),r}),n,null,o.SX)}})},6477:function(t,e,n){"use strict";n.d(e,{D:function(){return u}});var r=n(7097),o=n(9121),s=n(747),a=n(3740),i=n(2200);const u=(0,n(2668).op)({equal_:function(t,e){let n=(0,a._1)(t,"a","equal"),u=(0,a._1)(e,"b","equal");[n,u]=(0,s.T_)(n,u),(0,i.$N)(n.shape,u.shape);const c={a:n,b:u};return r.BV.runKernelFunc((t=>t.equal(n,u)),c,null,o.hd)}})},4650:function(t,e,n){"use strict";n.d(e,{q:function(){return u}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(2271);const u=(0,n(2668).op)({erf_:function(t){let e=(0,s._1)(t,"x","erf");a.hu("int32"===e.dtype||"float32"===e.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===e.dtype&&(e=(0,i.p)(e,"float32"));const n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.erf(e);return n([e]),r}),n,null,o.Om)}})},4842:function(t,e,n){"use strict";n.d(e,{Q:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({exp_:function(t){const e=(0,s._1)(t,"x","exp"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.exp(e);return n([r]),r}),n,null,o.NE)}})},1300:function(t,e,n){"use strict";n.d(e,{d:function(){return i}});var r=n(3740),o=n(569),s=n(2668),a=n(4968);const i=(0,s.op)({expandDims_:function(t,e=0){const n=(0,r._1)(t,"x","expandDims",null);o.hu(e<=n.rank,(()=>"Axis must be <= rank of the tensor"));const s=n.shape.slice();return e<0&&(o.hu(-(n.rank+1)<=e,(()=>`Axis must be in the interval [${-(n.rank+1)}, ${n.rank}]`)),e=n.rank+e+1),s.splice(e,0,1),(0,a.X)(n,s)}})},3426:function(t,e,n){"use strict";n.d(e,{t:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({expm1_:function(t){const e=(0,s._1)(t,"x","expm1"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.expm1(e);return n([e]),r}),n,null,o.Y0)}})},4006:function(t,e,n){"use strict";n.d(e,{h:function(){return s}});var r=n(7097),o=n(9121);function s(t,e,n){const s={shape:t,value:e,dtype:n};return r.BV.runKernelFunc((r=>r.fill(t,e,n)),{},null,o.de,s)}},6943:function(t,e,n){"use strict";n.d(e,{G:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({floor_:function(t){const e=(0,s._1)(t,"x","floor"),n={x:e};return r.BV.runKernelFunc((t=>t.floor(e)),n,null,o.OR)}})},9165:function(t,e,n){"use strict";n.d(e,{q:function(){return i}});var r=n(7097),o=n(9121),s=n(747),a=n(3740);const i=(0,n(2668).op)({floorDiv_:function(t,e){let n=(0,a._1)(t,"a","floorDiv"),i=(0,a._1)(e,"b","floorDiv");[n,i]=(0,s.T_)(n,i);const u={a:n,b:i};return r.BV.runKernelFunc(((t,e)=>{const r=t.floorDiv(n,i);return e([n,i]),r}),u,null,o.je)}})},9323:function(t,e,n){"use strict";n.d(e,{Fr:function(){return d},pf:function(){return h},QH:function(){return f},uy:function(){return m}});var r=n(2200),o=n(3233),s=n(4841),a=n(8151),i=n(7409),u=n(3582),c=n(4968),l=n(1901),p=n(5475);function d(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return(0,s.d)(t,(0,l.N)(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function h(t,e){let n=e;const o=r.RR(t.shape,e.shape);return o.length>0&&(n=(0,p.S)(n,o)),(0,c.X)(n,t.shape)}function f(t,e,n){if("linear"===e)return t;if("relu"===e)return(0,i.U)(t);if("elu"===e)return(0,o.p)(t);if("relu6"===e)return(0,u.b)(t);if("prelu"===e)return(0,a.A)(t,n);throw new Error(`Unknown fused activation ${e}.`)}const m=(t,e)=>!(t>0)||"linear"===e},4926:function(t,e,n){"use strict";n.d(e,{I:function(){return l}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(2668),u=n(4968),c=n(4931);const l=(0,i.op)({gather_:function(t,e,n=0){const i=(0,s._1)(t,"x","gather"),l=(0,s._1)(e,"indices","gather","int32"),p={x:i,indices:l},d={axis:n};return r.BV.runKernelFunc(((t,e)=>{const r=(0,a.EC)(n,i.shape)[0],o=(0,c.collectGatherOpShapeInfo)(i,l,r),s=t.gather(i,(0,u.X)(l,[l.size]),r);return e([i,l]),(0,u.X)(s,o.outputShape)}),p,null,o.qi,d)}})},636:function(t,e,n){"use strict";n.d(e,{p:function(){return u}});var r=n(7097),o=n(9121),s=n(747),a=n(3740),i=n(2200);const u=(0,n(2668).op)({greater_:function(t,e){let n=(0,a._1)(t,"a","greater"),u=(0,a._1)(e,"b","greater");[n,u]=(0,s.T_)(n,u),(0,i.$N)(n.shape,u.shape);const c={a:n,b:u};return r.BV.runKernelFunc((t=>t.greater(n,u)),c,null,o.iZ)}})},7630:function(t,e,n){"use strict";n.d(e,{b:function(){return u}});var r=n(7097),o=n(9121),s=n(747),a=n(3740),i=n(2200);const u=(0,n(2668).op)({greaterEqual_:function(t,e){let n=(0,a._1)(t,"a","greaterEqual"),u=(0,a._1)(e,"b","greaterEqual");[n,u]=(0,s.T_)(n,u),(0,i.$N)(n.shape,u.shape);const c={a:n,b:u};return r.BV.runKernelFunc(((t,e)=>{const r=t.greaterEqual(n,u);return e([n,u]),r}),c,null,o.Ac)}})},4386:function(t,e,n){"use strict";n.d(e,{a:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({imag_:function(t){const e=(0,s._1)(t,"input","imag"),n={input:e};return r.BV.runKernelFunc((t=>t.imag(e)),n,null,o.J_)}})},3305:function(t,e,n){"use strict";n.d(e,{I:function(){return c}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(2668),u=n(4968);const c=(0,i.op)({resizeBilinear_:function(t,e,n=!1){const i=(0,s._1)(t,"images","resizeBilinear");a.hu(3===i.rank||4===i.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`)),a.hu(2===e.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`));let c=i,l=!1;3===i.rank&&(l=!0,c=(0,u.X)(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const[p,d]=e,h={images:c},f={alignCorners:n,size:e},m=r.BV.runKernelFunc(((t,e)=>(e([c]),t.resizeBilinear(c,p,d,n))),h,null,o._Y,f);return l?(0,u.X)(m,[m.shape[1],m.shape[2],m.shape[3]]):m}})},5098:function(t,e,n){"use strict";n.d(e,{j:function(){return c}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(2668),u=n(4968);const c=(0,i.op)({resizeNearestNeighbor_:function(t,e,n=!1){const i=(0,s._1)(t,"images","resizeNearestNeighbor");a.hu(3===i.rank||4===i.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`)),a.hu(2===e.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`)),a.hu("float32"===i.dtype||"int32"===i.dtype,(()=>"`images` must have `int32` or `float32` as dtype"));let c=i,l=!1;3===i.rank&&(l=!0,c=(0,u.X)(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const[p,d]=e,h={images:c},f={alignCorners:n,size:e},m=r.BV.runKernelFunc(((t,e)=>(e([c]),t.resizeNearestNeighbor(c,p,d,n))),h,null,o.dp,f);return l?(0,u.X)(m,[m.shape[1],m.shape[2],m.shape[3]]):m}})},9133:function(t,e,n){"use strict";n.d(e,{h:function(){return u}});var r=n(3740),o=n(632),s=n(4841),a=n(2668),i=n(9494);const u=(0,a.op)({leakyRelu_:function(t,e=.2){const n=(0,r._1)(t,"x","leakyRelu");return(0,o.g)((0,s.d)((0,i.i)(e),n),n)}})},6573:function(t,e,n){"use strict";n.d(e,{d:function(){return u}});var r=n(7097),o=n(9121),s=n(747),a=n(3740),i=n(2200);const u=(0,n(2668).op)({less_:function(t,e){let n=(0,a._1)(t,"a","less"),u=(0,a._1)(e,"b","less");[n,u]=(0,s.T_)(n,u),(0,i.$N)(n.shape,u.shape);const c={a:n,b:u};return r.BV.runKernelFunc((t=>t.less(n,u)),c,null,o.vt)}})},624:function(t,e,n){"use strict";n.d(e,{z:function(){return u}});var r=n(7097),o=n(9121),s=n(747),a=n(3740),i=n(2200);const u=(0,n(2668).op)({lessEqual_:function(t,e){let n=(0,a._1)(t,"a","lessEqual"),u=(0,a._1)(e,"b","lessEqual");[n,u]=(0,s.T_)(n,u),(0,i.$N)(n.shape,u.shape);const c={a:n,b:u};return r.BV.runKernelFunc(((t,e)=>{const r=t.lessEqual(n,u);return e([n,u]),r}),c,null,o.CA)}})},9648:function(t,e,n){"use strict";n.d(e,{G:function(){return c}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(2668),u=n(4968);const c=(0,i.op)({localResponseNormalization_:function(t,e=5,n=1,i=1,c=.5){const l=(0,s._1)(t,"x","localResponseNormalization");a.hu(4===l.rank||3===l.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${l.rank}.`)),a.hu(a.GN(e),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`));let p=l,d=!1;3===l.rank&&(d=!0,p=(0,u.X)(l,[1,l.shape[0],l.shape[1],l.shape[2]]));const h={x:p},f={depthRadius:e,bias:n,alpha:i,beta:c},m=r.BV.runKernelFunc(((t,r)=>{const o=t.localResponseNormalization4D(p,e,n,i,c);return r([p,o]),o}),h,null,o.eZ,f);return d?(0,u.X)(m,[m.shape[1],m.shape[2],m.shape[3]]):m}})},2597:function(t,e,n){"use strict";n.d(e,{c:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({log_:function(t){const e=(0,s._1)(t,"x","log"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.log(e);return n([e]),r}),n,null,o.Zb)}})},7474:function(t,e,n){"use strict";n.d(e,{K:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({log1p_:function(t){const e=(0,s._1)(t,"x","log1p"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.log1p(e);return n([e]),r}),n,null,o.kU)}})},1510:function(t,e,n){"use strict";n.d(e,{C:function(){return h}});var r=n(7097),o=n(9121),s=n(3740),a=n(2271),i=n(4842),u=n(2597),c=n(3307),l=n(2668),p=n(827),d=n(5475);const h=(0,l.op)({logSoftmax_:function(t,e=-1){const n=(0,s._1)(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);const l={logits:n},h={axis:e};return r.BV.runKernelFunc(((n,r)=>{const o=(0,c.F)(t,e,!0),s=(0,p.l)(t,o),l=(0,p.l)((0,a.p)(s,"float32"),(0,u.c)((0,d.S)((0,i.Q)(s),e,!0)));return r([l]),l}),l,null,o.qC,h)}})},1391:function(t,e,n){"use strict";n.d(e,{l:function(){return f}});var r=n(3740),o=n(569),s=n(6407),a=n(3591),i=n(4842),u=n(2597),c=n(3307),l=n(2668),p=n(4968),d=n(827),h=n(5475);const f=(0,l.op)({logSumExp_:function(t,e=null,n=!1){const l=(0,r._1)(t,"x","logSumExp"),f=(0,o.EC)(e,l.shape),m=(0,c.F)(l,f,!0),g=(0,d.l)(l,m),y=(0,i.Q)(g),x=(0,h.S)(y,f),v=(0,u.c)(x),b=(0,s.I)((0,p.X)(m,v.shape),v);if(n){const t=(0,a.rv)(b.shape,f);return(0,p.X)(b,t)}return b}})},2856:function(t,e,n){"use strict";n.d(e,{H:function(){return i}});var r=n(7097),o=n(9121),s=n(3740),a=n(2200);const i=(0,n(2668).op)({logicalAnd_:function(t,e){const n=(0,s._1)(t,"a","logicalAnd","bool"),i=(0,s._1)(e,"b","logicalAnd","bool");(0,a.$N)(n.shape,i.shape);const u={a:n,b:i};return r.BV.runKernelFunc((t=>t.logicalAnd(n,i)),u,null,o.PY)}})},8651:function(t,e,n){"use strict";n.d(e,{h:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({logicalNot_:function(t){const e=(0,s._1)(t,"x","logicalNot","bool"),n={x:e};return r.BV.runKernelFunc((t=>t.logicalNot(e)),n,null,o.Vf)}})},5750:function(t,e,n){"use strict";n.d(e,{K:function(){return i}});var r=n(7097),o=n(9121),s=n(3740),a=n(2200);const i=(0,n(2668).op)({logicalOr_:function(t,e){const n=(0,s._1)(t,"a","logicalOr","bool"),i=(0,s._1)(e,"b","logicalOr","bool");(0,a.$N)(n.shape,i.shape);const u={a:n,b:i};return r.BV.runKernelFunc((t=>t.logicalOr(n,i)),u,null,o.MZ)}})},8687:function(t,e,n){"use strict";n.d(e,{O:function(){return l}});var r=n(7097),o=n(9121),s=n(747),a=n(3740),i=n(569),u=n(2668),c=n(4968);const l=(0,u.op)({matMul_:function(t,e,n=!1,u=!1){let l=(0,a._1)(t,"a","matMul"),p=(0,a._1)(e,"b","matMul");[l,p]=(0,s.T_)(l,p);const d={a:l,b:p},h={transposeA:n,transposeB:u};return r.BV.runKernelFunc(((t,e)=>{e([l,p]);const r=n?l.shape[l.rank-2]:l.shape[l.rank-1],o=u?p.shape[p.rank-1]:p.shape[p.rank-2],s=n?l.shape[l.rank-1]:l.shape[l.rank-2],a=u?p.shape[p.rank-2]:p.shape[p.rank-1],d=l.shape.slice(0,-2),h=p.shape.slice(0,-2),f=i.NA(d),m=i.NA(h),g=f===m||1===f||1===m;i.hu(l.rank>=2&&p.rank>=2&&g,(()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${d}) and (${h}).`)),i.hu(r===o,(()=>`Error in matMul: inner shapes (${r}) and (${o}) of Tensors with shapes ${l.shape} and ${p.shape} and transposeA=${n} and transposeB=${u} must match.`));const y=(f>m?d:h).concat([s,a]),x=n?(0,c.X)(l,[f,r,s]):(0,c.X)(l,[f,s,r]),v=u?(0,c.X)(p,[m,a,o]):(0,c.X)(p,[m,o,a]),b=t.batchMatMul(x,v,n,u);return(0,c.X)(b,y)}),d,null,o.XL,h)}})},3307:function(t,e,n){"use strict";n.d(e,{F:function(){return p}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(3591),u=n(2668),c=n(4968),l=n(9065);const p=(0,u.op)({max_:function(t,e=null,n=!1){const u=(0,s._1)(t,"x","max"),p={x:u},d={reductionIndices:e,keepDims:n};return r.BV.runKernelFunc(((t,r)=>{let o=a.EC(e,u.shape);const s=i.Q3(o,u.rank);let p=u;null!=s&&(p=(0,l.p)(u,s),o=i.sY(o.length,p.rank));const d=t.max(p,o);null!=s&&p.dispose();let h=d;if(n){const t=i.rv(h.shape,a.EC(e,u.shape));h=(0,c.X)(h,t),d.dispose()}return r([u,h]),h}),p,null,o.Yo,d)}})},1174:function(t,e,n){"use strict";n.d(e,{_:function(){return l}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(2582),u=n(2668),c=n(4968);const l=(0,u.op)({maxPool_:function(t,e,n,u,l){const p=(0,s._1)(t,"x","maxPool");let d=p,h=!1;3===p.rank&&(h=!0,d=(0,c.X)(p,[1,p.shape[0],p.shape[1],p.shape[2]])),a.hu(4===d.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${d.rank}.`)),a.hu(i.jT(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),null!=l&&a.hu(a.GN(u),(()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${l} but got pad ${u}.`));const f={x:d},m={filterSize:e,strides:n,pad:u,dimRoundingMode:l},g=r.BV.runKernelFunc(((t,r)=>{const o=i.Xw(d.shape,e,n,1,u,l);let s;return s=1===o.filterWidth&&1===o.filterHeight&&a.cO(o.inShape,o.outShape)?d.clone():t.maxPool(d,o),r([d,s]),s}),f,null,o.mT,m);return h?(0,c.X)(g,[g.shape[1],g.shape[2],g.shape[3]]):g}})},632:function(t,e,n){"use strict";n.d(e,{g:function(){return c}});var r=n(7097),o=n(9121),s=n(747),a=n(3740),i=n(2200),u=n(2271);const c=(0,n(2668).op)({maximum_:function(t,e){let n=(0,a._1)(t,"a","maximum"),c=(0,a._1)(e,"b","maximum");[n,c]=(0,s.T_)(n,c),"bool"===n.dtype&&(n=(0,u.p)(n,"int32"),c=(0,u.p)(c,"int32")),(0,i.$N)(n.shape,c.shape);const l={a:n,b:c};return r.BV.runKernelFunc(((t,e)=>{const r=t.maximum(n,c);return e([n,c]),r}),l,null,o.BM)}})},5130:function(t,e,n){"use strict";n.d(e,{J:function(){return y}});var r=n(7097),o=n(633),s=n(9121),a=n(3740),i=n(569),u=n(3591),c=n(2271),l=n(1274),p=n(4841),d=n(4917),h=n(2668),f=n(4968),m=n(9494),g=n(5475);const y=(0,h.op)({mean_:function(t,e=null,n=!1){const h=(0,a._1)(t,"x","mean"),y=(0,i.EC)(e,h.shape),x=(0,u.kz)(h.shape,y)[1],v=(0,i.NA)(x),b={x:h},w={axis:e,keepDims:n},$=()=>{const t=(0,m.i)(v),r=t.dtype===h.dtype?h:(0,c.p)(h,t.dtype),o=(0,l.h)(r,t);return(0,g.S)(o,e,n)};return(0,o.cb)((t=>({value:r.BV.runKernelFunc($,b,null,s.q2,w),gradFunc:e=>{const n=t.shape.slice();y.forEach((t=>{n[t]=1}));const r=(0,f.X)(e,n);return(0,l.h)((0,p.d)(r,(0,d.i)(t.shape,"float32")),v)}})))(h)}})},5735:function(t,e,n){"use strict";n.d(e,{V:function(){return p}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(3591),u=n(2668),c=n(4968),l=n(9065);const p=(0,u.op)({min_:function(t,e=null,n=!1){const u=(0,s._1)(t,"x","min"),p={x:u},d={axis:e,keepDims:n};return r.BV.runKernelFunc(((t,r)=>{const o=(0,a.EC)(e,u.shape);let s=o;const p=i.Q3(s,u.rank);let d=u;null!=p&&(d=(0,l.p)(u,p),s=i.sY(s.length,u.rank));const h=t.min(d,s);null!=p&&d.dispose();let f=h;if(n){const t=i.rv(f.shape,o);f=(0,c.X)(h,t),h.dispose()}return r([u,f]),f}),p,null,o.c1,d)}})},4513:function(t,e,n){"use strict";n.d(e,{L:function(){return c}});var r=n(7097),o=n(9121),s=n(747),a=n(3740),i=n(2200),u=n(2271);const c=(0,n(2668).op)({minimum_:function(t,e){let n=(0,a._1)(t,"a","minimum"),c=(0,a._1)(e,"b","minimum");[n,c]=(0,s.T_)(n,c),"bool"===n.dtype&&(n=(0,u.p)(n,"int32"),c=(0,u.p)(c,"int32")),(0,i.$N)(n.shape,c.shape);const l={a:n,b:c};return r.BV.runKernelFunc(((t,e)=>{const r=t.minimum(n,c);return e([n,c]),r}),l,null,o.q8)}})},1483:function(t,e,n){"use strict";n.d(e,{V:function(){return i}});var r=n(7097),o=n(9121),s=n(3740),a=n(569);const i=(0,n(2668).op)({mirrorPad_:function(t,e,n){a.hu("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const i=(0,s._1)(t,"x","mirrorPad");if(0===i.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");a.hu(e.length===i.rank,(()=>`Padding doesn't match input. Must be ${i.rank}. Got ${e.length}.`));const u="reflect"===n?1:0;for(let t=0;t<i.rank;t++)a.hu(2===e[t].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),a.hu(e[t][0]>=0&&e[t][0]<=i.shape[t]-u&&e[t][1]>=0&&e[t][1]<=i.shape[t]-u,(()=>`Padding in dimension ${t} cannot be greater than or equal to ${i.shape[t]-u} or less than 0 for input of shape ${i.shape}`));const c={paddings:e,mode:n},l={x:i};return r.BV.runKernel(o.jQ,l,c)}})},5228:function(t,e,n){"use strict";n.d(e,{w:function(){return i}});var r=n(7097),o=n(9121),s=n(747),a=n(3740);const i=(0,n(2668).op)({mod_:function(t,e){let n=(0,a._1)(t,"a","mod"),i=(0,a._1)(e,"b","mod");[n,i]=(0,s.T_)(n,i);const u={a:n,b:i};return r.BV.runKernelFunc(((t,e)=>{const r=t.mod(n,i);return e([n,i]),r}),u,null,o.Vb)}})},4841:function(t,e,n){"use strict";n.d(e,{d:function(){return i}});var r=n(7097),o=n(9121),s=n(747),a=n(3740);const i=(0,n(2668).op)({mul_:function(t,e){let n=(0,a._1)(t,"a","mul"),i=(0,a._1)(e,"b","mul");[n,i]=(0,s.T_)(n,i);const u={a:n,b:i};return r.BV.runKernelFunc(((t,e)=>{const r=t.multiply(n,i);return e([n,i]),r}),u,null,o.wY)}})},7370:function(t,e,n){"use strict";n.d(e,{W:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({neg_:function(t){const e=(0,s._1)(t,"x","neg"),n={x:e};return r.BV.runKernelFunc((t=>t.neg(e)),n,null,o.L0)}})},3561:function(t,e,n){"use strict";n.d(e,{K:function(){return y}});var r=n(3740),o=n(569),s=n(6235),a=n(3591),i=n(3307),u=n(5735),c=n(2668),l=n(3453),p=n(4968),d=n(9494),h=n(3261),f=n(248),m=n(5475);function g(t,e,n=null){if(0===t.rank)return(0,s.W)(t);if(1!==t.rank&&null===n)return g((0,p.X)(t,[-1]),e,n);if(1===t.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===e)return(0,m.S)((0,s.W)(t),n);if(e===1/0)return(0,i.F)((0,s.W)(t),n);if(e===-1/0)return(0,u.V)((0,s.W)(t),n);if("euclidean"===e||2===e)return(0,h._)((0,m.S)((0,l.s)((0,s.W)(t),(0,d.i)(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&2===n.length){if(1===e)return(0,i.F)((0,m.S)((0,s.W)(t),n[0]),n[1]-1);if(e===1/0)return(0,i.F)((0,m.S)((0,s.W)(t),n[1]),n[0]);if(e===-1/0)return(0,u.V)((0,m.S)((0,s.W)(t),n[1]),n[0]);if("fro"===e||"euclidean"===e)return(0,h._)((0,m.S)((0,f.h)(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const y=(0,c.op)({norm_:function(t,e="euclidean",n=null,s=!1){const i=g(t=(0,r._1)(t,"x","norm"),e,n);let u=i.shape;if(s){const e=(0,o.EC)(n,t.shape);u=a.rv(i.shape,e)}return(0,p.X)(i,u)}})},6500:function(t,e,n){"use strict";n.d(e,{Q:function(){return u}});var r=n(7097),o=n(9121),s=n(747),a=n(3740),i=n(2200);const u=(0,n(2668).op)({notEqual_:function(t,e){let n=(0,a._1)(t,"a","notEqual"),u=(0,a._1)(e,"b","notEqual");[n,u]=(0,s.T_)(n,u),(0,i.$N)(n.shape,u.shape);const c={a:n,b:u};return r.BV.runKernelFunc((t=>t.notEqual(n,u)),c,null,o.yQ)}})},6708:function(t,e,n){"use strict";n.d(e,{l:function(){return u}});var r=n(7097),o=n(9121),s=n(3740),a=n(2668),i=n(4968);const u=(0,a.op)({oneHot_:function(t,e,n=1,a=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const u=(0,s._1)(t,"indices","oneHot","int32"),c=[...u.shape,e],l={indices:u},p={depth:e,onValue:n,offValue:a};return r.BV.runKernelFunc(((t,r)=>(r([u]),(0,i.X)(t.oneHot((0,i.X)(u,[u.size]),e,n,a),c))),l,null,o.we,p)}})},4917:function(t,e,n){"use strict";n.d(e,{i:function(){return i}});var r=n(7097),o=n(569),s=n(1661),a=n(9640);function i(t,e="float32"){if("complex64"===e){const e=i(t,"float32"),n=(0,a.l)(t,"float32");return(0,s.P)(e,n)}const n=(0,o.p8)((0,o.NA)(t),e);return r.BV.makeTensor(n,t,e)}},7846:function(t,e,n){"use strict";n.d(e,{J:function(){return p}});var r=n(7097),o=n(9121),s=n(3740),a=n(1661),i=n(4386),u=n(2668),c=n(766),l=n(6577);const p=(0,u.op)({onesLike_:function(t){const e=(0,s._1)(t,"x","onesLike"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{if("complex64"===e.dtype){const t=p((0,c.k)(e)),n=(0,l.P)((0,i.a)(e));return(0,a.P)(t,n)}return t.onesLike(e)}),n,null,o.qW)}})},2668:function(t,e,n){"use strict";n.d(e,{op:function(){return s}});var r=n(7097),o=n(569);function s(t){const e=Object.keys(t);if(1!==e.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const s=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const a=(...t)=>{r.BV.startScope(n);try{const e=s(...t);return(0,o.tI)(e)&&console.error("Cannot return a Promise inside of tidy."),r.BV.endScope(e),e}catch(t){throw r.BV.endScope(null),t}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}},5410:function(t,e,n){"use strict";n.d(e,{IHx:function(){return r.I},f3b:function(){return o.f},d9v:function(){return s.d},zoF:function(){return a.z},Izb:function(){return u},hiC:function(){return c.h},BHj:function(){return kt},Fp7:function(){return l.F},dC7:function(){return p.d},w6H:function(){return d.w},XLQ:function(){return h.X},iD$:function(){return f.i},XD2:function(){return m.X},tPi:function(){return g.t},XAC:function(){return y.X},knu:function(){return x.k},luU:function(){return v.l},XeE:function(){return b.X},RRF:function(){return w.R},odF:function(){return I},p4s:function(){return k.p},HHK:function(){return E.H},lls:function(){return T.l}});var r=n(6407),o=n(2657),s=n(8723),a=n(6884),i=n(2668);const u=(0,i.op)({concat2d_:function(t,e){return(0,a.z)(t,e)}});var c=n(1274),l=n(3307),p=n(4841),d=n(7245),h=n(4968),f=n(9494),m=n(625),g=n(2676),y=n(682),x=n(2991),v=n(827),b=n(701),w=n(6092),$=n(3740),C=n(569),N=n(7852);function I(t,e,n){if((0,C.Cq)(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const r=(0,$.C)(t,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,N.H)(t,e,r,n)}var E=n(4136),T=n(9640),k=n(9065),S=n(3710),R=n(7020),_=n(8447),A=n(4415);function D(t,e,n){const r=1-t%2,o=new Float32Array(t);for(let s=0;s<t;++s){const a=2*Math.PI*s/(t+r-1);o[s]=e-n*Math.cos(a)}return(0,w.R)(o,"float32")}(0,i.op)({hammingWindow_:function(t){return D(t,.54,.46)}});const O=(0,i.op)({hannWindow_:function(t){return D(t,.5,.5)}});var F=n(4006);const B=(0,i.op)({frame_:function(t,e,n,r=!1,o=0){let s=0;const i=[];for(;s+e<=t.size;)i.push((0,g.t)(t,s,e)),s+=n;if(r)for(;s<t.size;){const r=s+e-t.size,u=(0,a.z)([(0,g.t)(t,s,e-r),(0,F.h)([r],o)]);i.push(u),s+=n}return 0===i.length?I([],[0,e]):(0,h.X)((0,a.z)(i),[i.length,e])}});(0,i.op)({stft_:function(t,e,n,r,o=O){var s;null==r&&(s=e,r=Math.floor(Math.pow(2,Math.ceil(Math.log(s)/Math.log(2)))));const i=B(t,e,n),u=(0,p.d)(i,o(e)),c=[];for(let t=0;t<i.shape[0];t++)c.push((0,S.Q)((0,g.t)(u,[t,0],[1,e]),r));return(0,a.z)(c)}});var P=n(7097),M=n(9121);const L=(0,i.op)({cropAndResize_:function(t,e,n,r,o,s){const a=(0,$._1)(t,"image","cropAndResize"),i=(0,$._1)(e,"boxes","cropAndResize","float32"),u=(0,$._1)(n,"boxInd","cropAndResize","int32");o=o||"bilinear",s=s||0;const c=i.shape[0];C.hu(4===a.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`)),C.hu(2===i.rank&&4===i.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${i.shape}.`)),C.hu(1===u.rank&&u.shape[0]===c,(()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${i.shape}.`)),C.hu(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),C.hu(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),C.hu("bilinear"===o||"nearest"===o,(()=>`method must be bilinear or nearest, but was ${o}`));const l={image:a,boxes:i,boxInd:u},p={method:o,extrapolationValue:s,cropSize:r};return P.BV.runKernelFunc((t=>t.cropAndResize(a,i,u,r,o,s)),l,null,M.Vc,p)}}),V=(0,i.op)({flipLeftRight_:function(t){const e=(0,$._1)(t,"image","flipLeftRight","float32");C.hu(4===e.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`));const n={image:e};return P.BV.runKernel(M.Uy,n,{})}}),W=(0,i.op)({rotateWithOffset_:function(t,e,n=0,r=.5){const o=(0,$._1)(t,"image","rotateWithOffset","float32");C.hu(4===o.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`));const s={image:o},a={radians:e,fillValue:n,center:r};return P.BV.runKernel(M.b9,s,a)}});function U(t,e,n,r,o,s){null==r&&(r=.5),null==o&&(o=Number.NEGATIVE_INFINITY),null==s&&(s=0);const a=t.shape[0];return n=Math.min(n,a),C.hu(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),C.hu(2===t.rank,(()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`)),C.hu(4===t.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`)),C.hu(1===e.rank,(()=>"scores must be a 1D tensor")),C.hu(e.shape[0]===a,(()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`)),C.hu(0<=s&&s<=1,(()=>`softNmsSigma must be in [0, 1], but was '${s}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:o,softNmsSigma:s}}const z=(0,i.op)({nonMaxSuppression_:function(t,e,n,r=.5,o=Number.NEGATIVE_INFINITY){const s=(0,$._1)(t,"boxes","nonMaxSuppression"),a=(0,$._1)(e,"scores","nonMaxSuppression"),i=U(s,a,n,r,o);n=i.maxOutputSize,r=i.iouThreshold,o=i.scoreThreshold;const u={maxOutputSize:n,iouThreshold:r,scoreThreshold:o};return P.BV.runKernelFunc((t=>t.nonMaxSuppression(s,a,n,r,o)),{boxes:s,scores:a},null,M.uv,u)}});var G=n(2055);const X=(0,i.op)({nonMaxSuppressionWithScore_:function(t,e,n,r=.5,o=Number.NEGATIVE_INFINITY,s=0){const a=(0,$._1)(t,"boxes","nonMaxSuppression"),i=(0,$._1)(e,"scores","nonMaxSuppression"),u=U(a,i,n,r,o,s),c={boxes:a,scores:i},l={maxOutputSize:n=u.maxOutputSize,iouThreshold:r=u.iouThreshold,scoreThreshold:o=u.scoreThreshold,softNmsSigma:s=u.softNmsSigma},p=P.BV.runKernel(M.W0,c,l);return{selectedIndices:p[0],selectedScores:p[1]}}}),H=(0,i.op)({nonMaxSuppressionPadded_:function(t,e,n,r=.5,o=Number.NEGATIVE_INFINITY,s=!1){const a=(0,$._1)(t,"boxes","nonMaxSuppression"),i=(0,$._1)(e,"scores","nonMaxSuppression"),u=U(a,i,n,r,o,null),c={boxes:a,scores:i},l={maxOutputSize:u.maxOutputSize,iouThreshold:u.iouThreshold,scoreThreshold:u.scoreThreshold,padToMaxOutputSize:s},p=P.BV.runKernel(M.cy,c,l);return{selectedIndices:p[0],validOutputs:p[1]}}});var j=n(3305),K=n(5098),q=n(7630),Y=n(624),Q=n(2856),Z=n(5912);(0,i.op)({bandPart_:function(t,e,n){(0,C.hu)(e%1==0,(()=>`bandPart(): numLower must be an integer, got ${e}.`)),(0,C.hu)(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`));const r=(0,$._1)(t,"a","bandPart");(0,C.hu)(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const o=r.shape,[s,a]=r.shape.slice(-2);if(!(e<=s))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`);if(!(n<=a))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${a}).`);e<0&&(e=s),n<0&&(n=a);const i=(0,h.X)((0,d.w)(0,s,1,"int32"),[-1,1]),u=(0,d.w)(0,a,1,"int32"),c=(0,v.l)(i,u),l=(0,Q.H)((0,Y.z)(c,(0,f.i)(+e,"int32")),(0,q.b)(c,(0,f.i)(-n,"int32"))),p=(0,T.l)([s,a],r.dtype);return(0,h.X)((0,x.k)((0,E.H)((0,h.X)(r,[-1,s,a])).map((t=>(0,Z.a)(l,t,p)))),o)}});var J=n(3561),tt=n(8644),et=n(9590),nt=n(5475);(0,i.op)({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,(0,C.hu)(null!=t&&t.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=t[0].shape[0];for(let e=1;e<t.length;++e)(0,C.hu)(t[e].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[e].shape[0]} vs. ${n})`))}else e=!0,t=(0,tt.V)(t,t.shape[0],0).map((t=>(0,et.L)(t,[0])));(0,C.hu)(t.length<=t[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`));const n=[],r=t;for(let e=0;e<t.length;++e)n.push(P.BV.tidy((()=>{let t=r[e];if(e>0)for(let r=0;r<e;++r){const e=(0,p.d)((0,nt.S)((0,p.d)(n[r],t)),n[r]);t=(0,v.l)(t,e)}return(0,c.h)(t,(0,J.K)(t,"euclidean"))})));return e?(0,x.k)(n,0):n}});var rt=n(4368),ot=n(1300),st=n(7501);const at=(0,i.op)({eye_:function(t,e,n,r="float32"){null==e&&(e=t);const s=(0,o.f)([t,e],r),a=t<=e?t:e;for(let t=0;t<a;++t)s.set(1,t,t);const i=(0,h.X)(s.toTensor(),[t,e]);if(null==n)return i;if(1===n.length)return(0,st.G)((0,ot.d)(i,0),[n[0],1,1]);if(2===n.length)return(0,st.G)((0,ot.d)((0,ot.d)(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return(0,st.G)((0,ot.d)((0,ot.d)((0,ot.d)(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});var it=n(636),ut=n(8687),ct=n(7370);function lt(t,e=!1){return P.BV.tidy((()=>{(0,C.hu)(2===t.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`));const n=t.shape[0],r=t.shape[1];let o=at(n),i=(0,s.d)(t);const u=I([[1]],[1,1]);let l=(0,s.d)(u);const d=n>=r?r:n;for(let t=0;t<d;++t){const e=i,d=l,h=o;[l,i,o]=P.BV.tidy((()=>{const e=(0,g.t)(i,[t,t],[n-t,1]),d=(0,J.K)(e),h=(0,g.t)(i,[t,t],[1,1]),f=(0,Z.a)((0,it.p)(h,0),I([[-1]]),I([[1]])),m=(0,v.l)(h,(0,p.d)(f,d)),y=(0,c.h)(e,m);l=1===y.shape[0]?(0,s.d)(u):(0,a.z)([u,(0,g.t)(y,[1,0],[y.shape[0]-1,y.shape[1]])],0);const x=(0,ct.W)((0,c.h)((0,ut.O)(f,m),d)),b=(0,g.t)(i,[t,0],[n-t,r]),w=(0,p.d)(x,l),$=(0,k.p)(l);if(0===t)i=(0,v.l)(b,(0,ut.O)(w,(0,ut.O)($,b)));else{const e=(0,v.l)(b,(0,ut.O)(w,(0,ut.O)($,b)));i=(0,a.z)([(0,g.t)(i,[0,0],[t,r]),e],0)}const C=(0,k.p)(w),N=(0,g.t)(o,[0,t],[n,o.shape[1]-t]);if(0===t)o=(0,v.l)(N,(0,ut.O)((0,ut.O)(N,l),C));else{const e=(0,v.l)(N,(0,ut.O)((0,ut.O)(N,l),C));o=(0,a.z)([(0,g.t)(o,[0,0],[n,t]),e],1)}return[l,i,o]})),(0,rt.B9)([e,d,h])}return!e&&n>r&&(o=(0,g.t)(o,[0,0],[n,r]),i=(0,g.t)(i,[0,0],[r,r])),[o,i]}))}(0,i.op)({qr_:function(t,e=!1){if((0,C.hu)(t.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`)),2===t.rank)return lt(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce(((t,e)=>t*e)),r=(0,E.H)((0,h.X)(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),o=[],s=[];return r.forEach((t=>{const[n,r]=lt(t,e);o.push(n),s.push(r)})),[(0,h.X)((0,x.k)(o,0),t.shape),(0,h.X)((0,x.k)(s,0),t.shape)]}}});var pt,dt=n(6235);!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(pt||(pt={}));var ht=n(2271),ft=n(5130),mt=n(6500),gt=n(4917);const yt=(0,i.op)({computeWeightedLoss_:function(t,e,n=pt.SUM_BY_NONZERO_WEIGHTS){const r=(0,$._1)(t,"losses","computeWeightedLoss");let o=null;null!=e&&(o=(0,$._1)(e,"weights","computeWeightedLoss"));const s=null==o?r:(0,p.d)(r,o);if(n===pt.NONE)return s;if(n===pt.SUM)return(0,nt.S)(s);if(n===pt.MEAN){if(null==o)return(0,ft.J)(s);{const t=r.size/o.size,e=(0,c.h)((0,nt.S)(s),(0,nt.S)(o));return t>1?(0,c.h)(e,(0,f.i)(t)):e}}if(n===pt.SUM_BY_NONZERO_WEIGHTS){if(null==o)return(0,c.h)((0,nt.S)(s),(0,f.i)(r.size));{const t=(0,p.d)(o,(0,gt.i)(r.shape)),e=(0,ht.p)((0,nt.S)((0,mt.Q)(t,(0,f.i)(0))),"float32");return(0,c.h)((0,nt.S)(s),e)}}throw Error(`Unknown reduction: ${n}`)}});(0,i.op)({absoluteDifference_:function(t,e,n,r=pt.SUM_BY_NONZERO_WEIGHTS){const o=(0,$._1)(t,"labels","absoluteDifference"),s=(0,$._1)(e,"predictions","absoluteDifference");let a=null;null!=n&&(a=(0,$._1)(n,"weights","absoluteDifference")),(0,C.k5)(o.shape,s.shape,"Error in absoluteDifference: ");const i=(0,dt.W)((0,v.l)(o,s));return yt(i,a,r)}}),(0,i.op)({cosineDistance_:function(t,e,n,r,o=pt.SUM_BY_NONZERO_WEIGHTS){const s=(0,$._1)(t,"labels","cosineDistance"),a=(0,$._1)(e,"predictions","cosineDistance");let i=null;null!=r&&(i=(0,$._1)(r,"weights","cosineDistance")),(0,C.k5)(s.shape,a.shape,"Error in cosineDistance: ");const u=(0,f.i)(1),c=(0,v.l)(u,(0,nt.S)((0,p.d)(s,a),n,!0));return yt(c,i,o)}});var xt=n(7409);(0,i.op)({hingeLoss_:function(t,e,n,r=pt.SUM_BY_NONZERO_WEIGHTS){let o=(0,$._1)(t,"labels","hingeLoss");const s=(0,$._1)(e,"predictions","hingeLoss");let a=null;null!=n&&(a=(0,$._1)(n,"weights","hingeLoss")),(0,C.k5)(o.shape,s.shape,"Error in hingeLoss: ");const i=(0,f.i)(1);o=(0,v.l)((0,p.d)((0,f.i)(2),o),i);const u=(0,xt.U)((0,v.l)(i,(0,p.d)(o,s)));return yt(u,a,r)}});var vt=n(4513),bt=n(248);(0,i.op)({huberLoss_:function(t,e,n,o=1,s=pt.SUM_BY_NONZERO_WEIGHTS){const a=(0,$._1)(t,"labels","huberLoss"),i=(0,$._1)(e,"predictions","huberLoss");let u=null;null!=n&&(u=(0,$._1)(n,"weights","huberLoss")),(0,C.k5)(a.shape,i.shape,"Error in huberLoss: ");const c=(0,f.i)(o),l=(0,dt.W)((0,v.l)(i,a)),d=(0,vt.L)(l,c),h=(0,v.l)(l,d),m=(0,r.I)((0,p.d)((0,f.i)(.5),(0,bt.h)(d)),(0,p.d)(c,h));return yt(m,u,s)}});var wt=n(2597);(0,i.op)({logLoss_:function(t,e,n,o=1e-7,s=pt.SUM_BY_NONZERO_WEIGHTS){const a=(0,$._1)(t,"labels","logLoss"),i=(0,$._1)(e,"predictions","logLoss");let u=null;null!=n&&(u=(0,$._1)(n,"weights","logLoss")),(0,C.k5)(a.shape,i.shape,"Error in logLoss: ");const c=(0,f.i)(1),l=(0,f.i)(o),d=(0,ct.W)((0,p.d)(a,(0,wt.c)((0,r.I)(i,l)))),h=(0,p.d)((0,v.l)(c,a),(0,wt.c)((0,r.I)((0,v.l)(c,i),l))),m=(0,v.l)(d,h);return yt(m,u,s)}});var $t=n(5265);(0,i.op)({meanSquaredError_:function(t,e,n,r=pt.SUM_BY_NONZERO_WEIGHTS){const o=(0,$._1)(t,"labels","meanSquaredError"),s=(0,$._1)(e,"predictions","meanSquaredError");let a=null;null!=n&&(a=(0,$._1)(n,"weights","meanSquaredError")),(0,C.k5)(o.shape,s.shape,"Error in meanSquaredError: ");const i=(0,$t.$)(o,s);return yt(i,a,r)}});var Ct=n(4842),Nt=n(7474);(0,i.op)({sigmoidCrossEntropy_:function(t,e,n,o=0,s=pt.SUM_BY_NONZERO_WEIGHTS){let a=(0,$._1)(t,"multiClassLabels","sigmoidCrossEntropy");const i=(0,$._1)(e,"logits","sigmoidCrossEntropy");let u=null;if(null!=n&&(u=(0,$._1)(n,"weights","sigmoidCrossEntropy")),(0,C.k5)(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),o>0){const t=(0,f.i)(o),e=(0,f.i)(1),n=(0,f.i)(.5);a=(0,r.I)((0,p.d)(a,(0,v.l)(e,t)),(0,p.d)(n,t))}const c=function(t,e){const n=(0,$._1)(t,"labels","sigmoidCrossEntropyWithLogits"),o=(0,$._1)(e,"logits","sigmoidCrossEntropyWithLogits");(0,C.k5)(n.shape,o.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=(0,xt.U)(o),a=(0,p.d)(o,n),i=(0,Nt.K)((0,Ct.Q)((0,ct.W)((0,dt.W)(o))));return(0,r.I)((0,v.l)(s,a),i)}(a,i);return yt(c,u,s)}});var It=n(633),Et=n(3591),Tt=n(1391);(0,i.op)({softmaxCrossEntropy_:function(t,e,n,o=0,s=pt.SUM_BY_NONZERO_WEIGHTS){let a=(0,$._1)(t,"onehotLabels","softmaxCrossEntropy");const i=(0,$._1)(e,"logits","softmaxCrossEntropy");let u=null;if(null!=n&&(u=(0,$._1)(n,"weights","softmaxCrossEntropy")),(0,C.k5)(a.shape,i.shape,"Error in softmaxCrossEntropy: "),o>0){const t=(0,f.i)(o),e=(0,f.i)(1),n=(0,f.i)(a.shape[1]);a=(0,r.I)((0,p.d)(a,(0,v.l)(e,t)),(0,c.h)(t,n))}const l=function(t,e,n=-1){if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return(0,It.cb)(((t,e,r)=>{const o=(0,Tt.l)(e,[n],!0),s=(0,v.l)((0,ht.p)(e,"float32"),o);r([t,s]);const a=(0,ct.W)((0,p.d)(s,t));return{value:(0,nt.S)(a,[n]),gradFunc:(t,e)=>{const[r,o]=e,s=(0,Et.rv)(t.shape,[n]);return[(0,p.d)((0,h.X)(t,s),(0,v.l)((0,ht.p)(r,"float32"),(0,Ct.Q)(o))),(0,p.d)((0,h.X)(t,s),(0,v.l)((0,Ct.Q)(o),(0,ht.p)(r,"float32")))]}}}))(t,e)}(a,i);return yt(l,u,s)}}),R.k,_.S,S.Q,A.w;const kt={flipLeftRight:V,resizeNearestNeighbor:K.j,resizeBilinear:j.I,rotateWithOffset:W,cropAndResize:L,nonMaxSuppression:z,nonMaxSuppressionAsync:async function(t,e,n,r=.5,o=Number.NEGATIVE_INFINITY){const s=(0,$._1)(t,"boxes","nonMaxSuppressionAsync"),a=(0,$._1)(e,"scores","nonMaxSuppressionAsync"),i=U(s,a,n,r,o);n=i.maxOutputSize,r=i.iouThreshold,o=i.scoreThreshold;const u=await Promise.all([s.data(),a.data()]),c=u[0],l=u[1],p=(0,G.GP)(c,l,n,r,o);return s!==t&&s.dispose(),a!==e&&a.dispose(),p},nonMaxSuppressionWithScore:X,nonMaxSuppressionWithScoreAsync:async function(t,e,n,r=.5,o=Number.NEGATIVE_INFINITY,s=0){const a=(0,$._1)(t,"boxes","nonMaxSuppressionAsync"),i=(0,$._1)(e,"scores","nonMaxSuppressionAsync"),u=U(a,i,n,r,o,s);n=u.maxOutputSize,r=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;const c=await Promise.all([a.data(),i.data()]),l=c[0],p=c[1],d=(0,G.pA)(l,p,n,r,o,s);return a!==t&&a.dispose(),i!==e&&i.dispose(),d},nonMaxSuppressionPadded:H,nonMaxSuppressionPaddedAsync:async function(t,e,n,r=.5,o=Number.NEGATIVE_INFINITY,s=!1){const a=(0,$._1)(t,"boxes","nonMaxSuppressionAsync"),i=(0,$._1)(e,"scores","nonMaxSuppressionAsync"),u=U(a,i,n,r,o,null),c=u.maxOutputSize,l=u.iouThreshold,p=u.scoreThreshold,[d,h]=await Promise.all([a.data(),i.data()]),f=(0,G.qP)(d,h,c,l,p,s);return a!==t&&a.dispose(),i!==e&&i.dispose(),f}}},9682:function(t,e,n){"use strict";n.d(e,{v:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({pad_:function(t,e,n=0){const a=(0,s._1)(t,"x","pad");if(0===a.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:e,constantValue:n},u={x:a};return r.BV.runKernelFunc(((t,r)=>(r([a]),t.pad(a,e,n))),u,null,o.ly,i)}})},3453:function(t,e,n){"use strict";n.d(e,{s:function(){return i}});var r=n(7097),o=n(9121),s=n(747),a=n(3740);const i=(0,n(2668).op)({pow_:function(t,e){let n=(0,a._1)(t,"base","pow"),i=(0,a._1)(e,"exp","pow");[n,i]=(0,s.T_)(n,i);const u={a:n,b:i};return r.BV.runKernelFunc(((t,e)=>{const r=t.pow(n,i);return e([n,i,r]),r}),u,null,o.pe)}})},8151:function(t,e,n){"use strict";n.d(e,{A:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({prelu_:function(t,e){const n=(0,s._1)(t,"x","prelu"),a=(0,s._1)(e,"alpha","prelu"),i={x:n,alpha:a};return r.BV.runKernelFunc(((t,e)=>{const r=t.prelu(n,a);return e([n,a]),r}),i,null,o.o0)}})},9451:function(t,e,n){"use strict";n.d(e,{W:function(){return d}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(3591),u=n(2271),c=n(2668),l=n(4968),p=n(9065);const d=(0,c.op)({prod_:function(t,e=null,n=!1){let c=(0,s._1)(t,"x","prod");"bool"===c.dtype&&(c=(0,u.p)(c,"int32"));const d={x:c},h={axis:e,keepDims:n};return r.BV.runKernelFunc((t=>{const r=(0,a.EC)(e,c.shape),o=(0,i.Q3)(r,c.rank);let s=r,u=c;null!=o&&(u=(0,p.p)(c,o),s=(0,i.sY)(s.length,c.rank));let d=t.prod(u,s);if(n){const t=(0,i.rv)(d.shape,r);d=(0,l.X)(d,t)}return d}),d,null,o.Dl,h)}})},7245:function(t,e,n){"use strict";n.d(e,{w:function(){return u}});var r=n(7097),o=n(9121),s=n(569),a=n(6092),i=n(9640);function u(t,e,n=1,u="float32"){if(0===n)throw new Error("Cannot have a step of zero");const c={start:t,stop:e,step:n,dtype:u};return r.BV.runKernelFunc((()=>{if(t===e||t<e&&n<0||e<t&&n>1)return(0,i.l)([0],u);const r=Math.abs(Math.ceil((e-t)/n)),o=(0,s.wT)(r,u);e<t&&1===n&&(n=-1),o[0]=t;for(let t=1;t<o.length;t++)o[t]=o[t-1]+n;return(0,a.R)(o,u)}),{},null,o.e6,c)}},766:function(t,e,n){"use strict";n.d(e,{k:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({real_:function(t){const e=(0,s._1)(t,"input","real"),n={input:e};return r.BV.runKernelFunc((t=>t.real(e)),n,null,o.xJ)}})},9036:function(t,e,n){"use strict";n.d(e,{M:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({reciprocal_:function(t){const e=(0,s._1)(t,"x","reciprocal"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.reciprocal(e);return n([e]),r}),n,null,o.$H)}})},5466:function(t,e,n){"use strict";n.d(e,{g:function(){return o},A:function(){return s}});var r=n(569);const o=30;function s(t){return t<=o?t:(0,r.jP)(t,Math.floor(Math.sqrt(t)))}},7409:function(t,e,n){"use strict";n.d(e,{U:function(){return u}});var r=n(7097),o=n(9121),s=n(3740),a=n(2668),i=n(2271);const u=(0,a.op)({relu_:function(t){const e=(0,s._1)(t,"x","relu"),n={x:e};return r.BV.runKernelFunc(((t,n)=>(n([e]),"bool"===e.dtype?(0,i.p)(e,"int32"):t.relu(e))),n,null,o.qk)}})},3582:function(t,e,n){"use strict";n.d(e,{b:function(){return i}});var r=n(7097),o=n(9121),s=n(3740),a=n(2271);const i=(0,n(2668).op)({relu6_:function(t){const e=(0,s._1)(t,"x","relu6"),n={x:e};return r.BV.runKernelFunc(((t,n)=>(n([e]),"bool"===e.dtype?(0,a.p)(e,"int32"):t.relu6(e))),n,null,o.Sb)}})},4968:function(t,e,n){"use strict";n.d(e,{X:function(){return i}});var r=n(7097),o=n(9121),s=n(3740),a=n(569);const i=(0,n(2668).op)({reshape_:function(t,e){const n=(0,s._1)(t,"x","reshape",null),i={x:n},u={shape:e};return r.BV.runKernelFunc(((t,r)=>(e=a.JZ(e,n.size),a.hu(n.size===a.NA(e),(()=>"new shape and old shape must have the same number of elements.")),r([n]),t.reshape(n,e))),i,null,o.HZ,u)}})},7486:function(t,e,n){"use strict";n.d(e,{G:function(){return l}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(8723),u=n(2668),c=n(4968);const l=(0,u.op)({reverse_:function(t,e){const n=(0,s._1)(t,"x","reverse"),u={x:n},l={dims:e};return r.BV.runKernelFunc((t=>{const r=(0,a.EC)(e,n.shape);if(0===n.rank)return(0,i.d)(n);const o=t.reverse(n,r);return(0,c.X)(o,n.shape)}),u,null,o.mK,l)}})},7809:function(t,e,n){"use strict";n.d(e,{N:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({round_:function(t){const e=(0,s._1)(t,"x","round"),n={x:e};return r.BV.runKernelFunc((t=>t.round(e)),n,null,o.e0)}})},2634:function(t,e,n){"use strict";n.d(e,{b:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({rsqrt_:function(t){const e=(0,s._1)(t,"x","rsqrt"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.rsqrt(e);return n([e]),r}),n,null,o.bV)}})},9494:function(t,e,n){"use strict";n.d(e,{i:function(){return s}});var r=n(569),o=n(7852);function s(t,e){if(((0,r.fU)(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&(0,r.fU)(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,o.H)(t,[],[],e)}},3028:function(t,e,n){"use strict";n.d(e,{l5:function(){return o},b0:function(){return s},SU:function(){return a}});var r=n(569);function o(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,o=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${o}.`;if(n.rank<o)throw new Error(s+` update.rank < ${o}. `);if(t.length<r+(n.rank-o))throw new Error(s+` Output shape length < ${r+(n.rank-o)}`);if(n.rank!==o+t.length-r)throw new Error(s+" update.rank != "+(o+t.length-r));for(let t=0;t<o;++t)if(n.shape[t]!==e.shape[t])throw new Error(s+` updates.shape[${t}] (${n.shape[t]}) != indices.shape[${t}] (${e.shape[t]}).`);for(let e=0;e<n.rank-o;++e)if(n.shape[e+o]!==t[e+r])throw new Error(s+` updates.shape[${e+o}] (${n.shape[e+o]}) != shape[${e+o}] (${t[e+o]})`)}function s(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===e.size)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}o(n,e,t)}function a(t,e,n){const o=e.shape.length,s=o>1?e.shape[o-1]:1,a=n.length;let i=1;for(let t=s;t<a;++t)i*=n[t];const u=s<1?1:s;return{sliceRank:s,numUpdates:(0,r.NA)(e.shape)/u,sliceSize:i,strides:[...(0,r.e3)(n.slice(0,s)),1],outputSize:(0,r.NA)(n)}}},4931:function(t,e,n){"use strict";n.r(e),n.d(e,{segOpComputeOptimalWindowSize:function(){return s},computeOutShape:function(){return a},collectGatherOpShapeInfo:function(){return i}});var r=n(569),o=n(5466);function s(t,e){let n,s=!1;for(t<=o.g?(n=t,s=!0):n=(0,r.jP)(t,Math.floor(Math.sqrt(t)));!s;)n>e||n===t?s=!0:n=(0,r.jP)(t,n+1);return n}function a(t,e,n){const r=[],o=t.length;for(let s=0;s<o;s++)s!==e?r.push(t[s]):r.push(n);return r}function i(t,e,n){const r=t.shape[n],o=[];let s=1,a=1;for(let e=0;e<n;e++)o.push(t.shape[e]),s*=t.shape[e];for(let t=0;t<e.rank;t++)o.push(e.shape[t]);for(let e=n+1;e<t.rank;e++)o.push(t.shape[e]),a*=t.shape[e];return{batchSize:s,sliceSize:a,dimSize:r,outputShape:o}}},5503:function(t,e,n){"use strict";n.d(e,{U:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({selu_:function(t){const e=(0,s._1)(t,"x","selu"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.selu(e);return n([e]),r}),n,null,o.oF)}})},625:function(t,e,n){"use strict";n.d(e,{X:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({sigmoid_:function(t){const e=(0,s._1)(t,"x","sigmoid"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.sigmoid(e);return n([r]),r}),n,null,o.a5)}})},4434:function(t,e,n){"use strict";n.d(e,{X:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({sign_:function(t){const e=(0,s._1)(t,"x","sign"),n={x:e};return r.BV.runKernelFunc((t=>t.sign(e)),n,null,o.i5)}})},9331:function(t,e,n){"use strict";n.d(e,{O:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({sin_:function(t){const e=(0,s._1)(t,"x","sin"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.sin(e);return n([e]),r}),n,null,o.RQ)}})},3254:function(t,e,n){"use strict";n.d(e,{R:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({sinh_:function(t){const e=(0,s._1)(t,"x","sinh"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.sinh(e);return n([e]),r}),n,null,o.w3)}})},2676:function(t,e,n){"use strict";n.d(e,{t:function(){return u}});var r=n(7097),o=n(9121),s=n(3740),a=n(2668),i=n(7650);const u=(0,a.op)({slice_:function(t,e,n){const a=(0,s._1)(t,"x","slice");if(0===a.rank)throw new Error("Slicing scalar is not possible");const u={x:a},c={begin:e,size:n};return r.BV.runKernelFunc(((t,r)=>{const[o,s]=i.parseSliceParams(a,e,n);return i.assertParamsValid(a,o,s),r([a]),t.slice(a,o,s)}),u,null,o.p2,c)}})},7650:function(t,e,n){"use strict";n.r(e),n.d(e,{assertParamsValid:function(){return o},maskToAxes:function(){return s},computeOutShape:function(){return a},stridesWithElidedDims:function(){return i},getNormalizedAxes:function(){return l},startIndicesWithElidedDims:function(){return p},stopIndicesWithElidedDims:function(){return d},stridesForAxis:function(){return h},startForAxis:function(){return f},stopForAxis:function(){return m},isSliceContinous:function(){return g},computeFlatOffset:function(){return y},parseSliceParams:function(){return x}});var r=n(569);function o(t,e,n){const o=t.shape.length;r.hu(o===e.length,(()=>`Error in slice${o}D: Length of begin ${e} must match the rank of the array (${o}).`)),r.hu(o===n.length,(()=>`Error in slice${o}D: Length of size ${n} must match the rank of the array (${o}).`));for(let s=0;s<o;++s)r.hu(e[s]+n[s]<=t.shape[s],(()=>`Error in slice${o}D: begin[${s}] + size[${s}] (${e[s]+n[s]}) would overflow input.shape[${s}] (${t.shape[s]})`))}function s(t){const e=[];let n=0;for(;t>0;)1&t&&e.push(n),t/=2,n++;return e}function a(t,e,n){const r=[];for(let o=0;o<t.length;o++)r[o]=Math.ceil((e[o]-t[o])/n[o]);return r}function i(t,e,n,r){const o=[...t];for(let t=o.length;t<r.length;t++)o.push(1);for(let t=0;t<n;t++)0===t?o[e]=1:(o.splice(e,0,1),o.pop());return o}function u(t,e,n){return n<=t?n:n-(e-1)}function c(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function l(t,e,n,r,o,s,a,u,c){const l=t.length;let g=new Array(l),y=new Array(l),x=new Array(l);if(e.length&&n>0){const c=e[0],l=n+1;g=p(a,c,l,r,t),y=d(u,c,l,o,t),x=i(s,c,l,t)}else for(let e=0;e<l;e++)g[e]=f(a,r,s,t,e,c),y[e]=m(u,o,s,t,e,c),x[e]=h(s,e,c);return{begin:g,end:y,strides:x}}function p(t,e,n,r,o){const s=[...o],a=c(n,e);for(let o=0;o<s.length;o++)if(a.indexOf(o)>-1)s[o]=0;else{const a=u(e,n,o);let i=r[a];t&1<<a&&(i=0),s[o]=i}return s}function d(t,e,n,o,s){const a=[...s],i=c(n,e);for(let r=0;r<a.length;r++)if(i.indexOf(r)>-1)a[r]=Number.MAX_SAFE_INTEGER;else{const s=u(e,n,r);let i=o[s];t&1<<s&&(i=Number.MAX_SAFE_INTEGER),a[r]=i}for(let t=0;t<a.length;t++){const e=s[t];a[t]<0&&(a[t]+=e),a[t]=r.uZ(0,a[t],s[t])}return a}function h(t,e,n){let r=t[e];return(n&1<<e||null==r)&&(r=1),r}function f(t,e,n,o,s,a){let i=e[s];const u=n[s]||1;(t&1<<s||a&1<<s||null==i)&&(i=u>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const c=o[s];return i<0&&(i+=c),i=r.uZ(0,i,c-1),i}function m(t,e,n,o,s,a){let i=e[s];const u=n[s]||1;(t&1<<s||a&1<<s||null==i)&&(i=u>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const c=o[s];return i<0&&(i+=c),i=u>0?r.uZ(0,i,c):r.uZ(-1,i,c-1),i}function g(t,e,n){let r=n.length;for(let t=0;t<n.length;t++)if(n[t]>1){r=t;break}for(let o=r+1;o<n.length;o++)if(e[o]>0||n[o]!==t[o])return!1;return!0}function y(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function x(t,e,n){let o;const s=t.shape.length;let a;return o="number"==typeof e?[e,...new Array(s-1).fill(0)]:e.length<s?e.concat(new Array(s-e.length).fill(0)):e.slice(),o.forEach((t=>{r.hu(-1!==t,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map(((e,n)=>e>=0?e:(r.hu(-1===e,(()=>`Negative size values should be exactly -1 but got ${e} for the slice() size at index ${n}.`)),t.shape[n]-o[n]))),[o,a]}},682:function(t,e,n){"use strict";n.d(e,{X:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({softmax_:function(t,e=-1){const n=(0,s._1)(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const a={logits:n},i={dim:e};return r.BV.runKernelFunc(((t,r)=>{const o=t.softmax(n,e);return r([o]),o}),a,null,o.Gc,i)}})},3694:function(t,e,n){"use strict";n.d(e,{W:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({softplus_:function(t){const e=(0,s._1)(t,"x","softplus"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.softplus(e);return n([e]),r}),n,null,o.MR)}})},7918:function(t,e,n){"use strict";n.d(e,{f:function(){return i}});var r=n(7097),o=n(9121),s=n(3740),a=n(569);const i=(0,n(2668).op)({spaceToBatchND_:function(t,e,n){const i=(0,s._1)(t,"x","spaceToBatchND");a.hu(i.rank>=1+e.length,(()=>`input rank ${i.rank} should be > than [blockShape] ${e.length}`)),a.hu(n.length===e.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`)),a.hu(i.shape.reduce(((t,r,o)=>o>0&&o<=e.length?t&&(r+n[o-1][0]+n[o-1][1])%e[o-1]==0:t),!0),(()=>`input spatial dimensions ${i.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`));const u={x:i},c={blockShape:e,paddings:n};return r.BV.runKernelFunc((t=>t.spaceToBatchND(i,e,n)),u,null,o.TQ,c)}})},7020:function(t,e,n){"use strict";n.d(e,{k:function(){return a}});var r=n(7097),o=n(9121),s=n(569);const a=(0,n(2668).op)({fft_:function(t){(0,s.hu)("complex64"===t.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`));const e={input:t};return r.BV.runKernelFunc((e=>{const n=t.shape[t.shape.length-1],r=t.size/n,o=t.as2D(r,n);return e.fft(o).reshape(t.shape)}),e,null,o.vw)}})},8447:function(t,e,n){"use strict";n.d(e,{S:function(){return u}});var r=n(7097),o=n(9121),s=n(569),a=n(2668),i=n(4968);const u=(0,a.op)({ifft_:function(t){(0,s.hu)("complex64"===t.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`));const e={input:t};return r.BV.runKernelFunc((e=>{const n=t.shape[t.shape.length-1],r=t.size/n,o=(0,i.X)(t,[r,n]),s=e.ifft(o);return(0,i.X)(s,t.shape)}),e,null,o.Qg)}})},4415:function(t,e,n){"use strict";n.d(e,{w:function(){return f}});var r=n(1661),o=n(6884),s=n(4386),a=n(4841),i=n(2668),u=n(766),c=n(4968),l=n(7486),p=n(9494),d=n(2676),h=n(8447);const f=(0,i.op)({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let i;if(e<=2){const r=(0,c.X)(t,[n,e]);i=(0,h.S)(r)}else{const f=[n,2*(e-1)],m=(0,c.X)((0,u.k)(t),[n,e]),g=(0,c.X)((0,s.a)(t),[n,e]),y=(0,l.G)((0,d.t)(m,[0,1],[n,e-2]),1),x=(0,a.d)((0,l.G)((0,d.t)(g,[0,1],[n,e-2]),1),(0,p.i)(-1)),v=(0,o.z)([m,y],1),b=(0,o.z)([g,x],1),w=(0,c.X)((0,r.P)(v,b),[f[0],f[1]]);i=(0,h.S)(w)}if(i=(0,u.k)(i),3===t.rank&&0!==t.shape[0]){const e=i,n=t.shape[0];i=(0,c.X)(i,[n,i.shape[0]/n,i.shape[1]]),e.dispose()}return i}})},3710:function(t,e,n){"use strict";n.d(e,{Q:function(){return m}});var r=n(569),o=n(1661),s=n(6884),a=n(4386),i=n(2668),u=n(766),c=n(4968),l=n(2676),p=n(8644),d=n(9640),h=n(6577),f=n(7020);const m=(0,i.op)({rfft_:function(t,e){(0,r.hu)("float32"===t.dtype,(()=>`The dtype for rfft() must be real value but got ${t.dtype}`));let n=t.shape[t.shape.length-1];const i=t.size/n;let m;if(null!=e&&e<n){const r=t.shape.map((t=>0)),o=t.shape.map((t=>t));o[t.shape.length-1]=e,m=(0,l.t)(t,r,o),n=e}else if(null!=e&&e>n){const r=t.shape.map((t=>t));r[t.shape.length-1]=e-n,m=(0,s.z)([t,(0,d.l)(r)],t.shape.length-1),n=e}else m=t;const g=(0,h.P)(m),y=(0,c.X)((0,o.P)(m,g),[i,n]),x=(0,f.k)(y),v=Math.floor(n/2)+1,b=(0,u.k)(x),w=(0,a.a)(x),$=(0,p.V)(b,[v,n-v],b.shape.length-1),C=(0,p.V)(w,[v,n-v],w.shape.length-1),N=m.shape.slice();return N[m.shape.length-1]=v,(0,c.X)((0,o.P)($[0],C[0]),N)}})},8644:function(t,e,n){"use strict";n.d(e,{V:function(){return c}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(2668),u=n(4099);const c=(0,i.op)({split_:function(t,e,n=0){const i=(0,s._1)(t,"x","split"),c={x:i},l={numOrSizeSplits:e,axis:n};return r.BV.runKernelFunc(((t,r)=>{const o=(0,a.EC)(n,i.shape)[0],s=(0,u.O)(i,e,o);return t.split(i,s,o)}),c,null,o.L8,l)}})},4099:function(t,e,n){"use strict";n.d(e,{O:function(){return o}});var r=n(569);function o(t,e,n=0){let o=[];if("number"==typeof e)(0,r.hu)(t.shape[n]%e==0,(()=>"Number of splits must evenly divide the axis.")),o=new Array(e).fill(t.shape[n]/e);else{const s=e.reduce(((t,e)=>(-1===e&&(t+=1),t)),0);(0,r.hu)(s<=1,(()=>"There should be only one negative value in split array."));const a=e.indexOf(-1);if(-1!==a){const r=e.reduce(((t,e)=>e>0?t+e:t));e[a]=t.shape[n]-r}(0,r.hu)(t.shape[n]===e.reduce(((t,e)=>t+e)),(()=>"The sum of sizes must match the size of the axis dimension.")),o=e}return o}},3261:function(t,e,n){"use strict";n.d(e,{_:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({sqrt_:function(t){const e=(0,s._1)(t,"x","sqrt"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.sqrt(e);return n([e]),r}),n,null,o.FK)}})},248:function(t,e,n){"use strict";n.d(e,{h:function(){return s}});var r=n(7097),o=n(3740);const s=(0,n(2668).op)({square_:function(t){const e=(0,o._1)(t,"x","square"),n=[e];return r.BV.runKernelFunc(((t,n)=>(n([e]),t.square(e))),{x:e},null,"Square",{},n,[])}})},5265:function(t,e,n){"use strict";n.d(e,{$:function(){return u}});var r=n(7097),o=n(9121),s=n(747),a=n(3740),i=n(2200);const u=(0,n(2668).op)({squaredDifference_:function(t,e){let n=(0,a._1)(t,"a","squaredDifference"),u=(0,a._1)(e,"b","squaredDifference");[n,u]=(0,s.T_)(n,u),(0,i.$N)(n.shape,u.shape);const c={a:n,b:u};return r.BV.runKernelFunc(((t,e)=>{const r=t.squaredDifference(n,u);return e([n,u]),r}),c,null,o._t,{})}})},9590:function(t,e,n){"use strict";n.d(e,{L:function(){return i}});var r=n(3740),o=n(569),s=n(2668),a=n(4968);const i=(0,s.op)({squeeze_:function(t,e){const n=(0,r._1)(t,"x","squeeze");return(0,a.X)(n,(0,o.bp)(n.shape,e).newShape)}})},2991:function(t,e,n){"use strict";n.d(e,{k:function(){return i}});var r=n(3740),o=n(569),s=n(6884),a=n(1300);const i=(0,n(2668).op)({stack_:function(t,e=0){const n=(0,r.sI)(t,"tensors","stack");if(o.hu(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),1===n.length)return(0,a.d)(n[0],e);const i=n[0].rank,u=n[0].shape,c=n[0].dtype;o.hu(e<=i,(()=>"Axis must be <= rank of the tensor")),n.forEach((t=>{o.k5(u,t.shape,"All tensors passed to stack must have matching shapes"),o.hu(c===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const l=n.map((t=>(0,a.d)(t,e)));return(0,s.z)(l,e)}})},1901:function(t,e,n){"use strict";n.d(e,{N:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({step_:function(t,e=0){const n=(0,s._1)(t,"x","step"),a={x:n},i={alpha:e};return r.BV.runKernelFunc((t=>t.step(n,e)),a,null,o.h8,i)}})},5158:function(t,e,n){"use strict";n.d(e,{N:function(){return l}});var r=n(7097),o=n(9121),s=n(3740),a=n(2668),i=n(4968),u=n(2676),c=n(7650);const l=(0,a.op)({stridedSlice_:function(t,e,n,a,l=0,p=0,d=0,h=0,f=0){let m=(0,s._1)(t,"x","stridedSlice");const g={x:m},y={begin:e,end:n,strides:a,beginMask:l,endMask:p,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:f};return r.BV.runKernelFunc((t=>{null==a&&(a=new Array(e.length));const r=(0,c.maskToAxes)(d);if(r.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==d&&0!==h)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==d&&0!==f)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const o=m.rank-e.length,s=(0,c.maskToAxes)(h),g=m.shape.slice();s.forEach((t=>{e[t]=0,n[t]=1,g.splice(t,0,1)})),m=(0,i.X)(m,g);const{begin:y,end:x,strides:v}=(0,c.getNormalizedAxes)(m.shape,r,o,e,n,a,l,p,d);e=y,n=x,a=v;const b=(0,c.maskToAxes)(f);b.forEach((t=>{n[t]=e[t]+1,a[t]=1}));const w=(0,c.computeOutShape)(e,n,a),$=w.filter(((t,e)=>-1===b.indexOf(e)));if(a.every((t=>1===t)))return(0,i.X)((0,u.t)(m,e,w),$);const C=t.stridedSlice(m,e,n,a);return(0,i.X)(C,$)}),g,null,o.m2,y)}})},827:function(t,e,n){"use strict";n.d(e,{l:function(){return i}});var r=n(7097),o=n(9121),s=n(747),a=n(3740);const i=(0,n(2668).op)({sub_:function(t,e){let n=(0,a._1)(t,"a","sub"),i=(0,a._1)(e,"b","sub");[n,i]=(0,s.T_)(n,i);const u={a:n,b:i};return r.BV.runKernelFunc(((t,e)=>{const r=t.subtract(n,i);return e([n,i]),r}),u,null,o.Tr)}})},5475:function(t,e,n){"use strict";n.d(e,{S:function(){return d}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(3591),u=n(2271),c=n(2668),l=n(4968),p=n(9065);const d=(0,c.op)({sum_:function(t,e=null,n=!1){let c=(0,s._1)(t,"x","sum");"bool"===c.dtype&&(c=(0,u.p)(c,"int32"));const d={x:c},h={axis:e,keepDims:n};return r.BV.runKernelFunc(((t,r)=>{r([c]);const o=(0,a.EC)(e,c.shape),s=(0,i.Q3)(o,c.rank);let u=o,d=c;null!=s&&(d=(0,p.p)(c,s),u=(0,i.sY)(u.length,c.rank));let h=t.sum(d,u);if(n){const t=(0,i.rv)(h.shape,o);h=(0,l.X)(h,t)}return h}),d,null,o.GB,h)}})},1173:function(t,e,n){"use strict";n.d(e,{O:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({tan_:function(t){const e=(0,s._1)(t,"x","tan"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.tan(e);return n([e]),r}),n,null,o.sE)}})},1869:function(t,e,n){"use strict";n.d(e,{A:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({tanh_:function(t){const e=(0,s._1)(t,"x","tanh"),n={x:e};return r.BV.runKernelFunc(((t,n)=>{const r=t.tanh(e);return n([r]),r}),n,null,o.MI)}})},701:function(t,e,n){"use strict";n.d(e,{X:function(){return s}});var r=n(3740),o=n(7852);function s(t,e,n){const s=(0,r.C)(t,n);return(0,o.H)(t,e,s,n)}},6092:function(t,e,n){"use strict";n.d(e,{R:function(){return a}});var r=n(3740),o=n(569),s=n(7852);function a(t,e){(0,o.Cq)(t);const n=(0,r.C)(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,s.H)(t,null,n,e)}},7852:function(t,e,n){"use strict";n.d(e,{H:function(){return a}});var r=n(7097),o=n(569),s=n(9155);function a(t,e,n,a){if(null==a&&(a=(0,o.D2)(t)),"complex64"===a)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!(0,o.fU)(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){(0,o.Mu)(e);const t=(0,o.NA)(e),r=(0,o.NA)(n);(0,o.hu)(t===r,(()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${r}`));for(let t=0;t<n.length;++t){const r=n[t],s=t!==n.length-1||r!==(0,o.NA)(e.slice(t));(0,o.hu)(n[t]===e[t]||!s,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `))}}return(0,o.fU)(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==a?(0,s.Os)(t,a):(0,o.xH)(t,[],!0),r.BV.makeTensor(t,e,a)}},7501:function(t,e,n){"use strict";n.d(e,{G:function(){return i}});var r=n(7097),o=n(9121),s=n(3740),a=n(569);const i=(0,n(2668).op)({tile_:function(t,e){const n=(0,s._1)(t,"x","tile",null);a.hu(n.rank===e.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`));const i=[n],u={x:n},c={reps:e};return r.BV.runKernelFunc(((t,r)=>{const o=t.tile(n,e);return r([n]),o}),u,null,o.n9,c,i)}})},3243:function(t,e,n){"use strict";n.d(e,{h:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({topk_:function(t,e=1,n=!0){const a=(0,s._1)(t,"x","topk");if(0===a.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const i=a.shape[a.shape.length-1];if(e>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${e}`);const u={x:a},c={k:e,sorted:n},[l,p]=r.BV.runKernelFunc((t=>t.topk(a,e,n)),u,null,o.cW,c);return{values:l,indices:p}}})},9065:function(t,e,n){"use strict";n.d(e,{p:function(){return i}});var r=n(7097),o=n(9121),s=n(3740),a=n(569);const i=(0,n(2668).op)({transpose_:function(t,e){const n=(0,s._1)(t,"x","transpose");if(null==e&&(e=n.shape.map(((t,e)=>e)).reverse()),a.hu(n.rank===e.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`)),e.forEach((t=>{a.hu(t>=0&&t<n.rank,(()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${e}`))})),n.rank<=1)return n.clone();const i={x:n},u={perm:e};return r.BV.runKernelFunc((t=>t.transpose(n,e)),i,null,o.G3,u)}})},9608:function(t,e,n){"use strict";n.d(e,{T:function(){return i}});var r=n(7097),o=n(9121),s=n(3740),a=n(569);const i=(0,n(2668).op)({unique_:function(t,e=0){const n=(0,s._1)(t,"x","unique",null);(0,a.hu)(n.rank>0,(()=>"The input tensor must be at least 1D"));const i={x:n},u={axis:e},[c,l]=r.BV.runKernel(o.kp,i,u);return{values:c,indices:l}}})},4136:function(t,e,n){"use strict";n.d(e,{H:function(){return i}});var r=n(7097),o=n(9121),s=n(3740),a=n(569);const i=(0,n(2668).op)({unstack_:function(t,e=0){const n=(0,s._1)(t,"x","unstack");a.hu(e>=-n.shape.length&&e<n.shape.length,(()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`)),e<0&&(e+=n.shape.length);const i={value:n},u={axis:e};return r.BV.runKernelFunc((t=>t.unstack(n,e)),i,null,o.To,u)}})},5912:function(t,e,n){"use strict";n.d(e,{a:function(){return c}});var r=n(7097),o=n(9121),s=n(3740),a=n(569),i=n(8247),u=n(2200);const c=(0,n(2668).op)({where_:function(t,e,n){const c=(0,s._1)(e,"a","where"),l=(0,s._1)(n,"b","where"),p=(0,s._1)(t,"condition","where","bool"),d=(0,u.$N)(c.shape,l.shape),h=(0,i.U)(c,d),f=(0,i.U)(l,d);1===p.rank&&(0,a.hu)(p.shape[0]===c.shape[0],(()=>"The first dimension of `a` must match the size of `condition`.")),1!==p.rank&&(0,a.k5)(p.shape,f.shape,"Error in where: ");const m={condition:p,t:h,e:f};return r.BV.runKernelFunc(((t,e)=>{const n=t.select(p,h,f);return e([p]),n}),m,null,o.xc)}})},9640:function(t,e,n){"use strict";n.d(e,{l:function(){return a}});var r=n(7097),o=n(569),s=n(1661);function a(t,e="float32"){if("complex64"===e){const e=a(t,"float32"),n=a(t,"float32");return(0,s.P)(e,n)}const n=(0,o.wT)((0,o.NA)(t),e);return r.BV.makeTensor(n,t,e)}},6577:function(t,e,n){"use strict";n.d(e,{P:function(){return a}});var r=n(7097),o=n(9121),s=n(3740);const a=(0,n(2668).op)({zerosLike_:function(t){const e=(0,s._1)(t,"x","zerosLike"),n={x:e};return r.BV.runKernelFunc((t=>t.zerosLike(e)),n,null,o.Ru)}})},4077:function(t,e,n){"use strict";n.d(e,{es:function(){return y},YD:function(){return l},_w:function(){return x},FZ:function(){return g},Vp:function(){return m},Vi:function(){return f}});var r=n(569);function o(t,e,n,o){const a=(0,r.e3)(e),c=function(t,e,n,o){const a=(0,r.NA)(e),i=o[o.length-1],c=new Array(i).fill(0),l=e.length,p="complex64"===n?u(t):t;if(l>1)for(let t=0;t<a/i;t++){const e=t*i;for(let t=0;t<i;t++)c[t]=Math.max(c[t],s(p[e+t],0,n).length)}return c}(t,e,n,a),l=e.length,p=i(t,e,n,a,c),d=["Tensor"];return o&&(d.push(`  dtype: ${n}`),d.push(`  rank: ${l}`),d.push(`  shape: [${e}]`),d.push("  values:")),d.push(p.map((t=>"    "+t)).join("\n")),d.join("\n")}function s(t,e,n){let o;return o=Array.isArray(t)?`${parseFloat(t[0].toFixed(7))} + ${parseFloat(t[1].toFixed(7))}j`:(0,r.HD)(t)?`'${t}'`:"bool"===n?a(t):parseFloat(t.toFixed(7)).toString(),(0,r.oj)(o,e)}function a(t){return 0===t?"false":"true"}function i(t,e,n,r,o,c=!0){const l="complex64"===n?2:1,p=e[0],d=e.length;if(0===d)return"complex64"===n?[s(u(t)[0],0,n)]:"bool"===n?[a(t[0])]:[t[0].toString()];if(1===d){if(p>20){const e=3*l;let r=Array.from(t.slice(0,e)),a=Array.from(t.slice((p-3)*l,p*l));return"complex64"===n&&(r=u(r),a=u(a)),["["+r.map(((t,e)=>s(t,o[e],n))).join(", ")+", ..., "+a.map(((t,e)=>s(t,o[p-3+e],n))).join(", ")+"]"]}return["["+("complex64"===n?u(t):Array.from(t)).map(((t,e)=>s(t,o[e],n))).join(", ")+"]"]}const h=e.slice(1),f=r.slice(1),m=r[0]*l,g=[];if(p>20){for(let e=0;e<3;e++){const r=e*m,s=r+m;g.push(...i(t.slice(r,s),h,n,f,o,!1))}g.push("...");for(let e=p-3;e<p;e++){const r=e*m,s=r+m;g.push(...i(t.slice(r,s),h,n,f,o,e===p-1))}}else for(let e=0;e<p;e++){const r=e*m,s=r+m;g.push(...i(t.slice(r,s),h,n,f,o,e===p-1))}const y=2===d?",":"";g[0]="["+g[0]+y;for(let t=1;t<g.length-1;t++)g[t]=" "+g[t]+y;let x=",\n";for(let t=2;t<d;t++)x+="\n";return g[g.length-1]=" "+g[g.length-1]+"]"+(c?"":x),g}function u(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}var c=n(9155);class l{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=r.NA(t),null!=n){const t=n.length;r.hu(t===this.size,(()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||r.rQ(e,this.size),this.strides=(0,r.e3)(t)}set(t,...e){0===e.length&&(e=[0]),r.hu(e.length===this.rank,(()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`));const n=this.locToIndex(e);this.values[n]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const n of t){if(n<0||n>=this.shape[e]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}e++}let n=t[t.length-1];for(let e=0;e<t.length-1;++e)n+=this.strides[e]*t[e];return this.values[n]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return p().makeTensor(this.values,this.shape,this.dtype)}}let p=null,d=null,h=null;function f(t){p=t}function m(t){d=t}function g(t){h=t}class y{constructor(t,e,n,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=r.NA(t),this.strides=(0,r.e3)(t),this.dataId=n,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return d.buffer(this.shape,this.dtype,t)}bufferSync(){return d.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return(0,r.GX)(this.shape,t)}arraySync(){return(0,r.GX)(this.shape,this.dataSync())}async data(){this.throwIfDisposed();const t=p().read(this.dataId);if("string"===this.dtype){const e=await t;try{return e.map((t=>c.v5(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataSync(){this.throwIfDisposed();const t=p().readSync(this.dataId);if("string"===this.dtype)try{return t.map((t=>c.v5(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await p().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(p().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return d.print(this,t)}clone(){return this.throwIfDisposed(),d.clone(this)}toString(t=!1){return o(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),d.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),p().makeVariable(this,t,e,n)}}Object.defineProperty(y,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed});class x extends y{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!r.cO(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);p().disposeTensor(this),this.dataId=t.dataId,p().incRef(this,null)}dispose(){p().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(x,Symbol.hasInstance,{value:t=>t instanceof y&&null!=t.assign&&t.assign instanceof Function})},747:function(t,e,n){"use strict";n.d(e,{T_:function(){return s},Vu:function(){return a}});var r=n(4077),o=n(1221);function s(t,e){if(t.dtype===e.dtype)return[t,e];const n=(0,o.x8)(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function a(t){const e=[];return i(t,e,new Set),e}function i(t,e,n){if(null==t)return;if(t instanceof r.es)return void e.push(t);if(o=t,!Array.isArray(o)&&"object"!=typeof o)return;var o;const s=t;for(const t in s){const r=s[t];n.has(r)||(n.add(r),i(r,e,n))}}},3740:function(t,e,n){"use strict";n.d(e,{C:function(){return u},_1:function(){return p},sI:function(){return d}});var r=n(7097),o=n(2885),s=n(4077),a=n(569),i=n(9155);function u(t,e){let n=t;if((0,a.fU)(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||(0,a.fU)(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&(0,o.OB)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&c(t,r,[]),r}function c(t,e,n){if(n=n||[],!Array.isArray(t)&&!(0,a.fU)(t))return void(0,a.hu)(0===e.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`));(0,a.hu)(e.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`)),(0,a.hu)(t.length===e[0],(()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`));const r=e.slice(1);for(let e=0;e<t.length;++e)c(t[e],r,n.concat(e))}function l(t,e,n,r){if(null!=t&&("numeric"!==t&&t!==e||"numeric"===t&&"string"===e))throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}function p(t,e,n,o="numeric"){if(t instanceof s.es)return l(o,t.dtype,e,n),t;let c=(0,a.D2)(t);if("string"!==c&&["bool","int32","float32"].indexOf(o)>=0&&(c=o),l(o,c,e,n),null==t||!(0,a.fU)(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t){const r=null==t?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const p=u(t,c);(0,a.fU)(t)||Array.isArray(t)||(t=[t]);const d="string"!==c?(0,i.Os)(t,c):(0,a.xH)(t,[],!0);return r.BV.makeTensor(d,p,c)}function d(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map(((t,r)=>p(t,`${e}[${r}]`,n)),r)}},1221:function(t,e,n){"use strict";var r,o,s,a,i;n.d(e,{x8:function(){return c},z4:function(){return l}}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(r||(r={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(o||(o={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(s||(s={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(a||(a={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(i||(i={}));const u={float32:a,int32:o,bool:s,complex64:i};function c(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return u[t][e]}function l(t){return c(t,"int32")}},9155:function(t,e,n){"use strict";n.d(e,{cO:function(){return o.cO},hu:function(){return o.hu},bT:function(){return o.bT},e3:function(){return o.e3},xH:function(){return o.xH},rQ:function(){return o.rQ},WP:function(){return o.WP},QB:function(){return o.QB},NE:function(){return o.NE},D2:function(){return o.D2},JZ:function(){return o.JZ},GN:function(){return o.GN},tI:function(){return o.tI},qy:function(){return o.qy},nY:function(){return o.nY},EC:function(){return o.EC},WD:function(){return o.WD},oj:function(){return o.oj},NA:function(){return o.NA},YP:function(){return o.YP},bp:function(){return o.bp},Sm:function(){return o.Sm},GX:function(){return o.GX},Os:function(){return s},zO:function(){return a},he:function(){return i},YW:function(){return u},v5:function(){return c}});var r=n(2885),o=n(569);function s(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=o.xH(t)),(0,r.OB)().getBool("DEBUG")&&o.D5(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error(`Unknown data type ${e}`)}function a(){return(0,r.OB)().platform.now()}function i(t,e){return(0,r.OB)().platform.fetch(t,e)}function u(t,e="utf-8"){return e=e||"utf-8",(0,r.OB)().platform.encode(t,e)}function c(t,e="utf-8"){return e=e||"utf-8",(0,r.OB)().platform.decode(t,e)}},569:function(t,e,n){"use strict";function r(t,e,n){return Math.max(t,Math.min(e,n))}function o(t){return t%2==0?t:t+1}function s(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function a(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function i(t,e,n=""){a(p(t,e),(()=>n+` Shapes ${t} and ${e} must match`))}function u(t){a(null!=t,(()=>"The input to the tensor constructor must be a non-null value."))}function c(t,e=[],n=!1){if(null==e&&(e=[]),Array.isArray(t)||N(t)&&!n)for(let r=0;r<t.length;++r)c(t[r],e,n);else e.push(t);return e}function l(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function p(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function d(t){return t%1==0}function h(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function f(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function m(t,e=(t=>0),n){return new Promise(((r,o)=>{let s=0;const a=()=>{if(t())return void r();s++;const i=e(s);null!=n&&s>=n?o():setTimeout(a,i)};a()}))}function g(t,e){let n=1,r=-1;for(let e=0;e<t.length;++e)if(t[e]>=0)n*=t[e];else if(-1===t[e]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${e}`);r=e}else if(t[e]<0)throw Error(`Shapes can not be < 0. Found ${t[e]} at dim ${e}`);if(-1===r){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(0===n)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const o=t.slice();return o[r]=e/n,o}function y(t,e){const n=e.length;return a((t=null==t?e.map(((t,e)=>e)):[].concat(t)).every((t=>t>=-n&&t<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`)),a(t.every((t=>d(t))),(()=>`All values in axis param must be integers but got axis ${t}`)),t.map((t=>t<0?n+t:t))}function x(t,e){const n=[],r=[],o=null!=e&&Array.isArray(e)&&0===e.length,s=null==e||o?null:y(e,t).sort();let a=0;for(let e=0;e<t.length;++e){if(null!=s){if(s[a]===e&&1!==t[e])throw new Error(`Can't squeeze axis ${e} since its dim '${t[e]}' is not 1`);(null==s[a]||s[a]>e)&&1===t[e]&&(n.push(t[e]),r.push(e)),s[a]<=e&&a++}1!==t[e]&&(n.push(t[e]),r.push(e))}return{newShape:n,keptDims:r}}function v(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error(`Unknown data type ${t}`);n=new Uint8Array(e)}return n}function b(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error(`Unknown data type ${t}`);n=new Array(e)}return n}function w(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function $(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}function C(t,e){return!("complex64"===e||"float32"===e&&"complex64"!==t||"int32"===e&&"float32"!==t&&"complex64"!==t||"bool"===e&&"bool"===t)}function N(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function I(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function E(t){if(null==t)return 0;let e=0;return t.forEach((t=>e+=t.length)),e}function T(t){return"string"==typeof t||t instanceof String}function k(t){return Array.isArray(t)?k(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":"number"==typeof t?"float32":T(t)?"string":"boolean"==typeof t?"bool":"float32"}function S(t){return!!(t&&t.constructor&&t.call&&t.apply)}function R(t,e){for(let n=e;n<t;++n)if(t%n==0)return n;return t}function _(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function A(t,e,n){const r=new Array;if(1===e.length){const o=e[0];for(let e=0;e<o;e++)r[e]=n[t+e]}else{const o=e[0],s=e.slice(1),a=s.reduce(((t,e)=>t*e));for(let e=0;e<o;e++)r[e]=A(t+e*a,s,n)}return r}function D(t,e){if(0===t.length)return e[0];const n=t.reduce(((t,e)=>t*e));if(0===n)return[];if(n!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}.`);return A(0,t,e)}function O(t,e){const n=F(t,e);for(let t=0;t<n.length;t++)n[t]=1;return n}function F(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function B(t){t.forEach((e=>{a(Number.isInteger(e)&&e>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`))}))}function P(t,e,n){if(0===e)return 0;if(1===e)return t[0];let r=t[t.length-1];for(let e=0;e<t.length-1;++e)r+=n[e]*t[e];return r}function M(t,e,n){if(0===e)return[];if(1===e)return[t];const r=new Array(e);for(let e=0;e<r.length-1;++e)r[e]=Math.floor(t/n[e]),t-=r[e]*n[e];return r[r.length-1]=t,r}function L(t){return t&&t.then&&"function"==typeof t.then}n.d(e,{uZ:function(){return r},nY:function(){return o},Sm:function(){return s},hu:function(){return a},k5:function(){return i},Cq:function(){return u},xH:function(){return c},NA:function(){return l},cO:function(){return p},GN:function(){return d},YP:function(){return h},oj:function(){return f},WD:function(){return m},JZ:function(){return g},EC:function(){return y},bp:function(){return x},WP:function(){return v},rQ:function(){return b},D5:function(){return w},LP:function(){return $},QB:function(){return C},fU:function(){return N},bT:function(){return I},Ub:function(){return E},HD:function(){return T},D2:function(){return k},mf:function(){return S},jP:function(){return R},e3:function(){return _},GX:function(){return D},p8:function(){return O},wT:function(){return F},Mu:function(){return B},qy:function(){return P},NE:function(){return M},tI:function(){return L}})},6377:function(t,e,n){var r=n(4832),o=n(8652),s=n(801),a=n(2030),i=n(3618),u=n(9049),c=n(1971);c.alea=r,c.xor128=o,c.xorwow=s,c.xorshift7=a,c.xor4096=i,c.tychei=u,t.exports=c},4832:function(t,e,n){var r;!function(t,o,s){function a(t){var e,n=this,r=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(t),n.s0<0&&(n.s0+=1),n.s1-=r(t),n.s1<0&&(n.s1+=1),n.s2-=r(t),n.s2<0&&(n.s2+=1),r=null}function i(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function u(t,e){var n=new a(t),r=e&&e.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=u:n.amdD&&n.amdO?void 0===(r=function(){return u}.call(e,n,e,o))||(o.exports=r):this.alea=u}(0,t=n.nmd(t),n.amdD)},9049:function(t,e,n){var r;!function(t,o,s){function a(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,r=e.d,o=e.a;return t=t<<25^t>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-r|0,e.d=r<<16^n>>>16^o,e.a=o-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function i(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function u(t,e){var n=new a(t),r=e&&e.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=u:n.amdD&&n.amdO?void 0===(r=function(){return u}.call(e,n,e,o))||(o.exports=r):this.tychei=u}(0,t=n.nmd(t),n.amdD)},8652:function(t,e,n){var r;!function(t,o,s){function a(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function i(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function u(t,e){var n=new a(t),r=e&&e.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=u:n.amdD&&n.amdO?void 0===(r=function(){return u}.call(e,n,e,o))||(o.exports=r):this.xor128=u}(0,t=n.nmd(t),n.amdD)},3618:function(t,e,n){var r;!function(t,o,s){function a(t){var e=this;e.next=function(){var t,n,r=e.w,o=e.X,s=e.i;return e.w=r=r+1640531527|0,n=o[s+34&127],t=o[s=s+1&127],n^=n<<13,t^=t<<17,n^=n>>>15,t^=t>>>12,n=o[s]=n^t,e.i=s,n+(r^r>>>16)|0},function(t,e){var n,r,o,s,a,i=[],u=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,u=Math.max(u,e.length)),o=0,s=-32;s<u;++s)e&&(r^=e.charCodeAt((s+32)%e.length)),0===s&&(a=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(a=a+1640531527|0,o=0==(n=i[127&s]^=r+a)?o+1:0);for(o>=128&&(i[127&(e&&e.length||0)]=-1),o=127,s=512;s>0;--s)r=i[o+34&127],n=i[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,i[o]=r^n;t.w=a,t.X=i,t.i=o}(e,t)}function i(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function u(t,e){null==t&&(t=+new Date);var n=new a(t),r=e&&e.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=n.next,o.quick=o,r&&(r.X&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=u:n.amdD&&n.amdO?void 0===(r=function(){return u}.call(e,n,e,o))||(o.exports=r):this.xor4096=u}(0,t=n.nmd(t),n.amdD)},2030:function(t,e,n){var r;!function(t,o,s){function a(t){var e=this;e.next=function(){var t,n,r=e.x,o=e.i;return t=r[o],n=(t^=t>>>7)^t<<24,n^=(t=r[o+1&7])^t>>>10,n^=(t=r[o+3&7])^t>>>3,n^=(t=r[o+4&7])^t<<7,t=r[o+7&7],n^=(t^=t<<13)^t<<9,r[o]=n,e.i=o+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function i(t,e){return e.x=t.x.slice(),e.i=t.i,e}function u(t,e){null==t&&(t=+new Date);var n=new a(t),r=e&&e.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=n.next,o.quick=o,r&&(r.x&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=u:n.amdD&&n.amdO?void 0===(r=function(){return u}.call(e,n,e,o))||(o.exports=r):this.xorshift7=u}(0,t=n.nmd(t),n.amdD)},801:function(t,e,n){var r;!function(t,o,s){function a(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function i(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function u(t,e){var n=new a(t),r=e&&e.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=u:n.amdD&&n.amdO?void 0===(r=function(){return u}.call(e,n,e,o))||(o.exports=r):this.xorwow=u}(0,t=n.nmd(t),n.amdD)},1971:function(t,e,n){var r;!function(o,s){var a,i=this,u=256,c=s.pow(u,6),l=s.pow(2,52),p=2*l,d=255;function h(t,e,n){var r=[],d=y(g((e=1==e?{entropy:!0}:e||{}).entropy?[t,x(o)]:null==t?function(){try{var t;return a&&(t=a.randomBytes)?t=t(u):(t=new Uint8Array(u),(i.crypto||i.msCrypto).getRandomValues(t)),x(t)}catch(t){var e=i.navigator,n=e&&e.plugins;return[+new Date,i,n,i.screen,x(o)]}}():t,3),r),h=new f(r),v=function(){for(var t=h.g(6),e=c,n=0;t<l;)t=(t+n)*u,e*=u,n=h.g(1);for(;t>=p;)t/=2,e/=2,n>>>=1;return(t+n)/e};return v.int32=function(){return 0|h.g(4)},v.quick=function(){return h.g(4)/4294967296},v.double=v,y(x(h.S),o),(e.pass||n||function(t,e,n,r){return r&&(r.S&&m(r,h),t.state=function(){return m(h,{})}),n?(s.random=t,e):t})(v,d,"global"in e?e.global:this==s,e.state)}function f(t){var e,n=t.length,r=this,o=0,s=r.i=r.j=0,a=r.S=[];for(n||(t=[n++]);o<u;)a[o]=o++;for(o=0;o<u;o++)a[o]=a[s=d&s+t[o%n]+(e=a[o])],a[s]=e;(r.g=function(t){for(var e,n=0,o=r.i,s=r.j,a=r.S;t--;)e=a[o=d&o+1],n=n*u+a[d&(a[o]=a[s=d&s+e])+(a[s]=e)];return r.i=o,r.j=s,n})(u)}function m(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function g(t,e){var n,r=[],o=typeof t;if(e&&"object"==o)for(n in t)try{r.push(g(t[n],e-1))}catch(t){}return r.length?r:"string"==o?t:t+"\0"}function y(t,e){for(var n,r=t+"",o=0;o<r.length;)e[d&o]=d&(n^=19*e[d&o])+r.charCodeAt(o++);return x(e)}function x(t){return String.fromCharCode.apply(0,t)}if(s.seedrandom=h,y(s.random(),o),t.exports){t.exports=h;try{a=n(3906)}catch(t){}}else void 0===(r=function(){return h}.call(e,n,e,t))||(t.exports=r)}([],Math)},2571:function(t,e,n){"use strict";n.d(e,{xF:function(){return s},Bs:function(){return a},dq:function(){return i},cA:function(){return u}});var r=n(2212),o=function(){for(var t=0,e=0,n=arguments.length;e<n;e++)t+=arguments[e].length;var r=Array(t),o=0;for(e=0;e<n;e++)for(var s=arguments[e],a=0,i=s.length;a<i;a++,o++)r[o]=s[a];return r};function s(t,e){var n=document.createElement("div");return n.style.position="absolute",n.style.left="50%",n.style.top="50%",n.style.transform="translateY(-50%) translateX(-50%)",n.style.width=t+"px",n.style.height=e+"px",n}function a(t){var e=t.videoWidth/t.videoHeight,n=t.offsetWidth,r=t.offsetHeight;return n/r>e?n=r*e:r=n/e,[n,r]}var i=function(t){return e=void 0,n=void 0,s=function(){var e;return function(t,e){var n,r,o,s,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return s={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function i(s){return function(i){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(o=2&s[0]?r.return:s[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,s[1])).done)return o;switch(r=0,o&&(s=[2&s[0],o.value]),s[0]){case 0:case 1:o=s;break;case 4:return a.label++,{value:s[1],done:!1};case 5:a.label++,r=s[1],s=[0];continue;case 7:s=a.ops.pop(),a.trys.pop();continue;default:if(!((o=(o=a.trys).length>0&&o[o.length-1])||6!==s[0]&&2!==s[0])){a=0;continue}if(3===s[0]&&(!o||s[1]>o[0]&&s[1]<o[3])){a.label=s[1];break}if(6===s[0]&&a.label<o[1]){a.label=o[1],o=s;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(s);break}o[2]&&a.ops.pop(),a.trys.pop();continue}s=e.call(t,a)}catch(t){s=[6,t],r=0}finally{n=o=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,i])}}}(this,(function(n){return e=new r.dpR,[2,new Promise((function(n,r){e.load(t,(function(t){n(t)}),void 0,(function(t){r(t)}))}))]}))},new((o=void 0)||(o=Promise))((function(t,r){function a(t){try{u(s.next(t))}catch(t){r(t)}}function i(t){try{u(s.throw(t))}catch(t){r(t)}}function u(e){var n;e.done?t(e.value):(n=e.value,n instanceof o?n:new o((function(t){t(n)}))).then(a,i)}u((s=s.apply(e,n||[])).next())}));var e,n,o,s},u=function(t,e){var n,s=new r._fP;(n=t.position).set.apply(n,e[0]);var a=(new(r.Pa4.bind.apply(r.Pa4,o([void 0],e[1].map((function(t,n){return t-e[0][n]})))))).normalize(),i=(new(r.Pa4.bind.apply(r.Pa4,o([void 0],e[2].map((function(t,n){return t-e[0][n]})))))).normalize().cross(a);s.setFromUnitVectors(i,new r.Pa4(0,0,1)),t.setRotationFromQuaternion(s)}},188:function(t,e,n){"use strict";var r=n(2212),o=function(){function t(t){var e=this;this.scene=new r.xsS,this.listener=new r.SJI,this.renderer=new r.CP7({alpha:!0}),this.clock=new r.SUY;var n=this,o=n.renderer,s=n.scene,a=n.clock,i=n.listener;this.camera=new r.iKG(t.clientWidth/-2,t.clientWidth/2,t.clientHeight/2,t.clientHeight/-2,-500,1e3),o.setSize(t.clientWidth,t.clientHeight),this.camera.add(i),t.appendChild(o.domElement);var u=function(){requestAnimationFrame(u),e.update(a.getDelta()),o.render(s,e.camera)};requestAnimationFrame(u)}return t.prototype.update=function(t){},t}();e.Z=o},7333:function(t,e){"use strict";e.Z=function(t){return e=void 0,n=void 0,o=function(){var e,n;return function(t,e){var n,r,o,s,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return s={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function i(s){return function(i){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(o=2&s[0]?r.return:s[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,s[1])).done)return o;switch(r=0,o&&(s=[2&s[0],o.value]),s[0]){case 0:case 1:o=s;break;case 4:return a.label++,{value:s[1],done:!1};case 5:a.label++,r=s[1],s=[0];continue;case 7:s=a.ops.pop(),a.trys.pop();continue;default:if(!((o=(o=a.trys).length>0&&o[o.length-1])||6!==s[0]&&2!==s[0])){a=0;continue}if(3===s[0]&&(!o||s[1]>o[0]&&s[1]<o[3])){a.label=s[1];break}if(6===s[0]&&a.label<o[1]){a.label=o[1],o=s;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(s);break}o[2]&&a.ops.pop(),a.trys.pop();continue}s=e.call(t,a)}catch(t){s=[6,t],r=0}finally{n=o=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,i])}}}(this,(function(r){switch(r.label){case 0:return(e=document.createElement("video")).setAttribute("playsinline","true"),e.style.transform="scaleX(-1)",t.appendChild(e),[4,navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:"user"}})];case 1:return n=r.sent(),e.srcObject=n,[2,new Promise((function(t){e.onloadedmetadata=function(){e.play(),t(e)}}))]}}))},new((r=void 0)||(r=Promise))((function(t,s){function a(t){try{u(o.next(t))}catch(t){s(t)}}function i(t){try{u(o.throw(t))}catch(t){s(t)}}function u(e){var n;e.done?t(e.value):(n=e.value,n instanceof r?n:new r((function(t){t(n)}))).then(a,i)}u((o=o.apply(e,n||[])).next())}));var e,n,r,o}},9776:function(t,e,n){"use strict";var r=n(2571),o=n(7333),s=(n(1263),function(t,e,n,r){return new(n||(n=Promise))((function(o,s){function a(t){try{u(r.next(t))}catch(t){s(t)}}function i(t){try{u(r.throw(t))}catch(t){s(t)}}function u(t){var e;t.done?o(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(a,i)}u((r=r.apply(t,e||[])).next())}))}),a=function(t,e){var n,r,o,s,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return s={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function i(s){return function(i){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(o=2&s[0]?r.return:s[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,s[1])).done)return o;switch(r=0,o&&(s=[2&s[0],o.value]),s[0]){case 0:case 1:o=s;break;case 4:return a.label++,{value:s[1],done:!1};case 5:a.label++,r=s[1],s=[0];continue;case 7:s=a.ops.pop(),a.trys.pop();continue;default:if(!((o=(o=a.trys).length>0&&o[o.length-1])||6!==s[0]&&2!==s[0])){a=0;continue}if(3===s[0]&&(!o||s[1]>o[0]&&s[1]<o[3])){a.label=s[1];break}if(6===s[0]&&a.label<o[1]){a.label=o[1],o=s;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(s);break}o[2]&&a.ops.pop(),a.trys.pop();continue}s=e.call(t,a)}catch(t){s=[6,t],r=0}finally{n=o=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,i])}}},i=n(9987);function u(){return s(this,void 0,void 0,(function(){return a(this,(function(t){switch(t.label){case 0:return[4,i.load()];case 1:return[2,t.sent()]}}))}))}var c,l=n(2212),p=(c=function(t,e){return(c=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n])})(t,e)},function(t,e){function n(){this.constructor=t}c(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)}),d=function(t){function e(e){void 0===e&&(e=500);var n=t.call(this)||this;n.size=e,n.fireConfig={speed:1,fireColor:{top:[0,128,255],bottom:[255,128,255]},opacity:0},n.uniforms={time:{value:1},topColor:{value:[0,0,0]},bottomColor:{value:[0,0,0]},opacity:{value:0}};var r=new l._12(e,e),o=new l.jyz({uniforms:n.uniforms,vertexShader:"varying vec2 vUv;\n\nvoid main()\n{\n  vUv = uv;\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  gl_Position = projectionMatrix * mvPosition;\n}\n",fragmentShader:"precision highp float;\nuniform float time;\nuniform vec3 topColor;\nuniform vec3 bottomColor;\nuniform float opacity;\nvarying vec2 vUv;\n\nfloat noise(vec3 p){\n  vec3 i=floor(p);\n  vec4 a=dot(i,vec3(1.,57.,21.))+vec4(0.,57.,21.,78.);\n  vec3 f=cos((p-i)*acos(-1.))*(-.5)+.5;\n  a=mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)),f.x);\n  a.xy=mix(a.xz,a.yw,f.y);\n  return mix(a.x,a.y,f.z);\n}\n\nfloat sphere(vec3 p,vec4 spr){\n  return length(spr.xyz-p)-spr.w;\n}\n\nfloat flame(vec3 p){\n  float d=sphere(p*vec3(.5,.6,1.),vec4(.0,-.7,.0,1.));\n  return d+(noise(p+vec3(.0,time*6.,.0))+noise(p*3.)*.5)*.25*(p.y);\n}\n\nfloat scene(vec3 p){\n  return min(100.-length(p),abs(flame(p)));\n}\n\nvec4 raymarch(vec3 org,vec3 dir){\n  float d=0.,glow=0.,eps=.02;\n  vec3 p=org;\n  bool glowed=false;\n\n  for(int i=0;i<64;i++)\n  {\n    d=scene(p)+eps;\n    p+=d*dir;\n    if(d>eps)\n    {\n      if(flame(p)<.0)\n      glowed=true;\n      if(glowed)\n      glow=float(i)/64.;\n    }\n  }\n  return vec4(p,glow);\n}\n\nvoid main(){\n  vec2 v=-1.5+3.*vUv;\n\n  vec3 org=vec3(0.,-2.,4.);\n  vec3 dir=normalize(vec3(v.x*1.6,-v.y,-1.5));\n\n  vec4 p=raymarch(org,dir);\n  float glow=p.w;\n\n  vec4 col=mix(vec4(topColor,opacity),vec4(bottomColor,opacity),p.y*.02+.4);\n\n  gl_FragColor=mix(vec4(0.),col,pow(glow*2.,2.));\n}\n"});o.transparent=!0;var s=new l.Kj0(r,o);return n.add(s),n}return p(e,t),e.prototype.update=function(t){var e=this.fireConfig,n=e.speed,r=e.fireColor,o=r.top,s=r.bottom,a=e.opacity;this.uniforms.time.value+=t*n,this.uniforms.opacity.value=a,this.uniforms.topColor.value=o.map((function(t){return t/255})),this.uniforms.bottomColor.value=s.map((function(t){return t/255}))},e}(l.Tme),h=n(188),f=n.p+"assets/fire.ce353bd.wav",m=function(){var t=function(e,n){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n])})(e,n)};return function(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}(),g=function(t){function e(e){var n=t.call(this,e)||this,r=new l.BbS(n.listener);return(new l.mTL).load(f,(function(t){r.setBuffer(t),r.setLoop(!0),r.setVolume(0),r.play()})),n.sound=r,n.fire=new d(e.clientWidth/2),n.scene.add(n.fire),n}return m(e,t),e.prototype.update=function(t){return e=this,n=void 0,o=function(){var e;return function(t,e){var n,r,o,s,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return s={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function i(s){return function(i){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(o=2&s[0]?r.return:s[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,s[1])).done)return o;switch(r=0,o&&(s=[2&s[0],o.value]),s[0]){case 0:case 1:o=s;break;case 4:return a.label++,{value:s[1],done:!1};case 5:a.label++,r=s[1],s=[0];continue;case 7:s=a.ops.pop(),a.trys.pop();continue;default:if(!((o=(o=a.trys).length>0&&o[o.length-1])||6!==s[0]&&2!==s[0])){a=0;continue}if(3===s[0]&&(!o||s[1]>o[0]&&s[1]<o[3])){a.label=s[1];break}if(6===s[0]&&a.label<o[1]){a.label=o[1],o=s;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(s);break}o[2]&&a.ops.pop(),a.trys.pop();continue}s=e.call(t,a)}catch(t){s=[6,t],r=0}finally{n=o=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,i])}}}(this,(function(n){switch(n.label){case 0:return[4,this.onUpdate()];case 1:return e=n.sent(),this.updateFires(t,e),[2]}}))},new((r=void 0)||(r=Promise))((function(t,s){function a(t){try{u(o.next(t))}catch(t){s(t)}}function i(t){try{u(o.throw(t))}catch(t){s(t)}}function u(e){var n;e.done?t(e.value):(n=e.value,n instanceof r?n:new r((function(t){t(n)}))).then(a,i)}u((o=o.apply(e,n||[])).next())}));var e,n,r,o},e.prototype.updateFires=function(t,e){var n=this.fire,r=this.sound,o=n.fireConfig.opacity,s=e[0];if(s){var a=s[0],i=s[1],u=s[2];n.fireConfig.opacity=o>=1?1:o+5*t,n.position.x=a,n.position.y=i,n.scale.x=u/n.size,n.scale.y=u/n.size,n.fireConfig.speed=i/n.size+1,n.fireConfig.fireColor.bottom[0]=Math.floor((a+1)/2),n.fireConfig.fireColor.top[1]=Math.floor((i+1)/2),r.setVolume(n.fireConfig.opacity)}else n.fireConfig.opacity=o<=0?0:o-5*t,r.setVolume(n.fireConfig.opacity);n.update(t)},e}(h.Z),y=function(t,e,n,r){return new(n||(n=Promise))((function(o,s){function a(t){try{u(r.next(t))}catch(t){s(t)}}function i(t){try{u(r.throw(t))}catch(t){s(t)}}function u(t){var e;t.done?o(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(a,i)}u((r=r.apply(t,e||[])).next())}))},x=function(t,e){var n,r,o,s,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return s={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function i(s){return function(i){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(o=2&s[0]?r.return:s[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,s[1])).done)return o;switch(r=0,o&&(s=[2&s[0],o.value]),s[0]){case 0:case 1:o=s;break;case 4:return a.label++,{value:s[1],done:!1};case 5:a.label++,r=s[1],s=[0];continue;case 7:s=a.ops.pop(),a.trys.pop();continue;default:if(!((o=(o=a.trys).length>0&&o[o.length-1])||6!==s[0]&&2!==s[0])){a=0;continue}if(3===s[0]&&(!o||s[1]>o[0]&&s[1]<o[3])){a.label=s[1];break}if(6===s[0]&&a.label<o[1]){a.label=o[1],o=s;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(s);break}o[2]&&a.ops.pop(),a.trys.pop();continue}s=e.call(t,a)}catch(t){s=[6,t],r=0}finally{n=o=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,i])}}};!function(){y(this,void 0,void 0,(function(){var t,e,n,i,c,l,p,d,h,f=this;return x(this,(function(m){switch(m.label){case 0:t=document.getElementById("app"),m.label=1;case 1:return m.trys.push([1,3,,4]),[4,(v=t,s(void 0,void 0,void 0,(function(){var t;return a(this,(function(e){switch(e.label){case 0:return[4,u()];case 1:return t=e.sent(),[4,(0,o.Z)(v)];case 2:return[2,[e.sent(),t]]}}))})))];case 2:return e=m.sent(),n=e[0],i=e[1],c=(0,r.Bs)(n),l=c[0],p=c[1],d=(0,r.xF)(l,p),t.appendChild(d),new g(d).onUpdate=function(){return y(f,void 0,void 0,(function(){return x(this,(function(t){switch(t.label){case 0:return[4,i.estimateHands(n)];case 1:return[2,t.sent().map((function(t){var e,n,r=t.boundingBox,o=r.topLeft,s=o[0],a=o[1],i=r.bottomRight,u=i[0],c=i[1];return[(n=[l,p])[0]/2-((e=[s,a,u,c])[0]+e[2])/2,n[1]/2-(e[1]+e[3])/2,e[2]-e[0],e[3]-e[1]]}))]}}))}))},[3,4];case 3:return h=m.sent(),alert(h),[3,4];case 4:return[2]}var v}))}))}()},3906:function(){},8352:function(){},1758:function(){}},0,[[9776,321]]]);